<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nova`s Wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://quano.gitee.io/"/>
  <updated>2024-09-13T17:58:09.219Z</updated>
  <id>https://quano.gitee.io/</id>
  
  <author>
    <name>Nova</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.特征工程方案v2</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/006.%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/002.%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%A1%88v2/"/>
    <id>https://quano.gitee.io/wk/算法/006.算法工程/特征工程/002.特征工程方案v2/</id>
    <published>2024-09-13T16:48:57.000Z</published>
    <updated>2024-09-13T17:58:09.219Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="563e303cdb3426b4fb51159ac39fd0c4c546cc96a9bab82c381972667725505a">6529a249a0af82b27e00ec9fb492a165cdeff919c1e3b0b703e0a95a87175d9ed7a5c883bcadff8f31ba8d3dc435c7ca1057c012cfb74a29b9d5c33d5760faf76473a6bd65d8534a757a3150120603b173a10db068ac96ba44c63630b4305466f0fb469137a9f69468657216d0d460a6f09ed1cf16a1c64a21e019065f9dac659d9c3dea5efa452fd99137f21390733ba14e1412a87806c43a98681345d839977bd860c37ead04c46a2234573b19413ca2b561648e9e86413b700ec080b4012eb9a33b06499bb72ba0e769985d6b15037bb45ba642a7f6e0e68cfd1645727f8ca27a0cee0d8b975b1773c6748f7dfc52f381a849275ec555f43b310ae96c0ff0bd7b4e9d76f31b0af22bff90c4cc8e8dbd97490cb15acb926805d279c4e8100e387b0e6e8a2d7fc2ed42791e84dac4a96284f913ac28890860188575398719ae086a48937d98b1068a560c245ea88e960ebbf7431d9ea0458899180d91a3204b37a4b819623cfd321479d29cc75ff8208f9c55bf9cc580954a6f294443f21bc3135cb0fad994ea5492475335ae2b59a712f34491b2ab8858bd69709ed93a9aa8f3cc3aa651fa6e33408bf002e7ce9ab6dcfc03026ecfdf4dfe9f47181911c2acf34b98c9ca1c73f42e7604042728517fefc213c84921addcefa13f9e97717e89611149662b25445fe2ad4aa0456a064fb68a3f89d384e7dc1847515950b6c21e58d579562c8c4ea4a1e2025d81fdb099d3089e761a2e4b4c50fff08b82d6bb77a3195d1f6a8afa323fb13ad6ab18331e9e86e2e192aff59d5aa452268d61f6336b30cb0626d12fa41995820447da4877fbbae805e94e7bf2a6869a2b6f4fb60e316d1f4eae2173b294385963173aa6b3e768812d4676188217abbdda1cc6af52497cf1c0788e6131b2b003510104193953ffdca850ac504ef2bde92697271418849c9b6441ca7bbc0fdc901e74631a1bbd49a88ca1d7ec4a0241a96d8cd7bc3b1d4a9146028cc3db7a6bc44aa2f80353e205468408ae6bc1f9907eb399ea8cbf206f4bd35ef2cc4d1d02fb2bb6cfaf29ded24067d4fae9926d237ecfce1ae581b49f455369761f10d596bdc45a0d8427156979edfde9949c750ed4a1a016011debbda6e16170b7148ee577067ff60c9008b201414dc12a32d5a2df076b20b3fd4943492e2fb1b4bd2262a70b70f87033753b46951ab8e31f0c82ad9a5c7c2a78eaf7dab277726af30d22034cd2355e47c06b78293a312df48daac84626d44a35d52822047fdb27d9bfcd468f6f6f7891a5161c3bcde9c73bc3fa89abe16f78bccd61c9f273c9e2948074b2c7564b7343a78843e5d1bc6123753d1cd9afefd3011274c333b46447039b1741027d3d0bd88e0a14b05dacf1f0041bb9fb59eac83178b565fbb6af33eb1dc9e1ab8aefca3d9a0ccb9c80d171789bedaf0aa7a26bb2fbc65b5aa4107969f054f710220e9f4c789b4c8eda0f10629f06e36b2747042ce3db6918154a57dd48ea42d57685b4c029e8a2f65ba5055fa00739d1b91985a2f0f2c17834941bab0aeedc11d65e872628900ab1cc42280ec2226aa97d8e28e2696101c323390527de79ff97d43bfafe37aac086bfa6b9221e747cd6c580c994b6adf47b365c06b39229894781f0bddf1f35ed8f12e3c07c892a8b936a18a70951cfb94b13dfa2348727adb4e98d877cf8edc7b3821c7de758c37fc7b24773ba52ab8d9eccad24cd6606ba2d0127da8040abcf65dc86fd1d0f8da2f62eb3dad8462e9703660454af4df376c00d1517f242dae3b92dea4c915ed8bf472b83296544654c01d5c0eb162ba99e9f4dc2fe73208a073156b367a2ce224f6ce368b94fad575a4b81baa6159ec327043372de172ded0feb8ef7ff5eb12bc090088024ae8e2a47ff9ee1e01d0c9d233059bc7e6bc55c91a0f270550c4377197b53d6a368b406130b9790bbc6399325bf684277e6f3a17376adb532d14f3128a3ad8b3599876a76217f40a260e91355a54f9fcbb684310fabb30c4fa0e19065b8bca7376c145620b4f508aa6b0edb38f31efa2e4d8cc10089100bc174d457b2138281a2254f4360b7c164ef1416a23a63a49a81b13bfee8916c419fa30fc57cd8ea2457d1c3ee33d1c6f6ca94563b4b2fddea141583ed632289f14f3b07bf9d426ce5c8316b213e3693d49ea0977627bd181aa018ea8065fe1747f13c9ec4c55230c7d7252ac2f21b63a088ccf2188ab8cf79c65ba964420746aae73ae2357b17e3a5ddcf8c53fedea46504173c5c6d22adc7ab5de41cbc28c1c3235c96baa16bbc19e1194fbf9c4a57679cccb848700dc9b2f969d605d7fd609340b166d7d6385ae1f0085912099a19f48e602b723e6b1e5506fa63d858eec67fd60222964344c7efbf86c61b971109e6e1f9ea313dba1419bf7a05db35d2da0c426263de70af3c1743ba1241f31a5d9205084782678293154d5cb93e82da4f3a6654a9a92a4ab74973a148640d4bc98d5e0391dc93ee35be2a51c0d218a07fe4a9f455af8701799a0d9d1e48c34d456c37a1075b3a12d8eb559db4f1889ad3ee023ebbd721c0e1d679e9eb840db5fcedb063fdf0451159de7290c8d0d3e55e56d65a28ce443ad05803da621f88deffef534f2bdfb2219fe70dac23b1a1bb7612e6c9c28497e498efd9a28bb885c50f55695c0829d0ccc8fd2ef18981d1d81584b6e99db9e69858dd5ee0a7f0ec518256cd4a6d0cf2399e4995e2bdee009cc7a37cba296ee5fd665adc0c3d878399b1f80ed62737199b9c35dbd45b5a44d2fc3cd23067729f503f24b484f9ddb028297a4bdf9837e7fd2abd0f5bbe8ce37f7ec85b4d23771a3cc1d5364bb6e5e9d4027c74078c0fa30c9e3aa71493515d3c817b80b19a916a6af49adbc01b8996d0ba7d952c34744f5f9a1568c34671d5e5de35b51b304925216a99573505359a38df5ac978bda3aebd0d8aa78bd649654cd6e143fdb69708ac2e5fb436f4ad6d8c12dbbf58cbd58cbbbdd48aaa4bde5d9bc3569216aacbe3b2b4cc25903594ec50da1134f81111e37d8cedc8debe3556edd3114dabac6e8e9f889d4f2df819316a4972bc34d95de05c44131113d38470cc21eb274f4272bb0ac27011af118c04141917910ff0c47bfd03d465cda39b41b04ac7cf8f82ee770f1cb768581f09788f957085b0f37352f19bc2ef75716450c2003c7525b550e5db68a01d18a61672da0cfa6c08c74d50618d17e86a0add955a1f43d8d872d03c50abd4c82baaa6e8c31cfbd75eb0d26d59abf347d77cb05e8917043b6d523f9a79d20f97578488e819f5236701edc2c2cb4302529c1dd90be0718911dc14412117e6e09d322c2e9814cc4ab2b6d78e591c6c61267b101b5f8c3a816f643a6026b8f027c8e3607cf8381be5833e52f0c0ccceec50b1370c5ae35465a4c6ea1cbcae4016f87560148079b700fcc1b6663038bc83a278c22078427dbfc856b77c0a9e4d0746c13f0840c2e467a3fe3f5c4698944b3aa85cbfda85bad9311298226d30b93cd78ede602040fb29b064d7db76acc2e9b6e6163c49bfb536dc8c270f6cfeacc5bc3c22e520dcfa20e455344e150252674ecf2d7d4193246a9c5a175e9a8bc336f92678496fd4cbc678cb0fe517b5626c91bbd58e5480ce76635faf38ea4ba854562006c680da0a22e15b02a0f63dda7692b7c5d18944050a5120643131cf33306adb17ea8521d38592b599297388168761f61b4c6994cfd5a2cdbbcc1adcf9d8ea8c018b3f5ae4de260849c0c3470f5b87258c4db2f9eb4d87cbdc892468a803c9329918cfad8e33876ce9c3f7c4d25f2bae22534d9aae97e63a8974b9af52452028d21dcd11fd638bd1cfafec2d6afd988100e02a5a50b7c3f3c4aa54fa8219fbd925143b29d7158447ed094fdf875ba3fbe4e5bfda24057f103c17c0e4c54ef8511b725c37e43aff1f1641305da948f15e37a283749a7cc0be1258f86d5e40bb950f5cbefd006a45d20865e5a3dee6c38d160ad67b1a44497842fc3c2576163a34a7bf5b136541c93151b5fc01ed8dd21f76f9974e938e5ef325562a929b80ceee812747d88287792e0dabae18d59c11b6dd5349165a1d4ab40076633a5432e36b84aabc8ef2065d80293b1bf6dc5541ec8fe8f9db623e01e290bc39074ba92ed64de8f5331d1b3bd45d167a7cbf682b0f850f88d05635e8263e4aa75dd0907fe6dc9cd1e941e91bfb9076c86baa4cd03051935125a07b4c463ebc0ccf1014ccb0a9b2db30a7890cdefc669b4a0f1c9fbcd138238328f9ed725311c4288d617e5dc9f3879349b3aec291a9ae55714f11642c10770327d564e8befa97a68c2e80e92d4775f1d2139b1ff906425c9b3c1ba0e7ba299c16f2a18d9eabfcbcde45ccd84701714761d6d63703e120eea5c7e897a1fd058a4577bd69d2b522f3eb4f5d31e3f58eb1340fb21920edae3802d244e7618ddf85c159877152ddbd84619c2132e2907b5f7a4a443c18ab0adbc8511afd0b6a5eb5a77581e051f31e56ad21f951e284ef0a370e0b37a95cfe778a48da81e02df1b147d27ab540b3e870159a5576dc0bbf3958976c073fa8cd1dd9e3fa9677f8c083d00df036700a518dac609080b2f14df266be90e50a69a651faff25d50b979dfb7145751647908bc7f016c4e82b30c5f1851639671cd2ea43815a9dc28be0699791474b7157e1aa532a54de0d8381c3e4cbfc191e168a93b98dba28a11bb4e3a880af2c90bbb09c8cfa0f788e643f96d038c24dccd21862441132584e674a0f1c68f9499aa509fd9a358bb9cc098bbac1dcab19682f6ec42b19d650c7b49fe04f0f3a39abd73e59e3d69b3201f1eccf506747df461afaacf64fe5deca93e359706fa752f4b5ebbe55de6eb160a25be95e4eb319a1b44101580ac963433fd473ab36537e9f8786fd907bff9e60dce3175549da45762b86b9eb8f010e35</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，需要密码才能继续阅读。
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="006.算法工程" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/006-%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="特征工程" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/006-%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="private" scheme="https://quano.gitee.io/tags/private/"/>
    
      <category term="feature engineering" scheme="https://quano.gitee.io/tags/feature-engineering/"/>
    
  </entry>
  
  <entry>
    <title>2.软件系统建模工具_UML</title>
    <link href="https://quano.gitee.io/wk/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/002.%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7_UML/"/>
    <id>https://quano.gitee.io/wk/平台工具/01.架构设计/01.架构设计体系与方法论/002.软件系统建模工具_UML/</id>
    <published>2024-08-17T14:55:57.000Z</published>
    <updated>2024-08-18T15:14:24.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-UML介绍"><a href="#1-UML介绍" class="headerlink" title="1. UML介绍"></a>1. UML介绍</h1><p>关键词：系统建模、系统分析与设计、统一建模语言、软件建模与系统设计</p><h2 id="1-1-UML概念-What"><a href="#1-1-UML概念-What" class="headerlink" title="1.1 UML概念(What)"></a>1.1 UML概念(What)</h2><p>UML 的全称是 Unified Modeling Language，即统一建模语言。 </p><span id="more"></span><h2 id="1-2-可以做什么-Where-应用场景"><a href="#1-2-可以做什么-Where-应用场景" class="headerlink" title="1.2 可以做什么?(Where-应用场景)"></a>1.2 可以做什么?(Where-应用场景)</h2><ul><li>软件开发项目：项目启动阶段，用例图可用于明确系统的功能需求和用户期望； 类图有助于设计系统的类结构和它们之间的关系，为编程实现提供清晰的蓝图。</li><li>企业信息系统规划：组件图和部署图能描绘系统的组件构成和物理部署情况，辅助企业IT基础设施的规划和优化。</li><li>数据库设计：通过类图和实体关系图(ERD)的结果，可以有效的设计数据库的表结构和关系。</li><li>业务流程建模：活动图可清晰地展示复杂的业务流程，帮助发现流程中的瓶颈和优化点。</li><li>系统集成：序列图和协作图有助于理解不同系统之间的交互方式和消息传递，从而实现高效的系统集成。</li><li>技术选项和架构决策：基于UML图对系统的描述，可以更有针对性地选择合适的技术框架和架构模式。</li></ul><h2 id="1-3-为什么用UML-Why-重点"><a href="#1-3-为什么用UML-Why-重点" class="headerlink" title="1.3 为什么用UML?(Why-重点)"></a>1.3 为什么用UML?(Why-重点)</h2><p>首先 随着软件系统的复杂度越来越高，并且软件开发迭代过程中往往有许多角色参与和使用，怎样从不同角色视角更好理解这个软件系统?<br>其次，对软件系统以及各个模块组件清晰的理解有助于大家建立相同的认识便于软件生命周期过程中沟通和协作和减少理解偏差，<strong><em>有助于软件设计人员更准确设计更好的系统</em></strong>。</p><p>而UML工具包含不同的图表(模型)，提供不同的角度来让各个角色更清晰的认识系统。各角色人员包括系统分析师、设计师、程序员、测试人员、客户、技术文件撰稿人员。</p><p>那UML都有哪些图表呢，以及重要常用的有哪些呢？接下来详细介绍</p><h2 id="1-4-UML图表类型"><a href="#1-4-UML图表类型" class="headerlink" title="1.4 UML图表类型"></a>1.4 UML图表类型</h2><p>大致分为结构性图表和行为性图表</p><h2 id="1-4-1-结构性图表"><a href="#1-4-1-结构性图表" class="headerlink" title="1.4.1 结构性图表"></a>1.4.1 结构性图表</h2><p>七中结构性图表包括：</p><ul><li>类图 (Class Diagram)</li><li>组件图 (Component Diagram)</li><li>部署图 (Deployment Diagram)</li><li>对象图 (Object Diagram)</li><li>包图 (Package Diagram)</li><li>复合结构图 (Composite Structure Diagram)</li><li>轮廓图 (Profile Diagram)</li></ul><h2 id="1-4-2-行为性图表"><a href="#1-4-2-行为性图表" class="headerlink" title="1.4.2 行为性图表"></a>1.4.2 行为性图表</h2><p>行为性图表显示了系统中对象的动态行为 ，可用以表达系统随时间的变化。行为性图表有七种类型：</p><ul><li>用例图 (Use Case Diagram)</li><li>活动图 (Activity Diagram)</li><li>状态机图 (State Machine Diagram)</li><li>序列图 (Sequence Diagram)</li><li>通訊圖 (Communication Diagram)</li><li>交互概述图 (Interaction Overview Diagram)</li><li>时序图 (Timing Diagram)</li></ul><h1 id="2-UML图表"><a href="#2-UML图表" class="headerlink" title="2. UML图表"></a>2. UML图表</h1><p>其中最常用和最重要的2个是类图和时序图。</p><h2 id="2-1-结构性图表"><a href="#2-1-结构性图表" class="headerlink" title="2.1 结构性图表"></a>2.1 结构性图表</h2><h3 id="2-1-1-类图"><a href="#2-1-1-类图" class="headerlink" title="2.1.1 类图"></a>2.1.1 <span style="color: red;">类图</span></h3><p>(Class Diagram)<br>类图是一切<strong><em>面向对象方法</em></strong>的<em>核心建模工具</em>。描述了系统中<strong><em>对象的类型</em></strong>以及它们之间<strong><em>存在的各种静态关系</em></strong>。</p><h4 id="1-关系"><a href="#1-关系" class="headerlink" title="1. 关系"></a>1. 关系</h4><p>类图有三种主要的关系</p><ul><li>关联：代表类型之间的关系（一个人为公司工作，一间公司有多个办事处）</li><li>继承：传为实例关系图(ERD)应用于面向对象设计而设的一种关系。 它在面向对象设计中的继承概念相互呼应。</li><li>聚合：面向对象设计中的一种对象组合的形式。</li></ul><p>各种关系的强弱顺序：泛华=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p><ul><li>关联(Association)：表示类之间的联系，可以是单向的或双向的，具有名称、角色和多重性等属性。例如：学生和课程之间存在关联，一个学生可以选择多门课程，一门课程可以有多个学生选修。</li><li>聚合(Aggregation)：表示整体与部分的关系，部分可以独立于整体存在。比如，汽车和轮胎，轮胎可以从汽车上拆下来而任然存在。</li><li>组合(Composition)：表示整体与部分的关系，但部分不能独立于整体存在。例如，房子和房间，房间不能脱离房子而单独存在。</li><li>集成/泛华(Generalization)：表示子类与父类的关系，子类继承父类的属性与方法。比如，哺乳动物是动物的子类。</li><li>实现(Realization)：类与接口之间的关系，表示类实现了接口中定义的操作。例如，一个具体的排序类实现了排序接口定义的排序方法。</li></ul><p>参考：<a href="https://blog.csdn.net/qq_43530773/article/details/118250152">CSDN:九种常见的UML图总结</a></p><div>    <img src="https://gitee.com/quano/www/raw/master/img/architecture/uml_class_diagram.png"         style="display: inline-block;margin-left: 18px; width: 75%"/>    <span style="display: block; margin-left: 18%;width: 70%"></span></div><p>在 UML 类图的描述中，一般在较为宽泛地提及类之间的联系时，可以使用“relation”这个统称（draw.io中不同的线段表示）。<br>而使用具体的关系类型，如关联、聚合、组合、继承、实现等，通常基于以下情况：<br>当需要清晰准确地描述类之间联系的特定性质和约束时，应使用具体的关系类型：</p><ul><li>如果强调类之间是一种普通的连接和交互，没有明确的整体部分关系或层次关系，就使用关联。</li><li>当要表明整体和部分之间部分可以独立存在于整体的关系，使用聚合。</li><li>若要突出整体和部分之间部分不能独立于整体存在的强拥有关系，就用组合。</li><li>对于表示类之间的层次分类，子类继承父类的特性，采用继承（泛化）关系。</li><li>当类需要实现某个接口定义的方法和行为时，使用实现关系。</li></ul><p>例如，如果只是简单地说“这些类之间存在某种关系”，可以用“relation”。但如果要详细说明“学生类继承自人员类”“汽车类和发动机类是组合关系”，就会使用具体的关系类型。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-UML介绍&quot;&gt;&lt;a href=&quot;#1-UML介绍&quot; class=&quot;headerlink&quot; title=&quot;1. UML介绍&quot;&gt;&lt;/a&gt;1. UML介绍&lt;/h1&gt;&lt;p&gt;关键词：系统建模、系统分析与设计、统一建模语言、软件建模与系统设计&lt;/p&gt;
&lt;h2 id=&quot;1-1-UML概念-What&quot;&gt;&lt;a href=&quot;#1-1-UML概念-What&quot; class=&quot;headerlink&quot; title=&quot;1.1 UML概念(What)&quot;&gt;&lt;/a&gt;1.1 UML概念(What)&lt;/h2&gt;&lt;p&gt;UML 的全称是 Unified Modeling Language，即统一建模语言。 &lt;/p&gt;
    
    </summary>
    
      <category term="平台工具" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"/>
    
      <category term="01.架构设计" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="01.架构设计体系与方法论" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="UML" scheme="https://quano.gitee.io/tags/UML/"/>
    
      <category term="系统建模" scheme="https://quano.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>信息安全与机器学习.md</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/004.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/004.应用场景/001.机器学习在安全领域的应用/</id>
    <published>2024-08-02T14:55:57.000Z</published>
    <updated>2024-08-29T16:39:31.967Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="004.应用场景" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/004-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    
    
      <category term="MchineLearning" scheme="https://quano.gitee.io/tags/MchineLearning/"/>
    
  </entry>
  
  <entry>
    <title>202409</title>
    <link href="https://quano.gitee.io/wk/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/1.%E8%AE%A4%E7%9F%A5%E8%BF%AD%E4%BB%A3/202409/"/>
    <id>https://quano.gitee.io/wk/项目管理/生活学习/1.认知迭代/202409/</id>
    <published>2024-07-24T01:56:24.000Z</published>
    <updated>2024-09-11T17:06:32.995Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="88f6b63b31373a2a23a83dac9d506254acc093bdb15761d510b872a70a106e02">6529a249a0af82b27e00ec9fb492a1659ff8fda0a35558e278766fb72a62643e7fcd9f90993037927a71dab0441c9dd57925126635a6bcdbd6944e6922ceddf5a45352c593ec510e48b99bad3d80943c1b94ee4facb8f0f0046ba19bd98b6db75ef13e6381284c5ab94c74b5d663d6d5c35040364cfb92f8b60cecfd963ec402498eb2e7f83651a2add3c5e13903c06e759e750bb04ab82cc008ca343e875a51cc98cfb43e0bdde13fd88f5a2be49783606a75b1ce69159d3ece6f33bc8dc94a1444811fc36f26fd82c9985933400467701d74710cd7e52f6bcec6b9ae05b47b194cf6b0463b354fc054afec1061ee945fe41069fb1c13ec4111ff3c7248a283ba6a335cdf4f65ab727b31381eea9de9da0e35771501cfc8e547b8c86cb6727e75a4d400b53e8654ada402a1addc0d2887758fe7451957a139436a76651361440c8df3c8e4d1258c2cbe9dd168c67c6b649a067974f720f58bba6ef8ce24d839e3607b37ab5a48f26e2716f2753b47369e3fd63503f1db4fce25185bd7f782f4a3bd2f43fd78b07de7e93b5b0b4945344e5daf8bd0ed958de7b579d3c8e2d0f0e0c167612b83f22436ce312728101dfb65a5cb6d452577ab3dc36101b3f2a2a125bef579aa826fe529d377f33e82e662fba052a62e96d6a4e658a72f6f2f5187395cd22d27815aa57327def860ef65828b98cf780455c020bf94c0dcaeaf3983361a90d2125006253f2dd6eaf9ad9306e4d6dd8fe4601eae85ed37c812d7c34d7267df94ca9c070734954eab27117a090ef02b485338c641d00281fbf0b8165d237275fc6309839581f446f2c2a066300b7ae4df8e7554529613772e3d69210ea924665edeec1b1085cb06caa1c330c58551ab897f5e21e113aac78ed4c8290ba25e5be23b9595a9786b85413dad5a706d639ae7f7a7d7565f49e9c0a0c6cac0de2476ea5dabf27e794ad943411ec3045424c7741cb9c680a7498975e8878fb1483eb66ed5e0945f2d066c4277b25dd08e6a09e68999c3c2a445967639bcf987769aa95d9c6737cd291870977f9a063e95781a4cebd9f6a161a88ea093e3ee0aeb104324217732341b14701cff49f65db3192c48e58434fe6337e09616049621e3d030006830e86fe6b330c375de3d5796c94a6477b0952dd45ea7f2d886212f92e7eb343026d5fac0a5e1358d09d3d3816a54d75ab808e87daf5c7372c04de98b9fac290216ad6408998ea5b4e3a49ed600b812927586a8cd98237881776002b7e0adacb25ad78b296bb029949540b1250671e0570cc54e66a3e4a50b81aa8de2fa29e755d630e41d846dccc426a5185be528d0f88cfbab3e4690e871ee2db6dc7aedb11f91d86020b307669de78c2a1eaa6281d2d98dc0e471e7fd21bf8b9e10b3e0272c56bca9f758a57ebd145dcd3ddc9cd3c99c52064e93565d3595ead47d39c4cce5b35649b13a662c579099cc3e9af0f8e71d518db29c3b21ad9a48740f55b1d64df08918869a1850e6ecd6fb35279e0daaba5d76ed54937dd7356d5a6ac906bcfdbd8a56a56b572125bb40033b05ce8715966ba8598666c5135c651258bc74c5ac4e7ad0dd805ebbe7ef26ae2e37a47a8175e1282b10900d068fa1d6430bbb7db4d2d6b4f60118fa155a2967647fd2db9fcdfd1b18b3d9143672a713f2bf3772a9607b4d223f3f08e4d5bbaa01e0f42c025e7d1e096c9dd9cfb3326a3c276503e683ef3fa825377fb1df1ce2c14478226e3978b36a34dba3e5de2eef424f82aa6d449235578370c942afbbe2bbcd48a7c0db3ee49ad5ad69847cf8fb8c561e420294f72ff0997be8eabdd02b7a2d39b9dec4f0d3b30ab4cbee216823034c51469a4393365383fa10d1b49bbc514650d99501737105f651495746abc0c8ec8f95f8d0d6df65a6807a57e1763ac59e29095a11b3104b81adf72832a3bcf181d1bb293e53f77d57461368177a8dd7b9c91f684b753427fd2b7c90d1921f68f2e1bef6a35c06dee80a94f7397b6058160f0c5312a548aeecc025d4e68f338fb460c7a01b81adadc3129a66f4963745ffd3bdfea0c6a4ad1e5026cc58dc02f816a618ab6a2265f4385f17e6817228a152e8a702685a6092202b2bfdd7c7d62503e771de02d74f95ad1b49a3fa1b9a9733fc97aa3570703b11b802863887e982d2ed5cb859047b8370d1fc281d544fa354431007c885f5f2b90b79321da88a553ac6a3466a3255a85bce81cdc312e229203fa5f962edd5cb9c4a7053d1fb4fc734894208fc7a50827aa8c52024a85e6b128e12e3cdc949541417cf708af161771ded30ad61ce3d480c823ae36a6b1b8bb6459519b2b9f5955e1a797b9dcbb84fe483f16d7f98e1e017e6e74411363c01174e7516b62c4edc7417e70f47b94e1f19f719a4677ebc9244542bd6d48568b33601c07d248d2ec3934947c0166081559dece8c9947312fefc7f4ee5cd4f4c6c87fbeb773c5f8fd569473e0c609d41a195e3688865ac75a2eeccfc9209cd01de5afc872a237868e5e0d3210740fca2b4c85613aae18c03d591b1f0ceeb35e14c38a9feb47614db09059832aca8032d8c671536d555190bfb1b641e54ae4921c4da864f009edfb3cf57b02022e7d30edbfc96d4c231c88fd2b9fe78052aad9893fc9688332b41fa6e97601d1b8fbd9c8a4198b412be502346199a1129e112c0158cbee0307814c6e7b36b947a2d131ceb3722cbce0e7d4796fc20257fc67863cbd7cb4679090fc348cfbb34005c80f11e6831bd859f0e7884b7f2f4225d520e48e368228cf94605354653286bfa09bb261785eca30b757c3321e7c6978d288b1a5489117b74b34484b7fd4f84ee4de0a18ae4ae94b4156cb5c2c0839af0310c79c92346c508874f5eb28f7b0e904730227354e1bd7ead6a124934df5446f44ab5b04d8fe9deafe3e858039f3f29c3bc7f747d031e1bf9c883cb9e0552c519769d0c8868181891f70243c1b56862462d93c4ef86ff7f2e09c8ec475147a5ddfe23a4a6b4327ba383156d1f81b582ee02cf538c273a2245f7f8f6750e7b41d9295abd471cb02e5f9139227cacc32455880dc56c915ccee603279fd42e831faaf93507ac5c2c3d480f2c1d129fdc953814cbf68bc2130eb923b334938e9ba71f2d0e9e0c0e064569894ef2e7dd440b60105eb032e9d380dc56aac8fcc641c05e5698bcac6d9581fed10d0db6e8d37568b399c9503aaa698653117f77da8488c239bbf7369ebf320da682bdf88bb41a84f4be45c1bb240eb6ff94833c0d8715ac75c470707f6b95d1829af8f1242a37f4788e512ae4ff470f6a4ded996e24cbabfc2373d31023d4f02148b76000b05df47803c9989670237b6bcc541652516f4f559f786a1675b49b8b47a9077d57a3580ff84905e56d0c261515aac846a5ca2899d1a14c526afeb77ea22e33d7fb4c0ca05eb1dc37193715550825685598e0e20d46571899b9810b0988442d7d2a0636c2e1e07b012e9d2c734102bd1ac743777f4b61c9a98f61a7a5c1af0ff5cbaadd94197ebbe986fccc7495aa2b77c2df79dd1a1f8ba39569cbe7cfbd11f467a9c24f76181caa2d3f5ab7b24c4ffb338a80d9303ec918deca74d55a869cdf2ab63dd71bc17ce6b28035534dcfa9f991dbcd1ab415566537cf7a89df087446f027ee092c221e2e97e9c1328ce16dfee76491198c5c12ea5f2943514bc23663053d81695d5314c49a41b3c44299a0aec963c9c708da49c8020a8109980de384e777d0571f79ef3b4c661718470f36f981d80c99e86756134c4c09eac9447fc4954422d14297831940cb504d5804bc93d0cf21c7b51b631400ef92ba545edf06994d4a171e7785db888611f4b44c62939d76e26d9f5192c4e4aaeee8e3e61d14cc0225f3e978987b85402b5a178d208db57227111c11f31e48939425e6cd29206fcc3e9e66d75df8898d235c01ab231090077e0a6e61876f36412ebb534156a13cd57eadf34ef59f7e36fe9bee2b014122fbd1e19ce9f6d1008d737b9b8827275567b4ce647c2dc4be5757ce98f929aeaf5cfc81879c06431866867d77f4d30913818d802a033e9588cf6de7d6008ff491cd7eaa3a036d2c9e498cea5f258f4556a83087a1eaad6f491fad3a62829c0d3de1f2b25e4a0065b4786bfbe03d0aab757ad51034ca23f7d5757f490d2efb99717710341e16a6ab802cf930c574ccad516b7aa9fe18023d16806ce1b37cff5f4331ca4d71e31fe73c98e6336ec6e12001ae33755ee83c88c95bbb3d6edc1755b35b38616fdc719c35b3c14e32775b768d0e598b2a5ac1aabb28e0d1f719ceb5338d417342f9b49560190a8cbc8e38f4d73ee9266c4117bb60a2439dd111493eb3ac50e1d7c6c2732d7a7c4fdeab07316e3474e5110523c71dc884c69ced2b828fb5875fd38f860ffe079ee9cd24927217828c13f641e57f9757e1d77088ee39d1aedcc353c965d6bb1ec6bac763f11c46a93ec2e66b8b471c6f40c2dec1b3858304f944e617da258220472407fe87c80aaa24e54d1ea1045ed30bbf77858e6ba1c52b0318a6b31dc97f19d6ae00495b21c497501e3f7738f6d839ac1fa43292f39eed41e61d2ce4ca7baad07ac4372427a8776fb9b77e69518de1bdf67385d7882d90075bc45720f0220085cbe1f2e9174c219e3bce4f82640578fc15649778622de4264666eed067ffd84776b761bd7ef2662e2adfe44dc971a96083d3a1286437b8099d8ac9b81b9a0ab2bb070466cf57f641b11952e81fb9c302b98cc282a4f626c7f742fb42e2c4e7d45ded4b3bb2557e7fc783b0b03b2a56ce5144c877177ae5d0d6934d58ddfba99455b084c575c99c70228e99ce8fd0b314171ab4a9963693d98f84d54872e5b5c85a25d62846ad85e7ee884fddc96e234d5df959840972e0c819e636f1e23352e045be3bcacb3df9951ec82f445b9dfd803671fb65f892e9ef95b7ca7616f0eb9cded5338106e8413ecfa0783a9b1d100828e148dd4fb4bc6857d9b95394a5f7ef24b1a53278be6324b49bf76d1351393685e2e8ec4b6dd5c7d1cc4c356e02c5d8fcc5d0cdc2fbb29ef4e708561aa63beba89852812b118f856167b6fd1cbd147beb280d2b8158c10c373639b6bc8cb2f06e796ef26e4e41800aebae78884a2d62ac37f20a6ede182f626ecfdcbe4e4aabc767b5f2b799bf306419d43297e4e8214f313412ecf821f5b07d61ebf2a066410234758ffda8658fdff68a98bd25bcc821c9c9adb73c8ffdbfede464c91361c390a7d92771489cc3ca85479e371a02e6aa25b22f0fa13be840d10b0ee8f0ae78c18377d9cb04291b7a11fb51fd7a9773051083668960640661d81647b39eb74d169ce81c7efa9981c5928ff3777b630908fcaa82aa7db3a6660f7ea6c77fe3bdd2520491910da63b20a759581b4c021e659a042d497f89a7aa0ecc0d79d99797ad30dd9949648a65a7811da8910a49cae01ecec0ce663128349e3771b5ba8cfef0d50fd7ba55b67c4c9d724cee99942f4885ac3a457bd48dbc96b0fda090357a6ad8e271e042c3fd0cd1d1de703dcd09460f18a5b9cea87234f349f944a475840679887b64e1ea6e97b591547c963d9be89bb5f432c645d3061916fc010e6979f084141b28b2dcec2d5f3e4e9494da336a2ca702a493f705f74e6dbd162debb695ee2073bec19a981721ca93eb12184097bfdb5d5d805700a4c0b5bc41956194f695b49c6b197f5761f4e91e9f2202ab9904e1a473fcadf1afb1516c3a6c5da2a35328e6108f8b0e690670c20180bc3c45e1bd4761ba481782343ab03678ccdc6435b1a84636da01641f4c0a2ddc63fdcf90d2ae52e0b228db8a47e9394f425514cf870743a01e9c824794cf4c5a51798821692d973a7d4168d17e91bf683828a420cd62e77e59b77bc328cec16fbd24e29a7cd43b423e71318b4f542c6990334bb9509b54e80fb9832d305b1c0aeaa975801de2bcc875c852a9d51dbe5bb91362c4fc8a71015a9957eeae3883659bc29741bbd4ba06d428634b354347a06f21d68d59926494462a756cc9644eeee0c999a9df5aae790c3784d629f7af9c8771de80c84dedaf91c7478bba0249b4141919bd22bdc072dac365c278b2eeba42b55e18ebe99d9c7ab69d1c28f3924331d69bd0635540f55b2e4265c004ac3efb363cb4ff00189cbd43b3ac8736120f4e66be8f7629c126047dd1c3922e46b0f3db521c0ae6fe0d9303c9c1cbfbd0560e92c6875c79f76720f48b7e2f578c5561d3437f93beaf3cf9ae59d8d7da6a9aef7b77f65388a8f208560747c4cd62921ccfee7c4730c5cdf5a6314911f7ac8b43cb2e95ef3e0e390392db86339c6cb511fcca73efa97050d4e84d3e1a02fa9fb3d4ba8daa6284543168e14b3916b60dca11408530820a63f5d0cfb52dcf5c9e613c790338e038b9aa527f9a7580796bb0be5c9fe269e01d2bd0053ca68f1811e7ccde0fcf98361f5fe1d24607fb12af58592b6edcfb8718edbc3041450a51e56f035cd7b93c2e68342822c62ad2955ddd2cfe5ac25cb1a92854a46d8cb022200ed17d3d562a409fa5bd00b5b5528356b9f374d8bcef6b53df82c6ac330d557bb9154a31383b4fafce8e6db0b4c14f1b4158e34c0dab3d55c4f1982e5988ddbd72537d4d0080106c6edba1f09f45eb43779374790920ae146dbf1ef6848aa1de342faf140b1fecb77885dc763faf39afbd94f4283f922fca4d7bedb1cef55f9d54500bf51a9b792f363989c20ee19dfa73668f959360e4e121c56439ee50482c4f3f9b1047127376d3aaca8a5d4f0a568ceaac4c106ad0e341c2d4e8a84d6e1b3ba0c7b3ac12035e025e8c85e7cf7544e6855db8f632950644c840ee4ff418b050eb7de9f9eef42ac0457afdb33427840162be8c29db4f6f6b007070615a4052f5408e53c633b9037fb643f42e82080e7782f6187590bd9a6d41f8b51755ab6a36e33e4f104244e0876608fa86bc9d9fd1f9fed4c48809476bf2eecd9b784c1aa1aad1d432241cfffe5ff1eb2d843556b295cadb492f8e02146603d99470c2b4fc98aa213978f008b8ab813785dabc00a901d478ae2d30b944d0a8a7c21ae8a3a18ef524435ae02750c4bb23e7f6929da3ca29170a0409642e195c01f4298593c05413cb48275ef1da265c5129a64681a04ee03d28942fa7ab1878bd92104d6b45ffdf5db401f340d8b012f323b6d72cb8ef9c339a8fdaa10b856045b83e9cc9bde98c4952a275c71b43cf490b30c70f8b0e2f179caf04cb8db75576ab01639fc4f8f1ce9f35b9846423245eaf861a36c62427b2d17446b984704c2aa40670fcef9cd6c554dd29a561069c9aa56947c90737b191495c1afeaad4e6b4903361d67972f74a01149a2db806551edadde8678ffe7e09f6d01a30679308a77dba7eb781caaedf26917c136802f85c2bfc19b8d9543da7cb438bfcfd37244a7ac65b659070a568706243827236840be1e28a86d294b9c81dfa35d690dd897f88b13c5c5f97ef5777c2b7537b2c6b04af1efcb77a22bb8354185d6677b11d2c7c88ca6189a0d27490d6ee9914ffc0f80c59a8c1504c7dc5729d4d04d11cef8bfaddac15b145391c6a5df1153d51602bc9d4751856fc930fbbbd0cc8fe180de7f2924430bcb8c1317cbad6afc6afe43f56efcfb4a079c4d90f7b087e47c2aba976ad89a06d20cf9bd09c4e59d4fb7dc3abfb1197da6523580eff442d401977ba76e083ac82c29057168c6e3a90358c6f31aba4364603eef46f1ffe5fc01404e721b1bf973cc89d33de0410dbbe8da9658b4f89eaf4a5f6f9fedc614a37da8c93b7eae9f3f81f3c639505eee1b24b2f9253218aa21b2258d17c80ff2cafffed9ece73ed8e611ad9a5c21da9b171a3f849dbaa10c96b9b08049839e119ec857b721fd12c172977867a018a7dd9ff7f5da9a7bd46ddf44e7fa4ddfbdb1c08c7c62470ac64fd903842c76dd61f9733ffc35deeeb3571657ddb65a482d43ef0b468b6f66ab622b8a7222b1379825e9373efcf4dface11e9a68402d0e3940ace85f4e11a01fda17b822cb32448696b0d110ef85658a50d73a90f32390497be4e2bbcfd0de506694328b3eb31700e7810d3daabe2b3f7e35f61527978360b3c6534de9d6ce525b8dc8da525d324194c2651a33b3415167b7cc4b87cf9a7ed7689982753fa1118cccc6093615358031782c36b71dc9954901ae3ab9e9cbe15891866a395955c62daa7946953754469dc7de79daa40abd25a477b9e77befe5634b52e79f3e9665cd3bd5c6b9519315dac8435cb120078c1cac5c23fb8d8463b9f37465f4701bf06b9a0352828fe3722261c0b88fad6c9c8a15a2725694f2ad57f9c6dfdab78deb1d1ae9040a7fd1fa5586b730e192a2e9ebf367c78c1200989c1953d3581ed97dc07aeab7e239501fccc7ffb96011a6d7248fcee9c11dd2186cf10ab56805bb27e6365784dc9bcc6cf6e6998f435befb37514948fe417d17833f0251e4e1ef43bf7b1b969aaf4ce5f43cd9aeef6d4c826ff9824b53a8593ee5be1a7cb78d46e83a0761389a2df1a4ae263b7cd8366b95185062e9ea39f97feacd7b28630f14a337895e7e24a5b606188b7b764a758291bdad934b8d3a7de2cb855846b43e0c7c681e76d4beed35b015ab5af1b25d40a44552cfb081b8264937408252cd0d9f7f863deefa2be31e6c4bdb8065fcb20d1d16fa1fb327dfe4d4533cb5820ae64cf28c1b1874bef5589ac959643ab53d892cef83a5188e99b9e25f8343303b27b03c907b3e11133871127e3bdec0e06bff48230fb0aabc9d5c09213adab2294250ee7fe8f39b0a0596e477362dcd22f6fc9839d422649676b689eac8ee2f95448e6065238859c9c39437ce75e1e55ddecd9b05d4ab8a0ffdcabf55e5b4fb390733af21df81dbcd9c446e793089fa16a0cd398b3ddb38be8a6112385cf63385e10d3ce7aed3d4679b5636160e83574a8af7cf1d5a04c3baf7c3af99384f578f9de7562cb56757de45c89b06a83446c78644fe37b67fdf7c09acd1c9028b3703eda22ee5f19a8ee559da88b473e2980ad4bfb4497e4d809e035d81ffee0a78531b6fd0a95cd105744ab17cb9210921a7ae4b4926dec977e1754ce4eb5191c145c9b2c8d3401b1edef4d3826d5956603bfd97dd5773c233990a2a232619055d0afc68040c6e81c4ac9e0ad2a78014024d6b8dfcd80a12267cb34105d8c4d9856b1d64c81f5d7be33a6ed81e28ba09ebabd0100ed09aea4e32f3d874c0415d4fe40036abb26ee755a5e496c71dac1463b4b3358fa91f2bf1ea55df00d3bb6ffafa392bd396cf5ddc55f3f60a251f445146f447fa37ede681f1ec2975c63be7763250bf26c8f57ea246556217697b54b013bb343657f68459b05e147896f2ddfe16399a8b24424893edd6a28af5cbcf4858717c465c2d7149c017a6d45b91299981f09cc3edcc5b55cb7834d451181a393c8ed63e9c3a54c80332045bc43c93b40f913a64956e049162f5f6b66cb3f87fb685c75c14b6cee589e72cc12faee29a9774214a9287b544b62619f39d7343bd37417fb4cffc5ce5ba10ac6cf3739f81c166fd1c012d1be5800d3f681afe82aabdc72d011d76eb66b91a9f2cf4aa5fffb217893649a523e9238f76e57ab0dac6a5efad080a8988a9cd955ed6aa6b63a944fcfa4de546d88ce444688b75414192564e5ebffb115b4193d2e9af866b1907695a62909aeed4f9187a75484e01f27bd67d014fe00abe1b52eca5ea5a14b0c6f1acc7eb925a1ca326111e6d07000a9cc7eb9e7319ed679c4f4f4efc0f7311f2e58e5ae09ace4372edbc18e0d79ca4a81b5d79007f1ab5882a71213abfd74627dd39793b31bfa3023666c05f334fdba0272edb4051f5a512183c12a9d7c10f1a6b1fd08a914c15eb350a84aef9fb9a8dbe7d1a3db802089a6130c3cacc2112e6234fa5085868a33ffc1c7e679b9566fee4118968b5abcae89e90c72457a7af434ce2edeba49df770300defefc55984da752f23ded0d9096eb26c33196253dc3aabdb9ee52bcb5095ae3c2dc57d1b744b72299e5e054e4d69ff3d8852e9992dbdbb6efea739ac96dde2452a3f2e1a149942c86f43ff07ba0de4c3a362b4cb7b45c7e6ae612a32cda497da47c79797b7ccad60fd4b3cba003e21ed8eb4748837e1fe629725acb0e3075c6f975916626a625e988763373513662c1c5cb49ce0f6c15e7364d4e97a67596f77036ad3f74076635d380bc138007c426b8f3bf281cf9cbe256cd170782cd83e9b34aedad5033ad852cf1479c1f49f524bb4253b9e77dacab17265181f461203b80c58e39eb8c6fa43fbf2f72be9c85a72caa961ba13702c4635bfb69ff7f808ca242819a86908d10ec0f268ff8ab43dc0101ba2c4f2d3e3a8249343151335c45b36a049dafd2359abc27c75d14255068ebcbd938389a8f4cf900ed8d8b3643f923f028f8f05ab7f83522d3a0a91b28d1d16ea18ccf3eaab3b971062dc0b0950f2eb7d9e36ff23e3e0681ef930d4e87a77289c61d71c8bd0b5093d54fddcaa6f7aad0e539eec41007682c71e317ab68edc016de12b5691062a465d02251f56d63b14d66437cd28b7ec0176c0d2e28632c5cee8c37fecd8b8243528bda5f922ee60a8ac1480aaa329f5fd1459e7c5f2cf135982cda20f8d15b4a2ae18f4c75580a74f72f95f398e6840bd0f6f382bbcbdac9d80ece8167304b05572da9bdfb1a573001c3002c348d0abd01c9d805e371a8f439f2c95c3b58ebd212cd0c4ceb54f378a2460e064adfdf1382bed3e46681b3cda8bd922fe69e5e226e62b6c08bd8e968a4fda91c216e263ee6dec4a3f4b2cae30aa3faf7f9f546d40a1839aa34fab38d1165ef4283f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，需要密码才能继续阅读。
    
    </summary>
    
      <category term="项目管理" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="生活学习" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="1.认知迭代" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/1-%E8%AE%A4%E7%9F%A5%E8%BF%AD%E4%BB%A3/"/>
    
    
      <category term="private" scheme="https://quano.gitee.io/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="https://quano.gitee.io/wk/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/001.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <id>https://quano.gitee.io/wk/项目管理/计算机基础/计算机网络/001.计算机网络总结/</id>
    <published>2024-07-20T15:11:57.000Z</published>
    <updated>2024-08-07T04:29:02.841Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要总结计算机网络核心的知识点，包括网络概述、网络性能指标、网络体系结构以及其中的分层细节。</p><h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><p>主要内容包括：</p><ul><li>互联网边缘部分、核心部分的作用。包括分组交换的概念</li><li>计算机网络的性能指标</li><li>计算机网络分层次的体系结构，包含协议和服务的概念。(比较抽象，需要理解概念)</li></ul><p>计算机网络通信的一个显著特点是：间歇性、突发性。</p><h2 id="1-1-互联网边缘、核心"><a href="#1-1-互联网边缘、核心" class="headerlink" title="1.1 互联网边缘、核心"></a>1.1 互联网边缘、核心</h2><h3 id="1-1-0-什么是因特网"><a href="#1-1-0-什么是因特网" class="headerlink" title="1.1.0 什么是因特网"></a>1.1.0 什么是因特网</h3><ul><li>协议：一系列规则和约定的集合。这些规则和约定用于管理<strong><em>两个或多个实体之间</em></strong>的通信、数据交换和交互操作。</li></ul><h3 id="1-1-1-网络边缘"><a href="#1-1-1-网络边缘" class="headerlink" title="1.1.1 网络边缘"></a>1.1.1 网络边缘</h3><h3 id="1-1-2-网络核心"><a href="#1-1-2-网络核心" class="headerlink" title="1.1.2 网络核心"></a>1.1.2 网络核心</h3><p><span style="color: red;"><strong><em>电路交换、分组交换(数据报、虚电路)</em></strong></span></p><p>构建网络核心有两种基本方式：电路交换、分组交换。</p><ul><li>电话交换：在通信双方进行通信之前，网络会在发送方和接收方之间简历一条专用的物理电路路径，该路径在整个通信过程中保持，直到通信结束才释放。（优点：通信质量稳定，实时性强；缺点：资源利用率低、灵活性差）</li><li>分组交换：将需要传输的数据分割成一个个较小的数据包，称为分组。每个分组都包含一个源地址、目标地址和一些控制信息，然后这些分组独立地在网络中传输，并通过网络中的节点(如路由器)根据分组的目的地址和网络的当前状态，选择合适的路径进行转发。</li></ul><p><span style="font-size: 12px;"><strong><em>一个简单的类比如：考虑两家餐厅，一个需要预定，而另一家不需要预定但不保证能安排</em></strong>。 对于需要预定的餐厅，我们离开家之前要承受必须先打电话预定的麻烦，但到达餐厅时，原则上能够立即点菜。 不需要预定的餐厅，没有预定餐桌的麻烦，但也许不得都不先等到有空闲餐桌才能找服务员点菜</span></p><p>计算机网络书中主要和因特网、分组交换有关。然而，理解因特网和其他计算机网络为什么使用分组交换，而非更为传统的用于电话网的电路交换，这一点很重要。</p><h4 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h4><p>频分复用(FDM)、时分复用(TDM)</p><h4 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h4><p>现代计算机网络中，源主机将长报文划分为较小的数据块，并称之为分组。 这些分组的每一个都通过通信链路和分组交换机(路由器或者链路层交换机)传送。</p><p>分组交换机(路由器、链路交换机)： 多数分组交换机在链路的输入端使用<strong><em>存储转发传输机制</em></strong>。 是指：在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。</p><p>存储转发时延：由于存储转发机制，分组交换机沿着该分组的路径在每条链路的输入端引入了存储转发时延。时延和分组的长度成正比。</p><p>排队时延：如果到达的分组需要跨越链路传输，但发现该链路正忙于传输其它分组，该到达分组必须在该输出缓存中等待。</p><p>分组丢失：如果一个到达的分组发现该缓存被等待传输的分组占满了，在这种情况下将出现分组丢失。（分组丢失怎么解决：超时重传、分组编号、ACK机制、流量控制、拥塞控制等待）</p><h4 id="3-数据报-虚电路网络"><a href="#3-数据报-虚电路网络" class="headerlink" title="3. 数据报/虚电路网络"></a>3. 数据报/虚电路网络</h4><p>分组交换网络有两大类：数据报网络和虚电路网络。它们的差异在于：其交换机是使用<strong><em>目的地址</em></strong>还是使用所谓的<strong><em>虚电路号</em></strong>朝其目的地转发分组。</p><p>因特网中路由器根据主机目的地址转发分组，因此因特网是一个数据报网络。</p><ul><li><strong><em>数据报网络</em></strong></li></ul><ul><li><strong><em>虚电路网络</em></strong></li></ul><h4 id="4-分组交换与电路交换对比"><a href="#4-分组交换与电路交换对比" class="headerlink" title="4. 分组交换与电路交换对比"></a>4. 分组交换与电路交换对比</h4><div class="table-container"><table><thead><tr><th></th><th>电路交换</th><th>分组交换</th></tr></thead><tbody><tr><td>时延</td><td>时延低</td><td>端到端时延:变动不可预测</td></tr><tr><td>成本</td><td>较高</td><td>低</td></tr><tr><td>效率</td><td>利用率低</td><td>简单有效</td></tr></tbody></table></div><h2 id="1-2-网络的性能指标"><a href="#1-2-网络的性能指标" class="headerlink" title="1.2 网络的性能指标"></a>1.2 网络的性能指标</h2><p>常用的7个性能指标：速率、带宽、吞吐量、时延(发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间RTT、利用率</p><p>非性能指标：费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护</p><h2 id="1-3-计算机网络体系结构"><a href="#1-3-计算机网络体系结构" class="headerlink" title="1.3 计算机网络体系结构"></a>1.3 计算机网络体系结构</h2><div>    <img src="https://gitee.com/quano/www/raw/master/img/network_layer.png"         style="display: inline-block;margin-left: 18px; width: 55%"/>    <span style="display: block; margin-left: 18%;width: 50%"></span></div><p>主要重点学习五层协议。</p><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><p>信道、单工、半双工、全双工</p><p>物理层设备：</p><p>传输介质：双绞线、光纤、电缆<br>数据通信基础：<br>信道复用技术：</p><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><p>(数据单元：帧(Frame))<br>网络分类： LAN(局域网)、MAN(城域网)、WAN(广域网)。它们的划分主要基于覆盖范围、传输速度、网络拓扑结构、管理和控制方式等因素。比如：</p><ul><li>覆盖范围：局域网一般在几千米以内，通常是一个办公室、一栋建筑物、一个校内的网络。城域网一般覆盖一个城市，通常5-50千米。</li><li>传输速度：局域网内一般10Mbps到10Gbps之间；城域网一般1Mbps-100Mbps之间，广域网一般几kbps-几Mbps之间。</li><li>网络拓扑结构：局域网(星形、总线型、环形、树形)；城域网(环形、双总线型等)；广域网(通常不规则的网络拓扑)</li><li>应用场景：局域网一般用于企业内部办公、学校教学、家庭网络；城域网一般公共服务设施、企业之间通信；广域网实现跨地区、跨国家的通信和数据传输，如互联网。</li></ul><p>这几种网络技术细节后续展开。比如WAN技术包括专线(VPN)等.</p><p>差错控制、流量控制、介质访问控制协议。</p><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><p>(重点)</p><h2 id="4-0-网络层协议"><a href="#4-0-网络层协议" class="headerlink" title="4.0 网络层协议"></a>4.0 网络层协议</h2><p>IP、ICMP、ARP、RARP、OSPF…</p><h2 id="4-1-IP协议"><a href="#4-1-IP协议" class="headerlink" title="4.1 IP协议"></a>4.1 IP协议</h2><p>网际协议：因特网中的转发和编址</p><p>因特网的网络层有三个主要的组件：IP协议、选路组件、网际控制报文协议(ICMP).</p><h3 id="4-1-1-IPV4数据报格式"><a href="#4-1-1-IPV4数据报格式" class="headerlink" title="4.1.1 IPV4数据报格式"></a>4.1.1 IPV4数据报格式</h3><p>由首部(包含选项)、数据 组成</p><p>IP数据包分片</p><ul><li>MTU(最大传输单元)：一个链路层数据报能承载的最大数据量叫做最大传输单元。</li></ul><h3 id="4-1-2-IPv4编址-重点"><a href="#4-1-2-IPv4编址-重点" class="headerlink" title="4.1.2 IPv4编址(重点)"></a>4.1.2 IPv4编址(重点)</h3><p>全球因特网中的每台主机和路由器上的每个接口必须有一个全球唯一的IP地址。<br><span style="font-size: 12px; color: blue;">这些地址不能以随意的方式自由选择，一个接口的IP地址的组成部分需要<strong><em>由其连接的子网来决定</em></strong></span></p><p>核心概念：子网、子网掩码、无类别域际路由选择、分类编址(A/B/C类)</p><ul><li>子网：子网是将较大的网络通过划分逻辑地分成较小的网络。其主要目的是为了更好的管理网络、提高网路性能、增强网络安全性和减少网络广播流量。</li><li>子网掩码：是确定IP地址中网络地址和主机地址的分隔表示。</li><li>CIDR(无类别域际路由选择)：因特网的地址分配策略。传统的IP地址分类(A/B/C类)存在地址分配不灵活和浪费的问题。CIDR摒弃了这种固定的分类方式，采用可变长子网掩码(VLSM),通过指定网络前缀的长度来标识网络。</li></ul><p>模拟信号和数字信号 是通信和电子领域中两种不同的信号类型。</p><ul><li>模拟信号 ：是一种连续的信号，其信号的幅度、频率或相位等参数随着时间连续变化。例如：传统的音频磁带记录的声音信号、有限电视的电视信号。</li><li>数字信号：是一种离散的数值表示。这些数值通常是二进制的，代表不同的状态或信息。计算机处理和存储的数据、通过数字通信线路传输的数据等都是数字信号。</li></ul><p>调制解调器(Modem)是一种在通信领域中用于在模拟信号和数字信号之间进行转换的设备。</p><h4 id="1-获取一块地址"><a href="#1-获取一块地址" class="headerlink" title="1. 获取一块地址"></a>1. 获取一块地址</h4><p><strong><em>为了获取一块IP地址用于一个组织的子网， 一个网络管理员也许首先会与其ISP联系；ISP会从已分给它的更大地址块中提供一些地址。</em></strong><br>例如：某ISP自己被分配了地址块 200.23.16.0/20。 该ISP可以依次将该地址块分成8个长度相等的较小地址块，为该ISP支持的最多达8个组织中的一个分配一小块， 如：200.23.16.0/23；200.23.18.0/23；….<br><span style="font-size: 12px; color: blue;">外界其它部分不需要知道在地址块200.23.16.0/20内实际上还存在8个其他组织，每个组织有自己的子网</span></p><p><span style="font-size: 12px; color: blue;">一块地址的分配取决于组织的具体需求和应用场景。网络规模较大、对网络的功能/性能有较高的要求，或者有特殊的网络应用需求</span></p><h4 id="2-获取主机地址"><a href="#2-获取主机地址" class="headerlink" title="2. 获取主机地址"></a>2. 获取主机地址</h4><p>一个组织一旦获得了一块地址，它就可以为该组织内的主机与路由器接口分配独立的IP地址。对于路由器接口地址，系统管理员手工配置路由器中的IP地址。 两种方式为一台主机分配一个IP地址： 手工配置、动态主机配置协议(DHCP).</p><p>除了为主机和路由器接口配置独立的IP，主要的工作还包括：规划IP地址分配方案、配置路由功能、配置访问控制列表等。</p><p><span style="font-size: 12px; color: blue;">那第1条获取一块地址我理解是从ISP获取一块公网IP， 在一个组织中，IP地址的分配、路由的配置等 实际配置的是什么？是和公网IP有什么关系呢？是怎么通过公网IP访问互联网的呢？</span></p><h4 id="3-NAT-网络地址转换"><a href="#3-NAT-网络地址转换" class="headerlink" title="3. NAT(网络地址转换)"></a>3. NAT(网络地址转换)</h4><p>背景：如果一个局域网变大了，则需要分配一块较大的地址，这时应该怎么办呢？<br>NAT：应用更广泛、更简单的地址分配方法(网络地址转换)<br>NAT中的地址用于 专用网络或具有专用地址的地域。指其地址仅对该网络中的设备有意义。<br>数以万计的家庭网络的事实，许多网络使用相同的地址空间。<br><span style="font-size: 12px; color: blue;">NAT使能路由器对于外界来说甚至不像一台路由器。对外界的行为就如同一个具有单一IP地址的单一设备。 </span><br><em>所有离开家庭路由器通向较大因特网的报文都拥有同一个源的IP地址，例如：138.76.29.7 ,且所有进入家庭路由器的报文都拥有同一个目的IP地址。</em></p><p>路由器通过从ISP的DHCP服务器得到它的地址，它再运行一个DHCP服务器(NAT-DHCP)，为家庭网络的地址空间中的计算机提供地址。<br>来自广域网到达<strong><em>NAT路由器</em></strong>的所有数据都有相同的目的IP地址，那该路由器是怎么知道它应将一个给定数据报转发给哪个内部主机呢？ <strong><em>NAT转换表</em></strong>。<br>家庭路由器一般都是NAT路由器.</p><p>虽然NAT在近几年得到广泛应用，但它也存在一些问题比如违反了所谓端到端主张、妨碍P2P应用程序等。</p><h4 id="4-IPv6"><a href="#4-IPv6" class="headerlink" title="4. IPv6"></a>4. IPv6</h4><h4 id="5-其它"><a href="#5-其它" class="headerlink" title="5. 其它"></a>5. 其它</h4><ul><li><p>怎么确认一个ip是哪类地址？<br>根据第一个字节(网络号部分)判断：A类地址范围(1-126);B类地址范围(128-191);C类地址范围(192-223);D类地址范围(224-239);E类范围(240-255)</p></li><li><p>私有地址(IETF定义，对私有IP地址的范围明确定义：满足企业、家庭等内部网络的需求，同时避免与公共网络的IP地址产生冲突)<br>A 类私有地址：10.0.0.0 到 10.255.255.255<br>B 类私有地址：172.16.0.0 到 172.31.255.255<br>C 类私有地址：192.168.0.0 到 192.168.255.255<br>这些私有地址通常用于家庭、企业等内部网络，在互联网上不可路由。 </p></li><li><p><strong><em>子网掩码：网段划分？子网掩码和IP，如何区分是否同一个网段？</em></strong>(重点)<br>当子网掩码为 255.255.0.0 时，这表示前两个字节是网络号，后两个字节是主机号。<br>假设网络地址为 192.168.0.0 ，那么同一网段中可能的 IP 地址范围是 192.168.0.1 到 192.168.255.254 。<br>需要注意的是，网络地址（192.168.0.0）和广播地址（192.168.255.255）通常不分配给具体的主机使用。<br>例如，如果网络地址是 10.10.0.0 ，那么同一网段中可用的 IP 地址就是 10.10.0.1 到 10.10.255.254 。<br>举例2：与10.110.12.29 mask 255.255.255.224 属于同一网段的主机IP地址是？<br>子网掩码 255.255.255.224 对应的子网块大小为 256 - 224 = 32 。<br>所以子网的地址范围如下：10.110.12.0 - 10.110.12.31<br>其中网络地址为 10.110.12.0 ，广播地址为 10.110.12.31 。<br>因此，与 10.110.12.29 掩码 255.255.255.224 属于同一网段的主机 IP 地址有：10.110.12.1 到 10.110.12.28 ，10.110.12.30  </p></li><li><p>组播地址<br>指在IP网络中实现一对多通信的一种特殊地址类型；<br>组播地址的范围在IPv4中是224.0.0.0 - 239.255.255.255<br>例如：视频会议、在线直播、网络教学等应用中，可以使用组播技术。</p></li></ul><h3 id="4-1-3-选路算法"><a href="#4-1-3-选路算法" class="headerlink" title="4.1.3 选路算法"></a>4.1.3 选路算法</h3><p>以上介绍了网络层的转发功能。</p><h1 id="五、其它"><a href="#五、其它" class="headerlink" title="五、其它"></a>五、其它</h1><h2 id="5-1-二进制数字调制"><a href="#5-1-二进制数字调制" class="headerlink" title="5.1 二进制数字调制"></a>5.1 二进制数字调制</h2><p>FSK、DPSK</p><p>VLAN</p><p>学习过程： 按7层从下到上依次学习。 再看TCP/IP体系结构，五层模型。</p><h1 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h1><p>计算机网络 - 第7版 谢希…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要总结计算机网络核心的知识点，包括网络概述、网络性能指标、网络体系结构以及其中的分层细节。&lt;/p&gt;
&lt;h1 id=&quot;一、计算机网络概述&quot;&gt;&lt;a href=&quot;#一、计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络概述&quot;&gt;&lt;/a&gt;一、计
      
    
    </summary>
    
      <category term="项目管理" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="计算机基础" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>GPU架构与CUDA编程模型</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/006.%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/Infra/001.GPU%E6%9E%B6%E6%9E%84%E4%B8%8ECUDA%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://quano.gitee.io/wk/算法/006.算法工程/Infra/001.GPU架构与CUDA编程模型/</id>
    <published>2024-07-03T15:55:57.000Z</published>
    <updated>2024-07-19T13:45:23.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>高性能推理引擎、AI算法工程 对GPU CUDA性能优化的诉求目前是AI行业各个公司在算法工程上需要解决的问题。 以实现高效的并行计算，充分利用GPU计算资源，实现AI算法高性能推理.</p><p>AI行业可以分为两块：<strong><em>基础设施(infra)和算法模型</em></strong>. 一方面是建设和优化支持AI应用的基础设施，让GPU更好的使用起来。另一方面是研究和应用在这些基础设施上运行的先进算法。</p><p>其中infra包括：硬件基础设施（比如GPU架构、云计算平台）、软件工具（比如深度学习框架、数据处理工具）、以及相关的网络基础设施（比如高速网络连接）。<em>GPU架构和CUDA编程模型可以被视为在这一基础设施层面的重要组成部分</em>。<br>而算法方面包括：机器学习算法（如监督学习、无监督学习、强化学习）、深度学习模型（如神经网络结构和训练方法）、以及在特定领域中的应用优化算法等。这些算法和模型构成了AI技术的核心，决定了AI系统在解决问题时的效果和性能。</p><span id="more"></span><p>本文介绍了CUDA编程模型(属于底层计算资源/硬件原理与加速)。 也包含了cuda环境搭建实践(理解cuda编程模型和GPU架构)，后续对实践部分单独拆出来。</p><h2 id="0-1-相关概念"><a href="#0-1-相关概念" class="headerlink" title="0.1 相关概念"></a>0.1 相关概念</h2><p>并行计算 CUDA核心加速库 </p><p>GPU池化、 GPU虚拟化 - 对GPU资源的分配和管控</p><p>算力平台：资源规划</p><p>国产智算芯片生态架构</p><h1 id="1-GPU架构"><a href="#1-GPU架构" class="headerlink" title="1.GPU架构"></a>1.GPU架构</h1><h1 id="2-CUDA编程模型"><a href="#2-CUDA编程模型" class="headerlink" title="2.CUDA编程模型"></a>2.CUDA编程模型</h1><h2 id="2-1-CUDA介绍"><a href="#2-1-CUDA介绍" class="headerlink" title="2.1 CUDA介绍"></a>2.1 CUDA介绍</h2><p>CUDA 是一种并行计算平台和编程模型，利用GPU的并行性能加速计算密集型任务。</p><p>熟悉并行计算的概念，如线程、块、网格等。</p><h2 id="2-2-CUDA编程模型"><a href="#2-2-CUDA编程模型" class="headerlink" title="2.2 CUDA编程模型"></a>2.2 CUDA编程模型</h2><ul><li>CUDA 编程模型涉及编写主机（CPU）和设备（GPU）端代码。</li><li>理解如何在CUDA中编写核函数（kernel functions）来在GPU上执行并行计算任务。</li></ul><h2 id="2-3-CUDA的核心概念-重点"><a href="#2-3-CUDA的核心概念-重点" class="headerlink" title="2.3 CUDA的核心概念(重点)"></a>2.3 CUDA的核心概念(重点)</h2><p>理解CUDA线程层次结构和内存管理。<br>学习如何使用CUDA工具集编译和调试CUDA程序。</p><h2 id="2-4-开发和优化CUDA程序"><a href="#2-4-开发和优化CUDA程序" class="headerlink" title="2.4 开发和优化CUDA程序"></a>2.4 开发和优化CUDA程序</h2><p>实际开发并优化具有挑战性的任务，如矩阵乘法、向量加法等。<br>学习如何优化内存访问和并行计算以提高性能。</p><h2 id="2-5-CUDA环境架构"><a href="#2-5-CUDA环境架构" class="headerlink" title="2.5 CUDA环境架构"></a>2.5 <span style="color: red;">CUDA环境架构</span></h2><p>CUDA是由NVIDIA推出的并行计算平台和编程模型，主要用于利用GPU进行通用目的的并行计算</p><p>是不是应该有个图?</p><h3 id="1-GPU硬件"><a href="#1-GPU硬件" class="headerlink" title="1. GPU硬件"></a>1. GPU硬件</h3><p>CUDA环境的核心是支持CUDA的NVIDIA GPU。这些GPU具有大量的并行处理单元（CUDA核心），专门设计用于高性能并行计算。CUDA能够利用这些核心并行处理大规模数据和复杂计算任务。</p><h3 id="2-CUDA-Driver"><a href="#2-CUDA-Driver" class="headerlink" title="2. CUDA Driver"></a>2. CUDA Driver</h3><p>CUDA Driver是与NVIDIA GPU硬件交互的底层驱动程序。它负责管理GPU设备、分配计算资源并与操作系统进行交互。CUDA Driver与操作系统紧密结合，确保CUDA程序能够正确地访问和控制GPU资源。</p><h3 id="3-CUDA-Runtime-API"><a href="#3-CUDA-Runtime-API" class="headerlink" title="3. CUDA Runtime API"></a>3. CUDA Runtime API</h3><p>CUDA Runtime API是一组库函数和接口，为开发人员提供了在CUDA环境中编写和执行GPU计算任务的方法。这些API包括设备管理、内存管理、执行控制和数据传输等功能。开发人员可以使用CUDA Runtime API来编写高效的GPU并行计算程序。</p><h3 id="4-CUDA-Toolkit"><a href="#4-CUDA-Toolkit" class="headerlink" title="4. CUDA Toolkit"></a>4. CUDA Toolkit</h3><p>CUDA Toolkit是一个完整的开发工具包，包括CUDA编译器、调试器、性能分析工具和开发文档等。它提供了开发、编译和优化CUDA程序所需的所有工具和资源。CUDA Toolkit还包括针对不同NVIDIA GPU架构的优化库和示例代码，帮助开发人员实现最佳的性能和兼容性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CUDA Toolkit不仅包含了CUDA Runtime API，还提供了更多的工具和资源，帮助开发者进行CUDA程序的开发、编译、优化和调试。</span><br><span class="line">CUDA Toolkit中的CUDA Runtime API是其中一个重要的组成部分，但并不是整个Toolkit的全部内容。</span><br><span class="line"></span><br><span class="line">- 关系</span><br><span class="line">依赖关系：CUDA Toolkit依赖于CUDA Runtime API。也就是说，在使用CUDA Toolkit进行CUDA程序的开发时，</span><br><span class="line">开发者需要调用CUDA Runtime API中提供的函数来实现与CUDA设备的交互和控制。</span><br><span class="line">功能关系：CUDA Toolkit提供了比CUDA Runtime </span><br><span class="line">API更广泛的功能，包括编译器、调试器和性能分析工具等，这些工具帮助开发者更高效地开发和优化CUDA应用程序。</span><br><span class="line">使用方式：开发者通常会安装CUDA Toolkit来获取CUDA编译器、文档、示例代码等资源，并通过Toolkit中提供的工具</span><br><span class="line">和CUDA Runtime API来编写、编译和调试CUDA程序。</span><br></pre></td></tr></table></figure><h4 id="4-1-CUDA-Toolkit的版本选择"><a href="#4-1-CUDA-Toolkit的版本选择" class="headerlink" title="4.1 CUDA Toolkit的版本选择"></a>4.1 CUDA Toolkit的版本选择</h4><p>不同的深度学习框架的版本依赖的cuda(toolkit)版本也是不同的，存在兼容性问题。 所以不同的项目对CUDA toolkit的版本选择也需要慎重。<br>目前大体上 cuda11.x是稳定在用的版本，因此先选择11.x版本来学习深度学习项目。</p><ul><li>也可以在linux(我用的WSL)对cuda多版本管理.  </li><li>选择方式：综合考虑cuda和深度学习框架稳定、兼容的版本，如：</li></ul><div class="table-container"><table><thead><tr><th>版本</th><th>Pytorch官方文档</th><th>Pytorch版本选择</th><th>tensorflow官方文档</th><th>tensorflow版本选择建议</th></tr></thead><tbody><tr><td>11.x</td><td><a href="https://pytorch.org/get-started/locally/">pytorch与cuda版本</a></td><td>Pytorch2.3.1；cuda:11.8</td><td><a href="https://tensorflow.google.cn/install/source">Tensorflow与cuda版本</a></td><td>tensorflow-2.12.0；py 3.8-3.11；GCC 9.3.1；Bazel 5.3.0；cuDNN8.6；CUDA11.8</td></tr><tr><td>12.x</td><td>-</td><td>-</td><td>-</td><td>tensorflow-2.15.0；py 3.9-3.11    ；Clang 16.0.0；Bazel 6.1.0；cuDNN8.9；12.2</td></tr></tbody></table></div><p>总之，选择相互兼容的版本，安装合适版本的cuda toolkit。 选择的示例见以下：Window WSL中的CUDA</p><p>tensorflow安装:<a href="https://tensorflow.google.cn/install/pip#windows-wsl2_1">官方文档:Install TensorFlow with pip</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是使用tensorflow，通过以下方式安装</span></span><br><span class="line">python3 -m pip install tensorflow[and-cuda]</span><br><span class="line"><span class="comment"># 实际的版本是 tensorflow-2.13.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span></span><br></pre></td></tr></table></figure></p><h3 id="5-CUDA-编程模型"><a href="#5-CUDA-编程模型" class="headerlink" title="5. CUDA 编程模型"></a>5. CUDA 编程模型</h3><p>CUDA 编程模型基于主机（CPU）与设备（GPU）之间的协同工作。开发者可以通过定义核函数（也称为CUDA核函数或者GPU核函数）来在GPU上并行执行操作，从而充分利用GPU的并行计算能力。核函数由开发者编写，并通过CUDA编译器转换为能够在GPU上执行的代码。</p><p>总结来说，CUDA环境架构包括GPU硬件、CUDA Driver、CUDA Runtime API、CUDA Toolkit和CUDA编程模型，为开发者提供了丰富的工具和资源，支持高效的并行计算和GPU加速应用程序的开发与优化。</p><h3 id="6-疑问"><a href="#6-疑问" class="headerlink" title="6. 疑问"></a>6. 疑问</h3><h4 id="6-1-nvcc-amp-nvidia-smi"><a href="#6-1-nvcc-amp-nvidia-smi" class="headerlink" title="6.1 nvcc &amp; nvidia-smi"></a>6.1 nvcc &amp; nvidia-smi</h4><p>CUDA有 runtime api 和 driver api</p><ul><li>runtime api </li><li>driver api</li></ul><p><span style="color: blue;">问题：nvcc -V 和 nvidia-smi 显示出来的CUDA版本不一致， 有没有问题？</span></p><p><strong><em>1.下面先分析一下版本不一致的原因：</em></strong></p><p>从编译器、设备监控管理角度看：</p><ul><li>nvcc属于<strong>CUDA</strong>的编译器，将程序编译成可执行的二进制文件.</li><li>nvidia-smi(NVIDIA System Management Interface) 是帮助<strong><em>管理和监控NVIDIA GPU设备</em></strong>的命令行工具.</li></ul><p>从api角度，CUDA有 runtime api和driver api（并且两者都有对应的版本    ）：</p><ul><li>nvcc -V显示的就是前者的版本</li><li>nvidia-smi显示的是后者对应的CUDA版本s</li></ul><p><strong><em>2.这两个api的必要文件(安装)都是哪些呢？</em></strong></p><ul><li>driver api的必要文件由 GPU driver install 安装， nvidia-smi就属于这一类API</li><li>而用于支持 runtime api的必要文件是由 <strong><em><span style="color: red;">GUDA Toolkit installer</span></em></strong> 安装的</li></ul><p><span style="color: blue;"><strong><em>nvcc</em></strong>是 CUDA Toolkit一起安装的<em>CUDA compiler-driver tool</em> 它只知道它自身构建时的CUDA runtime版本，并不知道安装了什么版本的GPU driver， 甚至不知道是否安装了    GPU driver</span></p><p><span style="font-size: 12px;">tips: GUDA Toolkit installer通常会集成了GPU dirver installer，如果你的CUDA均通过CUDA Toolkit installer来安装，那么runtime api和driver api的版本应该是一致的。 否则可能是使用了单独的 GPU driver installer，这样就导致nvidia-smi和nvcc -V显示的版本不一致了 </span></p><p>通常driver api的版本是向下兼容runtime api的版本，即nvida-smi显示的版本大于nvcc -V的版本通常不会有大问题.</p><h4 id="6-2-pytorch中使用gpu失败"><a href="#6-2-pytorch中使用gpu失败" class="headerlink" title="6.2 pytorch中使用gpu失败"></a>6.2 pytorch中使用gpu失败</h4><p>The NVIDIA driver on your system is too old<br>问题：当在wsl中通过 pytorch 使用gpu时。 出现以下错误：<br>CUDA initialization: The NVIDIA driver on your system is too old (found version 10010).</p><p>原因分析：驱动的兼容性。  找到pytorch 兼容版本的 cuda即可。 并且安装pytorch依赖的nvidia依赖(python库). 具体详见以下： Window WSL中的CUDA</p><p>tips：WSL中的CUDA程序实际上是通过Windows上的NVIDIA驱动来访问GPU资源的</p><h2 id="2-6-Window-WSL中的CUDA"><a href="#2-6-Window-WSL中的CUDA" class="headerlink" title="2.6 Window WSL中的CUDA"></a>2.6 Window WSL中的CUDA</h2><h3 id="1-官方资料"><a href="#1-官方资料" class="headerlink" title="1. 官方资料"></a>1. 官方资料</h3><p>(1).<a href="https://developer.nvidia.com/cuda/wsl">CUDA on Windows Subsystem for Linux (WSL)</a></p><ul><li>Windows 11 上的wsl不再是预览版，而是正式发布的WSL2。</li></ul><p>(2).<strong><a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html">CUDA on WSL User Guide</a></strong>,内容包括:</p><ul><li>在WSL 2上使用NVIDIA CUDA软件架构(软件堆栈)</li><li>Getting Started with CUDA on WSL 2 （讲述了在wsl2中使用cuda的一系列步骤：驱动版本和安装、WSL2安装、CUDA Toolkit等）<br>(以上官方文档仔细阅读)<br><span style="font-size: 12px;color: blue;"><em>tips:从官方文档看到，驱动程序仅安装 NVIDIA GeForce Game Ready或NVIDIA RTX Quadro Windows 11显示驱动程序。<br>(其中GeForce和RTX Quadro是两种不同显卡产品，GeForce面向消费者 适用游戏娱乐， Quadro适用于用于专业工作站和专业应用程序)</em></span></li></ul><h3 id="2-CUDA-on-WSL-User-Guide"><a href="#2-CUDA-on-WSL-User-Guide" class="headerlink" title="2. CUDA on WSL User Guide"></a>2. CUDA on WSL User Guide</h3><p>如上文中官网的资料说明了CUDA on WSL User Guide，这里总结下实践流程(哪些改装，哪些不用装)：</p><ol><li>下载驱动程序。只下载和安装win环境驱动即可，选择符合要求的版本。注意如果是Quadro需要升级win11.<br> <span style="font-size: 12px;color: #e96900;">tips: 安装了<a href="https://www.nvidia.com/Download/driverResults.aspx/228212/en-us/">556.12版本/下载链接</a>。在window环境中下载安装。</span></li><li>安装WSL2. (之前已经安装使用过，忽略。 建议升级win11)<br> <span style="font-size: 12px;color: #e96900;">安装条件： win10登录windows账户并升级windows至预览版本, 大概1-2小时。win11应该可以直接使用了.</span></li><li>CUDA Support for WSL 2(仅安装Linux CUDA Toolkit。<strong><em>在wsl中不用再安装Driver</em></strong>)<br> <span style="font-size: 12px;color: #e96900;">安装toolkit那个版本？ 见： <a href="#4-1-CUDA-Toolkit的版本选择">wiki:CUDA Toolkit的版本选择与下载（wsl的在linux下）</a></span></li><li>安装CUDA toolkit 11.8版本(对pytorch、tensorflow兼容性好，python使用3.8及以后版本).<br> <span style="font-size: 12px;color: #e96900;"><a href="https://developer.nvidia.com/cuda-toolkit-archive">官网:CUDA toolkit 版本选择</a></span>.在wsl环境中下载安装.<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载和cuda toolkit 11.8（好几个G，有点大）</span></span><br><span class="line">wget .....</span><br><span class="line">sudo sh cuda_11.8.0_520.61.05_linux.run</span><br><span class="line"><span class="comment"># 查看 cuda toolkit安装情况（查看路径下都有哪些版本的cuda）。</span></span><br><span class="line"><span class="built_in">ls</span> -la /usr/local/</span><br><span class="line"><span class="comment"># pytorch支持(创建python3.8环境后，安装PyTorch相关的库)</span></span><br><span class="line">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure></li><li>验证<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证pytorch环境，python进入命令行模式后</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"><span class="comment"># 输出 True 则一切正常.</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证 gpu tensorflow</span></span><br><span class="line">python3 -c <span class="string">&quot;import tensorflow as tf; print(tf.config.list_physical_devices(&#x27;GPU&#x27;))&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-CUDA多版本管理和切换"><a href="#3-CUDA多版本管理和切换" class="headerlink" title="3. CUDA多版本管理和切换"></a>3. CUDA多版本管理和切换</h3><p>linux环境中(包括wsl) 同链接文件路径方式生效，所以可以灵活选择切换</p><h3 id="4-Docker中使用nvidia-GPU加速"><a href="#4-Docker中使用nvidia-GPU加速" class="headerlink" title="4. Docker中使用nvidia GPU加速"></a>4. Docker中使用nvidia GPU加速</h3><h4 id="4-1-前言"><a href="#4-1-前言" class="headerlink" title="4.1 前言"></a>4.1 前言</h4><p>以上 实现了 wsl中 搭建cuda环境以 使用GPU, 实现深度学习模型训练和推理。<br>但为了更好的<strong><em>移植性</em></strong>、通常会通过容器(docker) 实现 这些环境(cuda toolkit、python、pytorch、tensorflow、jupyter-lab)</p><p>关键词：容器环境启用GPU、NVIDIA Docker、GPU 服务器应用程序部署、可移植性<br>目的：<strong><em>在Docker中使用NVIDIA GPU加速</em></strong>.</p><p>以下是安装步骤(安装nvidia-docker)<br>前提：安装好了nvidia驱动、cuda、cudnn、docker基础版.<br>接下来需要安装的2个组件：NVIDIA Container Toolkit、NVIDIA Docker 2</p><h4 id="4-2-NVIDIA-Container-Toolkit"><a href="#4-2-NVIDIA-Container-Toolkit" class="headerlink" title="4.2 NVIDIA Container Toolkit"></a>4.2 NVIDIA Container Toolkit</h4><p>NVIDIA Container Toolkit： 提供运行时环境和必要工具，以便Docker容器有效的访问和利用宿主机上的GPU资源. 主要包括 nvidia-container-runtime 和相关的库文件 (libnvidia-container)。它负责在容器内部管理 GPU 的访问和资源分配。</p><p><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/index.html">官方文档:cloud-native/container-toolkit</a></p><h4 id="4-3-NVIDIA-Docker-2"><a href="#4-3-NVIDIA-Docker-2" class="headerlink" title="4.3 NVIDIA Docker 2"></a>4.3 NVIDIA Docker 2</h4><p>是一个 Docker 的插件，它与 Docker Engine 集成，简化了与 NVIDIA GPU 的交互和配置。它建立在 NVIDIA Container Toolkit 之上，通过 Docker CLI 扩展了对 GPU 的支持。</p><p>主要提供了 nvidia-docker 命令行工具，使得容器可以直接通过 —gpus 参数指定使用的 GPU 数量。</p><ul><li>依赖关系：NVIDIA Docker 2 依赖于 NVIDIA Container Toolkit 的运行时环境来管理和配置 GPU。</li></ul><p>具体的安装步骤：在ubuntu中使用apt-get直接安装，具体不展开了. </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留下之前的安装方式. 最新的官方方式还没有尝试过，后续遇到问题可供参考</span></span><br><span class="line">apt-get install nvidia-docker2:amd64=2.5.0-1 \</span><br><span class="line">libnvidia-container-tools:amd64=1.3.3-1 \</span><br><span class="line">nvidia-container-runtime:amd64=3.4.2-1 \</span><br><span class="line">libnvidia-container1:amd64=1.3.3-1 \</span><br><span class="line">nvidia-container-toolkit:amd64=1.4.2-1</span><br></pre></td></tr></table></figure><h4 id="4-4-验证及使用方式"><a href="#4-4-验证及使用方式" class="headerlink" title="4.4 验证及使用方式"></a>4.4 验证及使用方式</h4><p><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/sample-workload.html">官方文档:Sample Workload</a></p><p>Running a Sample Workload with Docker<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --<span class="built_in">rm</span> --runtime=nvidia --gpus all ubuntu nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果出现：docker: Error response from daemon: Unknown runtime specified nvidia.</span></span><br><span class="line"><span class="comment"># 则配置如下：</span></span><br><span class="line">/etc/docker/daemon.json中添加</span><br><span class="line"><span class="string">&quot;runtimes&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;nvidia&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/usr/bin/nvidia-container-runtime&quot;</span>,</span><br><span class="line">      <span class="string">&quot;runtimeArgs&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># 然后重启docker：sudo systemctl restart docker  </span></span><br><span class="line">----------</span><br><span class="line"><span class="comment"># 或者使用</span></span><br><span class="line">docker run --gpus=all --<span class="built_in">rm</span> nvidia/cuda:11.0-base nvidia-smi</span><br><span class="line"><span class="comment"># 测试nvidia-container及查看信息</span></span><br><span class="line">sudo nvidia-container-cli -k -d /dev/tty info</span><br></pre></td></tr></table></figure></p><h4 id="4-5-NVIDIA-Docker原理"><a href="#4-5-NVIDIA-Docker原理" class="headerlink" title="4.5 NVIDIA Docker原理"></a>4.5 NVIDIA Docker原理</h4><p>在docker容器中使用GPU的原理是什么呢，硬件和软件架构是?</p><h4 id="4-6-关于docker中的cuda版本"><a href="#4-6-关于docker中的cuda版本" class="headerlink" title="4.6 关于docker中的cuda版本"></a>4.6 关于docker中的cuda版本</h4><p>通过选择 指定版本的 docker镜像。<br><a href="https://hub.docker.com/r/nvidia/cuda/">镜像站</a> 国外的,超时下载不下来。建议使用以下：<br><a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/cuda/tags">NVIDIA官方的网站; nvcr.io/nvidia/</a></p><ul><li><span style="font-size: 12px;color: #e96900;">此网站还包含了很多镜像和模型.推荐</span></li></ul><p>对于版本的选择： 可以选择任意版本cuda的镜像，因为镜像里包含了完整的兼容的工具链(cuda toolkit、python、等等)<br>需要注意的是 镜像的版本类型，有base、runtime、cudnn8 等镜像。 它们的区别在于:</p><ul><li>base是基础镜像，提供了cuda运行时库和基础工具. （大小一般仅 几十M 、 没有nvcc、没有python）</li><li>runtime基于base， 增加了一些必要的运行时依赖.（大小一般 1个G 、 有nvcc、没有conda和python）</li><li>(部署)cudnn8基于runtime，额外包含了cuNDD库，用于深度学习的加速，提供了优化的卷积操作等功能.（大小一般 近2个G）</li><li>(开发)devel（带有nvcc 等编译器。 其他的镜像没有开发工具， 仅用于运行已经编译好的CUDA应用程序）</li></ul><p>由于在wsl中我们选择了cuda11.8，那在docker环境中 我们选择接近版本的(选错,应该选18结果选了16…大写的无语,pytorch对16支持不好…)：nvcr.io/nvidia/cuda:11.8.0-cudnn8-runtime-ubuntu20.04<br>    <span style="font-size: 12px;color: #e96900;">如果需要加速用到cudnn，则选择第三个tag类型的镜像.</span><br>    <span style="font-size: 12px;color: #e96900;">由于以上镜像拉取超时，解决办法. 拉取 nvcr.io/nvidia/cuda:11.8.0-cudnn8-runtime-ubuntu20.04</span><br><span style="color: blue">推荐直接选择cudnn8-devel版本,用于开发环境. 如果是部署可以选择runtime版本</span></p><p>测试<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvidia-docker  run -it --<span class="built_in">rm</span>   -p 3333:8888  nvcr.io/nvidia/cuda:11.8.0-cudnn8-devel-ubuntu20.04  /bin/bash</span><br><span class="line"><span class="comment"># 查看路径：/usr/local/cuda-11.6/ 是否存在</span></span><br></pre></td></tr></table></figure></p><p><span style="color: blue">搭建一个长久运行的nvidia docker容器 以及notebook开发环境(重要)</span><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name ai_devel --runtime=nvidia --gpus all --restart=always -d  -p 8081:8888 -v /mnt/d/jupyter/quanoc:/home/quanoc nvcr.io/nvidia/cuda:11.8.0-cudnn8-devel-ubuntu20.04 <span class="built_in">tail</span> -f /dev/null</span><br><span class="line"><span class="comment"># 后面加tail -f /dev/null 是为了不让容器自动正常退出.</span></span><br><span class="line">nvidia-docker run --name ai-devops --restart=always -d  -p 8888:8888 -v /mnt/d/jupyter/quanoc:/home/quanoc nvcr.io/nvidia/cuda:11.6.1-runtime-ubuntu20.04</span><br><span class="line"><span class="comment"># 说明：将容器路径映射到宿主机. 提供nvidia docker容器环境</span></span><br></pre></td></tr></table></figure></p><p><span style="color: red">后面加tail -f /dev/null 是为了不让容器自动正常退出.</span></p><h3 id="5-基于nvidia-cuda镜像搭建容器开发环境"><a href="#5-基于nvidia-cuda镜像搭建容器开发环境" class="headerlink" title="5. 基于nvidia/cuda镜像搭建容器开发环境"></a>5. 基于nvidia/cuda镜像搭建容器开发环境</h3><p>关键词：python、jupyter-lab、pytorch、tensorflow<br>下载下来镜像后，接下来搭建开发环境. 安装相关组件.</p><h4 id="5-1-安装Miniconda3"><a href="#5-1-安装Miniconda3" class="headerlink" title="5.1 安装Miniconda3"></a>5.1 安装Miniconda3</h4><p><a href="/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001.%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/001.Anaconda%E5%AE%89%E8%A3%85/">参考：Anaconda安装</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install wget</span><br><span class="line"><span class="comment"># 安装Miniconda3</span></span><br><span class="line"><span class="comment">## 下载Miniconda3-py38_23.3.1-0-Linux-x86_64.sh ； 安装</span></span><br><span class="line">bash Miniconda3-py38_23.5.1-0-Linux-x86_64.sh</span><br><span class="line"><span class="comment"># 重新进入容器(安装完成后默认配置了环境变量，需要重新打开终端)</span></span><br></pre></td></tr></table></figure></p><h4 id="5-2-python及其它框架安装"><a href="#5-2-python及其它框架安装" class="headerlink" title="5.2 python及其它框架安装"></a>5.2 python及其它框架安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n ml3.8 python=3.8</span><br><span class="line">conda activate ml3.8</span><br><span class="line"><span class="comment"># pip安装jupterlab </span></span><br></pre></td></tr></table></figure><p><a href="/wk/算法/001.机器学习/001.工作环境搭建/002.jupyterlab开发环境搭建/">Jupyterlab开发环境搭建</a></p><p>pytorch安装,见以上资料. 2.3.1版本 使用conda安装需要下载近2个G why? pip好像800+M.<br><span style="font-size: 12px;color: #e96900;">如果你只需要安装Python包，且不需要管理环境或依赖关系，那么pip也可以胜任。</span></p><p>pytorch验证问题，torch.cuda.is_available() 出现500的错误。 解决办法：重新安装  nvidia-container-toolkit即可，详见：<br><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html">Installing the NVIDIA Container Toolkit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h1&gt;&lt;p&gt;高性能推理引擎、AI算法工程 对GPU CUDA性能优化的诉求目前是AI行业各个公司在算法工程上需要解决的问题。 以实现高效的并行计算，充分利用GPU计算资源，实现AI算法高性能推理.&lt;/p&gt;
&lt;p&gt;AI行业可以分为两块：&lt;strong&gt;&lt;em&gt;基础设施(infra)和算法模型&lt;/em&gt;&lt;/strong&gt;. 一方面是建设和优化支持AI应用的基础设施，让GPU更好的使用起来。另一方面是研究和应用在这些基础设施上运行的先进算法。&lt;/p&gt;
&lt;p&gt;其中infra包括：硬件基础设施（比如GPU架构、云计算平台）、软件工具（比如深度学习框架、数据处理工具）、以及相关的网络基础设施（比如高速网络连接）。&lt;em&gt;GPU架构和CUDA编程模型可以被视为在这一基础设施层面的重要组成部分&lt;/em&gt;。&lt;br&gt;而算法方面包括：机器学习算法（如监督学习、无监督学习、强化学习）、深度学习模型（如神经网络结构和训练方法）、以及在特定领域中的应用优化算法等。这些算法和模型构成了AI技术的核心，决定了AI系统在解决问题时的效果和性能。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="006.算法工程" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/006-%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Infra" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/006-%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/Infra/"/>
    
    
  </entry>
  
  <entry>
    <title>策略治理_策略评价体系</title>
    <link href="https://quano.gitee.io/wk/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/%E7%AD%96%E7%95%A5%E5%B9%B3%E5%8F%B0/001.%E7%AD%96%E7%95%A5%E6%B2%BB%E7%90%86_%E7%AD%96%E7%95%A5%E8%AF%84%E4%BB%B7%E4%BD%93%E7%B3%BB/"/>
    <id>https://quano.gitee.io/wk/信息安全/风控与业务安全/策略平台/001.策略治理_策略评价体系/</id>
    <published>2024-06-24T07:55:57.000Z</published>
    <updated>2024-06-25T15:51:27.114Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="14239b5fe69f4219a02b4430f494264791039600332beaf2c1451170acda7291">6529a249a0af82b27e00ec9fb492a16554c827f272e9748714be7891901a63d8de314d6d0b6656af15cadc33b8cce5aa86c8b95ec593b02332f93dbbc84d4343222e9b804f962bacce50f4de7ab55acffe9516142e678310b11e54b99873542462fbd3f477668f73b69edfbf7df084952600abad77f454dddd2153ebe063a444b098fb9772b94a84396ea167c211466d4e05d706a5801e210b094f34eabfcd34907a082811091897da7eaa63eb95624bfc174946d447c8119d99de2e9636565d9b430ab9ab5e4f45ec5e77ee91c77de25ab0dce573baaceb9fdca9e976d073bf0f86fb93428d619f622dbb29e85ab4f9bf464317494b83d76c9edb841b2de1d84a48a65c509dae3c711a48fa89ae441fb4164b4d2b65fcdf2d2da5db3b216fe718bd35c7c852009c18cf38608b47df8c18d826a017530df7098102ce3c886705ae4f1f8a93806c661fd041a53a3d498af34db88726916996cf4565e72baf9f139fdd033d44dc10ee877c9595ecbc9437bb93b0acb62c041095499e55ff3f08977f8ec8032731e7690f36f2b213dc341f233bdfc580162f873a469e08d3801db390420e28d2b62a5975d5c60df5a97621d4cc1ce536b1731f376a568b087837d7e8575fe2cdf7d3fdfd8c873f8930bbd8744061ea1b4038d9d603bff061f5c9272d479e58e16d533a7266825a601e32fc8dc746d7a811d2b33250a64a96ae3d0c2dbbfe7e49581ef32db3a9b1dd5cb69ff70d2fe11f71c09499e60358d3a34f1b4251d7743cbc20dc5c96aaa56eb9153deb6f852e68f1d06230931de849c5ad81c1a12554e9cd035f3479ca089bdddf6cca4cc71e0f8187a57b55c5b46811e1a854abaa28c11ba489cedde1643b14c1e49bb0bbdf36d930eb758b02e37e9644e3a61830637106a0d82db582dd637d976c1d9be34ba607ea37e0713dcb2815650b8d0f870499f7b11eb36351b92cca22161d291e33bc76eb0300b77c7c76755e202ba68888f6f65a4c2252bcb1ddce5a4fb31b55621f3049e39f1575512fc06fd54a6493ffd1422371561be419a8610aff5ac6569843933e87d0a599041b3b71aa1069fa5e58648d23b6960bc82464de50eae683dea98d9acf08629a0aa36a80416c6e81bb73486eee66619d5b13176b6b3ddfb9a4fadd2385afeeb783791b9c624267e551074356510e832270283da58648e53c4f15594e7d5fff8a815a598f1c3e17e66371d02a53ace029eb72614bbf85e14ce2e0649e80b9136528fecbe9854bf2252a9d68cc4a39a32efca2b0faf456799c17a389587b42a160e0feefe5eb8e95038dd9b3dceb43cdaca2aceb49b3c64ffd5c4d97341c65c13eb510764a0b8b4fb0b9ef0abe1a52d929cd06c96c32f02ccb1ba3ec64e1539709402f059970e5fd86cce8aa9bcae4098b09113491e553c154dc8d3a1cea27a2c5d4d8af655dad0fae242e7a0dc74fcd8729b398c0e9070be8af5921fcfbd1ff4851e2fc2ba8b27351169db2de8380d50fbad5e34984db912455d33400c25f7b406dd81d2fa0169ff3ab8d3cdeca00be1fb0a2698e14b4c8f6bfdd2edbbc3d0552dc7d6f59758de3042be73c98c8e3c93378bd517cbb29811cceb10bf47197076c55b7ac796d6fc199cff69b5c482e1dd27b9a3cc372110c9e098e6a7059395060391c91e90e33554af10d47a52c29a740487c66ec0048035e28e029423bd094dd81a6773136902aa2daeaa63fd484d6464f6dd13f9373d6367e0ece0586cc2ba42ef55fcb67b998994f175f9db4e766cb181b12a78e2904fda9ea084abbd5691be7c784beee6d1f02eb010b1af30163af925f5277347e925d218bb7eb212f9604b3c18e3d985a255905d7421eb02fb7105b7c144be5ba59107d1a2dc69ce68baf539cf6fff55247b2d62501b3c29ce93faff33ec2d96a40c3451edd03304232b789f3dfdfb2b54aba06b38f680492c1e01c84d4a9dcebe5f99c2902961f3b2967eec659e63a727695f1e0d66771982c434265bcd182dd4e70c3fee0a716dbd1c8d383b64845526e4bf6a7049100149b3ca1a7f2d60cf3205e26e976804247df3f90d34f30e4644d6314ea1a5f518dc643d0267f7c5653fc25b9dac6ad2234cd5bb546262a5e92c9084056d5110401ff268ffd9742c5141d8b0616968be9a4a678aba383d325f4bd6ade7edc043978bc22d42021e805a8571c2b708d86ab9d5946ae32e4c9fceefaf453cf358a7401b4b3858ae30ce70ba1f00753cdd90ee8cad1df8b58aca4373c7c239a700d0c1ea205e9375bbc28d14391891f1a883dd6853eb84f97f45a382f46de943b28094d86d79e97cb129d72fbe496c2b5f6de556df1f5d0468b206b5d1f7897e8c8f2207b5dfc7c979e42c9e7415aaa5363a439ee104387d1a41f5f13a84fc94db27084a9ec75f2fcfc99e27f7d7c5eedf1228c86867951ca6c2be5a9cbb204c504dab92bfd0781f38383fbd18ca45b6e429a3e9dc3d783d4a8b6305ebed7978e395f36b5e0f4c03ec98dec084a44badba4a9cb46f554f599760f27bc9806adf0b6227eb91d3a6dd9185142e8d093b8df8855691f39e20ee1a6f442b7ea839ae3b4e06f221a8d44fad5f5464b407fd77ae9673bd8323d00faf59ec99fc42fb23e58f9fc5f2b47d4667324486a4f6be9a02925efb07a9faa3d7b19af6d65d321dcef7ecb74d3ac0679c2d3eeb513717dd1a3b799cca15bc8585a9851cd1beb1a731d4bee0767d03097d9a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，需要密码才能继续阅读。
    
    </summary>
    
      <category term="信息安全" scheme="https://quano.gitee.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="风控与业务安全" scheme="https://quano.gitee.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/"/>
    
      <category term="策略平台" scheme="https://quano.gitee.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/%E7%AD%96%E7%95%A5%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="private" scheme="https://quano.gitee.io/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>策略平台产品</title>
    <link href="https://quano.gitee.io/wk/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/%E7%AD%96%E7%95%A5%E5%B9%B3%E5%8F%B0/002.%E7%AD%96%E7%95%A5%E5%B9%B3%E5%8F%B0%E4%BA%A7%E5%93%81/"/>
    <id>https://quano.gitee.io/wk/信息安全/风控与业务安全/策略平台/002.策略平台产品/</id>
    <published>2024-06-24T07:55:57.000Z</published>
    <updated>2024-08-14T15:56:34.494Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="e4fb3f212d23e80ac5c12dfc556310e3cb71dbd1d98a7b0d0f57e3ab2474abfe">6529a249a0af82b27e00ec9fb492a165139c3cab6083c44fcf717c7658439994a49d0760a03e592e92ca5352d78a28d2712f99923cfbe6672962a4fb5f2b37fc9f1ae2ccd083b052fe60c0550691c42fe610363a3c5fb3afb31aa4eff353e597a9af888da622ddc71c32254e2fa40dd843c90a080d491c7a1e4ab9176696089c304743e466b4b747ef94d07e1b7756b9783968e86fc2944dd3a33f36df1d631679f6029304342b2ab5725423060738ff62191688deca5c0392e1cb50798d5c483f36699b17d9015210be9f8ad7e4755c0f5e8e285f471ce89cd0f703d762da2a6fb39cc660597ecbbef74294e2d2b879708a1f6ec1cbdcd1f369c9353c82a0778acfa5e9f75ea88ee2787c27eeff63123129656221eb40881fcd0281d6253af5a21bf4397373b54ae9b4f44c0d1c3b09bd6dcc5e44da2e21b8254f79c572c24f1de90b43830e7371ae37077266c0942b670e136399814df46762d6f12391d03081a5d9b38ff5042f32e59316538950f2fdc4985df6565b464274da6b8ce170ed41907d3b2ef5d5f1937224446e9ff5dfb534b1e56a52d7740c408a3891b3d044ff49adfebb28de855242648bac38ed8a29aa13918b37b424fc43aedb6a8547a4aa5c7267337be42f7a9f7eaed337f624</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，需要密码才能继续阅读。
    
    </summary>
    
      <category term="信息安全" scheme="https://quano.gitee.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="风控与业务安全" scheme="https://quano.gitee.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/"/>
    
      <category term="策略平台" scheme="https://quano.gitee.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E9%A3%8E%E6%8E%A7%E4%B8%8E%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/%E7%AD%96%E7%95%A5%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="private" scheme="https://quano.gitee.io/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>1.参数估计方法</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001.%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/002.数学知识/机器学习/001.参数估计/</id>
    <published>2024-06-12T17:55:57.000Z</published>
    <updated>2024-06-16T20:35:05.461Z</updated>
    
    <content type="html"><![CDATA[<p>定义：<br>参数估计过程中，我们的目的是找到一组参数值， 使得<strong><em>目标函数</em></strong>达到最优(如最小或最大)。</p><p><span style="font-size: 12px;">tips: 损失函数是目标函数的一种常见形式。 很多情况下，优化目标函数主要就是通过最小化损失函数来实现的。</span></p><p>参数估计的方法有：<br><strong><em>最优化理论(最大似然估计、最小化损失函数(最小二乘法、梯度下降法)) 、贝叶斯估计、矩估计</em></strong></p><p>以上 也说明了 参数估计 与最小化损失函数 的关系.</p><h1 id="一、最优化理论"><a href="#一、最优化理论" class="headerlink" title="一、最优化理论"></a>一、最优化理论</h1><p><a href="/wk/算法/001.机器学习/002.数学知识/机器学习/002.最优化理论_模型训练中的数学/">数学原理:最优化理论/梯度下降最优化算法</a></p><h2 id="1-1-最大似然估计"><a href="#1-1-最大似然估计" class="headerlink" title="1.1 最大似然估计"></a>1.1 最大似然估计</h2><p><span style="color: red;">通过最大似然估计(MLE)或其他优化算法来估计模型的参数 θ</span>而不是最小化平方差.</p><p>可以 通过 梯度上升法 实现最大似然估计， 帮助找到 使得似然最大的 参数组合. </p><p>另外用于 最大似然估计的方法还有：</p><ul><li>牛顿法： 利用目标函数的 一阶导数和二阶导数来更新参数。</li><li>拟牛顿法：是对牛顿法的改进，避免了计算二阶导数。</li><li>期望最大化(EM)算法：在一些含有隐变量的模型中经常使用。</li></ul><p>这里重点介绍 梯度上升法：</p><h3 id="1-1-1-梯度上升法"><a href="#1-1-1-梯度上升法" class="headerlink" title="1.1.1 梯度上升法"></a>1.1.1 梯度上升法</h3><p>基于的思想：要<span style="color: red;">找到某函数的最大值</span>，最好的方法是<strong><em>沿着该函数的梯度方向探寻</em></strong>。</p><p><span style="font-size: 12px;">tips: 关于<strong><em>梯度</em></strong>的概念， <a href="/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%BE%AE%E7%A7%AF%E5%88%86/001.%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/#4-2-%E6%A2%AF%E5%BA%A6-Gradient">梯度</a>是多元函数在某一点的导数，是一个向量， 其各个分量分别是函数对各个自变量的偏导数。</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">梯度是多元函数在某一点的导数，是一个向量，其各个分量分别是函数对各个自变量的偏导数</span><br><span class="line">1. 在单变量情况下，导数和梯度是等价的概念，因为梯度只有一个分量.</span><br><span class="line">2. 在多变量情况下，导数是一个标量，而梯度是一个向量，包含了所有偏导数的信息.</span><br><span class="line">3. 梯度 的每个分量，表示了函数在 对应方向上的变化率，可以看作是函数在该点的局部导数.</span><br><span class="line">在优化问题中，特别是在机器学习和数值优化中，我们经常需要最小化或最大化函数。梯度提供了函数在给定点的局部变化方向，</span><br><span class="line">因此可以被用来指导优化算法（如梯度下降法、梯度上升法）在参数空间中搜索最优解。</span><br></pre></td></tr></table></figure><h4 id="1-梯度上升的迭代"><a href="#1-梯度上升的迭代" class="headerlink" title="1. 梯度上升的迭代"></a>1. 梯度上升的迭代</h4><p>迭代公式如下：<br>$ \mathbf{w}^{(t+1)} = \mathbf{w}^{(t)} + \eta \nabla f(\mathbf{w}^{(t)}) $</p><p>其中：</p><ul><li>$\mathbf{w}^{(t+1)}$ 是第 $t$ 次迭代后的参数向量</li><li>$\eta$ 是学习率，控制每次迭代中参数更新的步长</li><li>$f(\mathbf{w}^{(t)})$ 是目标函数$f$在参数向量 $\mathbf{w}^{(t)}$ 处的梯度向量</li></ul><p>该公式将一直被迭代执行，直到达到某个停止条件为止，比如迭代次数达到某个指定值 或者算法达到某个可以允许的误差范围.</p><h4 id="2-训练算法-逻辑回归"><a href="#2-训练算法-逻辑回归" class="headerlink" title="2. 训练算法:逻辑回归"></a>2. 训练算法:逻辑回归</h4><p>使用梯度上升找到最佳参数</p><p>逻辑回归假设输出$y$是二分类问题。 对于给定的输入特征 $\mathbf{x}$ ，逻辑回归模型的输出 $ \hat{y}$ 由一下逻辑函数给出：<br>$ \hat{y} = \sigma(\mathbf{w}^\top \mathbf{x} + b) = \frac{1}{1 + e^{-(\mathbf{w}^\top \mathbf{x} + b)}} $</p><ol><li>损失函数<br>逻辑回归使用<strong><em>交叉熵损失函数</em></strong>来衡量预测值 $\hat{y}$ 与真实标签 $y$ 之间的差异：<br>$\mathcal{L}(\mathbf{w}, b) = - \frac{1}{N} \sum_{i=1}^N \left[ y^{(i)} \log \hat{y}^{(i)} + (1 - y^{(i)}) \log (1 - \hat{y}^{(i)}) \right]$<br>其中：<ul><li>$N$ 是训练样本数量</li><li>$y^{(i)} = \sigma(\mathbf{w}^\top \mathbf{x^{(i)}} + b)$ 是对样本 $i$ 的预测概率</li><li>$y^{(i)}$ 是样本 $i$ 的真实标签</li></ul></li><li>梯度上升优化过程<br>梯度上升法<strong><em>用于最大化对数似然函数</em></strong> $ \ell(\mathbf{w}, b) = \sum_{i=1}^N \left[ y^{(i)} \log \hat{y}^{(i)} + (1 - y^{(i)}) \log (1 - \hat{y}^{(i)}) \right] $<br>即使得损失函数 $ \mathcal{L}(w, b) $ 最小化。<br>梯度上升法的步骤如下：<ul><li>(1)初始化参数：随机初始化权重$\mathbf{w}$和偏置$b$</li><li>(2)计算梯度： 计算损失函数对参数 $\mathbf{w}$和$b$ 的梯度<br>  对于权重 $\mathbf{w}$ 的梯度： $ \frac{\partial \mathcal{L}}{\partial \mathbf{w}} = \frac{1}{N} \sum_{i=1}^N (\hat{y}^{(i)} - y^{(i)}) \mathbf{x}^{(i)} $<br>  对于偏置 b 的梯度：$ \frac{\partial \mathcal{L}}{\partial b} = \frac{1}{N} \sum_{i=1}^N (\hat{y}^{(i)} - y^{(i)}) $</li><li>(3)参数更新：根据梯度方向和学习率 $\eta$，更新参数  $\mathbf{w}$和$b$<br>  $ \mathbf{w} := \mathbf{w} + \eta \frac{\partial \mathcal{L}}{\partial \mathbf{w}} $<br>  $ b:= b + \eta \frac{\partial \mathcal{L}}{\partial b} $</li><li>(4) 重复迭代：重复步骤2和步骤3，直到损失函数收敛或达到预定的迭代次数</li></ul></li></ol><p>理解 梯度上升、 最大似然估计(似然函数)、 损失函数的关系：</p><ul><li>逻辑回归中 通过 最大化似然函数(假设观测数据服从伯努利分布) 来估计参数</li><li>而 最大化的方法 是通过 梯度上升法</li><li>梯度上升 是通过 计算损失函数 $\mathcal{L}(\mathbf{w}, b)$ 对参数  $\mathbf{w}$和$b$  的梯度来更新参数.</li></ul><p>梯度上升 只是定义了 迭代的方法(看迭代公式) . 而损失函数 的梯度用来计算 更新方向和大小，从而逐步优化.</p><p>损失函数的梯度被用来计算参数的更新方向和大小，从而逐步优化模型的参数以最小化或最大化损失函数的值。</p><p>逻辑回归中， 损失函数是怎么来的？？<br>通过最大化对数似然函数（log-likelihood）得到的， 推导过程：<br>(重要)在统计推断中，通过最大化对数似然函数来估计参数是常用的方法。对于逻辑回归，我们实际上是最大化对数似然函数的负数的相反数，即最小化负对数似然函数（Negative Log-Likelihood）：<br>$\mathcal{L}(\mathbf{w}, b) = - \frac{1}{N} \sum_{i=1}^N \left[ y^{(i)} \log \hat{y}^{(i)} + (1 - y^{(i)}) \log (1 - \hat{y}^{(i)}) \right]$</p><p>这个负对数似然函数就是逻辑回归中常用的损失函数，用于衡量模型预测值与真实标签之间的差异。</p><p>损失函数是 对数似然函数的负数除以样本数.</p><h2 id="1-2-最小化损失函数"><a href="#1-2-最小化损失函数" class="headerlink" title="1.2 最小化损失函数"></a>1.2 最小化损失函数</h2><h3 id="1-2-1-最小二乘法"><a href="#1-2-1-最小二乘法" class="headerlink" title="1.2.1 最小二乘法"></a>1.2.1 最小二乘法</h3><h3 id="1-2-2-梯度下降法"><a href="#1-2-2-梯度下降法" class="headerlink" title="1.2.2 梯度下降法"></a>1.2.2 梯度下降法</h3><h1 id="二、贝叶斯估计"><a href="#二、贝叶斯估计" class="headerlink" title="二、贝叶斯估计"></a>二、贝叶斯估计</h1><h1 id="三、矩估计"><a href="#三、矩估计" class="headerlink" title="三、矩估计"></a>三、矩估计</h1><h1 id="关于目标函数和损失函数"><a href="#关于目标函数和损失函数" class="headerlink" title="关于目标函数和损失函数"></a>关于目标函数和损失函数</h1><p>损失函数是目标函数的一种常见形式。 很多情况下，优化目标函数主要就是通过最小化损失函数来实现的。</p><p>假设我们训练 图像分类模型， 目标函数 除了考虑分类错误的损失（损失函数部分）， 还可能考虑模型的复杂度，如参数的数量或某些正则化项， 以避免过拟合吗，这就是损失之外的其它因素。</p><p>包含约束条件的例子： 比如在资源分配问题中，目标函数可能是 最大化总收益， 但同时有约束条件如每个资源的分配量不能超过其上限，或者总资源使用量不能超过某个固定值等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义：&lt;br&gt;参数估计过程中，我们的目的是找到一组参数值， 使得&lt;strong&gt;&lt;em&gt;目标函数&lt;/em&gt;&lt;/strong&gt;达到最优(如最小或最大)。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;tips: 损失函数是目标函数的一种常见形式。
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="002.数学知识" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="https://quano.gitee.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>2.最优化理论_模型训练中的数学原理</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA_%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/002.数学知识/机器学习/002.最优化理论_模型训练中的数学/</id>
    <published>2024-06-10T14:55:57.000Z</published>
    <updated>2024-06-16T17:49:51.469Z</updated>
    
    <content type="html"><![CDATA[<p>在参数估计中，常用的方法主要是最优化理论，<br>其中包括 最大似然估计、最小化损失函数(最小二乘法、梯度下降法)) 。</p><ul><li>本文以Logistic回归算法 为依据， 初步的学习逻辑回归中的最优化理论：最大似然估计. </li><li>之后介绍其它的最优化方法：梯度下降、最小二乘法.</li></ul><p><span style="font-size: 12px;">tips: 逻辑回归中除了 最大似然估计还可以用其它方法，比如梯度下降</span></p><h1 id="逻辑回归中的最优化理论"><a href="#逻辑回归中的最优化理论" class="headerlink" title="逻辑回归中的最优化理论"></a>逻辑回归中的最优化理论</h1><p>基于 最优化方法 的最佳回归系数确定.</p><h2 id="1-最大似然估计"><a href="#1-最大似然估计" class="headerlink" title="1. 最大似然估计"></a>1. 最大似然估计</h2><h1 id="背景-模型训练"><a href="#背景-模型训练" class="headerlink" title="背景(模型训练)"></a>背景(模型训练)</h1><p>先来看看模型训练过程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 算法过程</span><br><span class="line">1. 收集数据、准备数据</span><br><span class="line">2. 分析数据</span><br><span class="line">3. 训练算法：训练的目的是为了找到最佳的分类回归系数</span><br></pre></td></tr></table></figure></p><h2 id="基于最优化方法的最佳回归系数确定"><a href="#基于最优化方法的最佳回归系数确定" class="headerlink" title="基于最优化方法的最佳回归系数确定"></a>基于<span style="color: red;">最优化方法</span>的最佳回归系数确定</h2><p>确定回归系数的最优化方法通常涉及到<strong><em>求解损失函数</em></strong>的<strong><em>最小化问题</em></strong>。<br>通常在线性回归中，最常用的方法是<strong><em>最小二乘法</em></strong>，而在深度学习中，通常使用<strong><em>梯度下降法或其变种来优化损失函数</em></strong>。<br>(逻辑回归是个分类问题，不是线性回归，使用的最优化方法是梯度下降)</p><ul><li>最小二乘法<br>在普通最小二乘线性回归中，我们试图找到一条直线，使得该直线与数据点的<strong><em>残差平方和</em></strong>最小。这个问题可以通过解析方法（例如正规方程）求解，或者通过迭代优化方法（例如梯度下降）来解决。</li></ul><ul><li>梯度下降法<br>在深度学习中，梯度下降法是最常用的优化方法之一。它通过计算损失函数相对于模型参数的梯度，并沿着梯度的反方向更新参数，以使损失函数的值逐渐减小。梯度下降法有多种变种，包括批量梯度下降（Batch Gradient Descent）、随机梯度下降（Stochastic Gradient Descent）和小批量梯度下降（Mini-batch Gradient Descent）等。</li></ul><ul><li>其他优化方法<br>除了梯度下降法之外，还有一些其他的优化方法，如动量法（Momentum）、自适应学习率方法（Adaptive Learning Rate Methods，如Adam、RMSProp等）等。这些方法通过在梯度下降过程中引入动量或自适应调整学习率的方式来加速优化过程。</li></ul><h2 id="1-最小二乘法"><a href="#1-最小二乘法" class="headerlink" title="1. 最小二乘法"></a>1. 最小二乘法</h2><p>目标是最小化观测值与模型预测值之间的平方误差</p><h2 id="2-梯度下降法"><a href="#2-梯度下降法" class="headerlink" title="2. 梯度下降法"></a>2. 梯度下降法</h2><h2 id="3-逻辑回归的最优化"><a href="#3-逻辑回归的最优化" class="headerlink" title="3. 逻辑回归的最优化"></a>3. 逻辑回归的最优化</h2><p>逻辑回归使用 梯度下降法<br>梯度下降通过迭代更新模型参数，沿着损失函数的负梯度方向寻找损失函数的最小值。这种方法适用于逻辑回归中的损失函数，如对数损失函数（logarithmic loss）或交叉熵损失函数（cross-entropy loss），可以有效地最小化损失并找到最优参数。</p><h3 id="1-1-模型预测："><a href="#1-1-模型预测：" class="headerlink" title="1.1 模型预测："></a>1.1 模型预测：</h3><p>logistic 回归的模型预测由 sigmoid 函数完成，将线性组合的结果 $z$ 映射到一个介于 0 和 1 之间的概率值，表示样本属于正类的概率。预测公式为：<br>$ \hat{y} = \sigma(z) = \frac{1}{1 + e^{-z}} $<br>其中，e是自然对数的底，即欧拉常数，约等于2.71828。</p><h3 id="1-2-损失函数"><a href="#1-2-损失函数" class="headerlink" title="1.2 损失函数"></a>1.2 损失函数</h3><p>logistic 回归通常使用对数损失函数（log loss），也称为交叉熵损失函数，用来衡量模型预测值与真实标签之间的差异。</p><p>对于二分类问题，对数损失函数的定义为：<br>$ \text{Log Loss} = -\frac{1}{N} \sum_{i=1}^{N} \left( y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right) $</p><p>其中，$N$ 是样本数量，y_i 是第 i 个样本的真实标签，$\hat{y}_i$ 是模型的预测概率。</p><p><strong><em>这个损失函数是根据最大似然估计推导而来的</em></strong>。todo：怎么推导来着？？？？？？</p><p>我们希望<strong><em>通过最小化损失函数，使得模型输出的概率尽可能地接近真实标签的概率</em></strong>。而对数损失函数在这里被广泛选择的原因有以下几点：</p><ol><li>可微性： 对数损失函数是连续可导的，这使得我们可以使用梯度下降等优化算法来最小化损失函数，从而更新模型的参数。</li><li>凸性： 对数损失函数是凸函数，这意味着局部最小值也是全局最小值，因此我们可以保证收敛到全局最优解。</li><li>推导简单性： 对数损失函数的推导相对简单，并且与逻辑回归模型的概率输出形式相符合，因此在数学上更容易处理和理解。</li></ol><p>因此，对数损失函数是逻辑回归中的一种合适选择，它在实践中被广泛采用，并且在处理二分类问题时通常能够取得良好的效果。</p><h3 id="1-3-参数优化"><a href="#1-3-参数优化" class="headerlink" title="1.3 参数优化"></a>1.3 参数优化</h3><p>通过最小化损失函数来优化模型的参数 $ \mathbf{w} = (w_0, w_1, \ldots, w_n) $。<br>通常使用梯度下降法或其变种来进行参数优化。<br>具体地，我们计算损失函数关于参数的梯度，然后沿着梯度的反方向更新参数，使损失函数的值逐渐减小。</p><p>如上 sigmoid函数 定义， 函数的输入记为 $z$(其中$z$是线性函数的输出)，即 $z$ 由下面公式得出：<br>$z = w_0 + w_1x_1 + w_2x_2 + \ldots + w_nx_n$<br>在这里，$w_0, w_1, \ldots, w_n$ 是模型的权重，$x_1, x_2, \ldots, x_n$ 是输入特征。sigmoid函数将z的值映射到[0,1]的区间</p><p>todo: 这个过程的代码实现.</p><p>是怎么根据 损失函数、梯度下降 来找到 最优参数的呢？？</p><p>拓展</p><p>其它机器学习模型 中的参数估计方法是？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在参数估计中，常用的方法主要是最优化理论，&lt;br&gt;其中包括 最大似然估计、最小化损失函数(最小二乘法、梯度下降法)) 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本文以Logistic回归算法 为依据， 初步的学习逻辑回归中的最优化理论：最大似然估计. &lt;/li&gt;
&lt;li&gt;之后介绍其它的
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="002.数学知识" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数学" scheme="https://quano.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>工作手册</title>
    <link href="https://quano.gitee.io/wk/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%5B2%5D%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92/TODOLIST/%E5%B7%A5%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>https://quano.gitee.io/wk/项目管理/[2]发展规划/TODOLIST/工作手册/</id>
    <published>2024-06-07T01:56:24.000Z</published>
    <updated>2024-06-09T18:58:54.807Z</updated>
    
    <content type="html"><![CDATA[<p>为什么很难形成习惯， 因为 每天的工作 都是 自由、随性的， 需要做什么没有计划？遇到什么学什么？</p><p>这是一种低效、不好的学习方式.</p><p>把 中长期的学习目标 列成清单, 每天只按照清单 处理即可. 把学习和工作内容 框定在 流程和范围内.</p><h2 id="深度学习-实践篇"><a href="#深度学习-实践篇" class="headerlink" title="深度学习_实践篇"></a>深度学习_实践篇</h2><ol><li><p>启动win，连接网络</p></li><li><p>打开mac， 跳到 win机器的 wsl环境.  启动notebook(jupyterlab)</p></li><li><p>实践 书中的项目， 并总结成 wiki，方便记忆</p></li><li><p>把总结的内容 提炼下， 讲出来， 分享的形式. (费曼)</p></li></ol><h2 id="深度学习-数学篇"><a href="#深度学习-数学篇" class="headerlink" title="深度学习_数学篇"></a>深度学习_数学篇</h2><p>找到需要的数学章节</p><p>近期：梯度下降、 微积分、导数</p><p>回顾：线性代数_矩阵</p><p>概率论：正态分布…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么很难形成习惯， 因为 每天的工作 都是 自由、随性的， 需要做什么没有计划？遇到什么学什么？&lt;/p&gt;
&lt;p&gt;这是一种低效、不好的学习方式.&lt;/p&gt;
&lt;p&gt;把 中长期的学习目标 列成清单, 每天只按照清单 处理即可. 把学习和工作内容 框定在 流程和范围内.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="项目管理" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="[2]发展规划" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/2-%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92/"/>
    
      <category term="TODOLIST" scheme="https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/2-%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92/TODOLIST/"/>
    
    
      <category term="todo" scheme="https://quano.gitee.io/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>1.分布式架构体系_专题-开篇介绍(架构概述)</title>
    <link href="https://quano.gitee.io/wk/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/03.%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB_%E4%B8%93%E9%A2%98/001.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>https://quano.gitee.io/wk/平台工具/01.架构设计/03.分布式架构体系_专题/001.架构设计概述/</id>
    <published>2024-05-31T16:05:57.000Z</published>
    <updated>2024-06-02T05:33:08.780Z</updated>
    
    <content type="html"><![CDATA[<p>单体架构早已成过去， 随着互联网和业务规模的发展，分布式系统已经随处可见，掌握分布式架构的知识体系 显得尤为重要.</p><p>这里主要是对 分布式架构的认识总结. </p><p><span style="color: red;">分布式架构体系设计</span> 是一种将系统得 <span style="color: red;">不同组件和功能分布在多个节点上</span>，通过<span style="color: red;">网络进行协同</span>工作的<span style="color: red;">架构设计理念和方法</span>.</p><h2 id="1-主要特点"><a href="#1-主要特点" class="headerlink" title="1.主要特点"></a>1.主要特点</h2><h3 id="1-1-去中心化"><a href="#1-1-去中心化" class="headerlink" title="1.1 去中心化"></a>1.1 去中心化</h3><p>不存在单一的中心控制节点，各个节点相互独立又相互协作.</p><h3 id="1-2-分布式部署"><a href="#1-2-分布式部署" class="headerlink" title="1.2 分布式部署"></a>1.2 分布式部署</h3><p>系统的各个部分运行在<span style="color: red;">不同的物理或逻辑节点上</span></p><h3 id="1-3-网络通信"><a href="#1-3-网络通信" class="headerlink" title="1.3 网络通信"></a>1.3 网络通信</h3><p>节点之间通过网络进行信息传递和协调</p><h2 id="2-目标"><a href="#2-目标" class="headerlink" title="2.目标"></a>2.目标</h2><ul><li><p>高可用：通过冗余和容错机制，减少单点故障对系统的影响，确保系统持续可用。</p></li><li><p>可扩展性：能够方便地添加或移除节点来适应业务增长或变化的需求</p></li><li><p>高性能：通过分布式处理和负载均衡，提升系统整体的处理能力和响应速度。</p></li><li><p>容错性和可靠性：即使部分节点出现故障，系统仍能正确运行或快速恢复</p></li><li><p>数据一致性： 保证在分布式环境下数据的完整性和一致性</p></li><li><p>弹性：可以动态调整资源分配以应对不同的工作负载</p></li></ul><p>todo： 怎么实现这些目标？都有哪些实践？常见的中间件都有哪些解决方案？ 如何和别人直观的描述这些内容？</p><h2 id="3-常用架构设计模式"><a href="#3-常用架构设计模式" class="headerlink" title="3. 常用架构设计模式"></a>3. 常用架构设计模式</h2><p>如何选择适合的架构设计模式.</p><div class="table-container"><table><thead><tr><th>架构模式</th><th>说明</th><th>优缺点</th><th>具体的实现技术</th><th>相关的中间件</th></tr></thead><tbody><tr><td>*分层架构模式</td><td>将系统分为不同的层次，如表示层、业务逻辑层、数据访问层等，各层职责明确。</td><td>优缺点</td><td>-</td><td>-</td></tr><tr><td>*微服务架构模式</td><td>将系统拆分成多个独立的微服务</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>*事件驱动模式</td><td>客户端与服务器</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>*微核模式</td><td>客户端与服务器</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>*整体架构</td><td>是一种用于设计和构建企业信息系统的框架和方法</td><td>通过包含多个层次或视角，例如业务架构、应用架构、数据架构和技术架构等</td><td>-</td><td>-</td></tr><tr><td>分布式对象模式</td><td>客户端与服务器</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>管道-过滤器模式</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>主从模式</td><td>有主节点负责主要任务处理，从节点提供辅助或备份</td><td>-</td><td>-</td></tr><tr><td>C/S 模式</td><td>客户端与服务器</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>MVP模式</td><td>客户端与服务器</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>分布式缓存模式</td><td>利用缓存提高数据访问效率</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>分布式缓存储模式</td><td>如分布式文件系统、分布式数据库等</td><td>-</td><td>数据6</td><td>-</td></tr><tr><td>分布式协调模式</td><td>如使用zookeeper等进行分布式协调</td><td>-</td><td>数据6</td><td>-</td></tr></tbody></table></div><p>优点：分布式系统的目标， 解决了高可用、扩展性、高性能、容错、弹性等问题。<br>缺点：负责性增加、 数据一致性挑战、分布式事务难题、部署和管理复杂、成本高(构建和维护分布式架构 需要更多的硬件资源和人力)、网络延迟和开销</p><h3 id="3-1-架构模式总结"><a href="#3-1-架构模式总结" class="headerlink" title="3.1 架构模式总结"></a>3.1 架构模式总结</h3><p>不同分类的架构（技术架构、产品架构、算法架构、云计算架构、解决方案架构、业务架构）<br>todo 这些模式怎么划分？</p><p>软件设计模式？区别？<br>todo：自己的认识和总结？</p><h3 id="3-1-整体架构模式"><a href="#3-1-整体架构模式" class="headerlink" title="3.1 整体架构模式"></a>3.1 整体架构模式</h3><p>整体架构模式的目的是： 确保企业信息系统能够支持企业的战略目标，同时保持灵活性、可扩展性和可维护性。</p><p>整体架构模式通常包括以下几个关键组成部分：</p><ol><li>业务架构：定义企业的业务流程、组成结构和业务策略，以支持企业目标</li><li>应用架构：定义企业应用系统的结构和交互方式，包括应用的功能、接口和服务</li><li>数据架构：定义企业数据的组织、管理和访问方式，包括数据模型、数据存储和数据交换</li><li>技术架构：定义支持企业信息系统的安全策略和控制措施，以保护企业资产和数据</li><li>安全架构：定义企业信息系统的安全策略和控制措施，以保护企业资产和数据</li><li>集成架构：定义不同系统和组件之间的集成方式，以实现数据和流程的无缝流动</li></ol><p>整体架构模式还可以能包括 治理、风险管理、合规性和其他方面的考虑。 通过采用整体架构模式，企业可以确保其信息系统的设计和实施与企业战略保持一致，并且能够适应不断变化的业务需求和技术环境。</p><h2 id="4-分布式系统模式"><a href="#4-分布式系统模式" class="headerlink" title="4. 分布式系统模式"></a>4. 分布式系统模式</h2><p>架构模式 相比分布式系统模式，是一个更广泛的概念，不仅适用于分布式系统，也适用于单体系统。 架构模式提供了一种高层次的抽象， 用于知道软件系统的组织和设计。</p><p>架构模式通常关注于系统的结构、组件、它们之间的关系以及它们如何交互。架构模式可以包括分布式系统模式，但它们也包括其他类型的模式，如：</p><ul><li>MVC（模型-视图-控制器）模式：用于分离用户界面和业务逻辑。</li><li>管道-过滤器模式：将数据流通过一系列过滤器进行处理。</li><li>分层架构模式：将系统分解为不同的逻辑层，每层负责不同的职责。</li></ul><p>总的来说，分布式系统模式是架构模式的一个子集，专注于解决分布式环境中特有的问题。而架构模式提供了更广泛的设计原则和实践，适用于各种类型的软件系统。</p><p>分布式系统模式都有哪些呢？</p><ul><li>代理模式：一个中间代理(代理服务器) 代表客户端与服务端进行通信，可以提供负载均衡、缓存、安全等功能</li><li>断路器模式：</li><li>命令查询责任分离(CQRS)：将读取(查询)操作和写入(命令)操作分离， 以提高性能和可伸缩性</li><li>事件溯源：</li><li>领导者选举：</li><li>发布者/订阅者：kafka等。 消息生产者、消息消费者 订阅.</li><li>分片模式：</li></ul><h2 id="5-难点"><a href="#5-难点" class="headerlink" title="5. 难点"></a>5. 难点</h2><ul><li>分布式一致性</li><li>分布式事务管理</li><li>网络通信与延迟</li><li>分布式故障处理</li><li>资源管理与调度</li><li>数据分布与管理</li><li>分布式锁与同步</li><li>性能优化</li><li>监控与调试</li><li>安全问题</li></ul><h3 id="5-1-网络通信与延迟"><a href="#5-1-网络通信与延迟" class="headerlink" title="5.1 网络通信与延迟"></a>5.1 网络通信与延迟</h3><p>在分布式架构体系设计中，如何避免网络延迟和开销？</p><p>对网络延迟赫尔开销的理解： 这是分布式系统固有的挑战之一，但为了获得诸多优势需要面对现实困难问题，需要在性能优化和系统特性之间权衡和取舍</p><ul><li>解决办法包括： 优化网络架构、数据压缩、缓存策略、就近访问、异步通信、协议优化、资源预分配、负载均衡策略 等</li></ul><p>合并请求、优化网络协议、智能路由(负载均衡)、流量控制、系统优化(减少不必要的通信)</p><p>如何评估网络延迟和开销问题呢？</p><ul><li>基准测试、监控工具、性能分析工具、日志分析、压力测试、分布式跟踪(系统)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单体架构早已成过去， 随着互联网和业务规模的发展，分布式系统已经随处可见，掌握分布式架构的知识体系 显得尤为重要.&lt;/p&gt;
&lt;p&gt;这里主要是对 分布式架构的认识总结. &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: red;&quot;&gt;分布式架构体系设计&lt;/span&gt; 是一
      
    
    </summary>
    
      <category term="平台工具" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"/>
    
      <category term="01.架构设计" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="03.分布式架构体系_专题" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/03-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB-%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="架构设计" scheme="https://quano.gitee.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>002.Bert模型实战</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/002.%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/004.%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/002.Bert%E5%AE%9E%E6%88%98/"/>
    <id>https://quano.gitee.io/wk/算法/002.深度学习/004.系列课程/002.Bert实战/</id>
    <published>2024-05-28T14:55:57.000Z</published>
    <updated>2024-08-01T16:40:59.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-了解Bert模型"><a href="#1-了解Bert模型" class="headerlink" title="1. 了解Bert模型"></a>1. 了解Bert模型</h1><p>BERT 是 Bidirectional Encoder Representations from Transformers 的缩写，意为多 Transformer 的双向编码器表示法</p><p>BERT是基于上下文的嵌入模型。它的原理是基于Transformer，可以把BERT看作只有编码器的 Transformer。</p><ul><li>在Transformer中学习了如何将句子送入 Transformer 的编码器，它将输出句子中每个词的特征值。</li><li>另外，BERT的双向是什么意思呢？Transformer 的编码器是双向的，它可以从两个方向读取一个句子。因此，BERT<br>由 Transformer 获得双向编码器特征。（可以理解为 对文本进行编码时，能够同时考虑一个词左右两侧的上下文信息）</li></ul><p>原始的Transformer架构本身不是天然双向的。然而，BERT基于Transformer架构，并通过特定的训练方法和任务设置(如掩码语言模型)实现了双向的语言理解。</p><p>具体的工作原理在另外的篇幅再展开介绍。</p><h2 id="1-1-Bert的配置"><a href="#1-1-Bert的配置" class="headerlink" title="1.1 Bert的配置"></a>1.1 Bert的配置</h2><ul><li>编码器的层数用 L 表示。</li><li>注意力头的数量用 A 表示。</li><li>隐藏神经元的数量用 H 表示。</li></ul><h3 id="1-BERT-base"><a href="#1-BERT-base" class="headerlink" title="1. BERT-base"></a>1. BERT-base</h3><p>12 层编码器叠加而成；每层编码器都使用 12 个注意力头，其中前 馈网络层由 768 个隐藏神经元组成，所以从 BERT-base 得到的特征向量的大小是 768。</p><p>因此，BERT-base 模型的配置可以表示为 L = 12、A = 12、H = 768，它的网络参 数总数可达 1.1 亿个。</p><h3 id="2-BERT-large"><a href="#2-BERT-large" class="headerlink" title="2. BERT-large"></a>2. BERT-large</h3><p>BERT-large 由 24 层编码器叠加而成。每层编码器都使用 16 个注意力头，其中前 馈网络层包含 1024 个隐藏神经元，所以从 BERT-large 得到的特征向量的大小是 1024.</p><p>BERT-large 模型的配置可以表示为 L = 24、A = 16、H = 1024，它的网络参数总数 可达 3.4 亿个。</p><h3 id="3-其它"><a href="#3-其它" class="headerlink" title="3. 其它"></a>3. 其它</h3><ul><li>BERT-tiny:L = 2、H = 128。</li><li>BERT-mini:L = 4、H = 256。</li><li>BERT-small:L = 4、H = 512。</li><li>BERT-medium:L = 8、H = 512。</li></ul><h2 id="1-2-BERT模型预训练"><a href="#1-2-BERT模型预训练" class="headerlink" title="1.2 BERT模型预训练"></a>1.2 BERT模型预训练</h2><p>在大多数实际业务场景中，一般不会直接进行BERT的预训练。 预训练通常是由大型研究机构或公司在大规模数据上完成的。</p><h2 id="1-3-BERT实战应用方式"><a href="#1-3-BERT实战应用方式" class="headerlink" title="1.3 BERT实战应用方式"></a>1.3 BERT实战应用方式</h2><p>Bert模型应用方式有以下几种：微调下游任务(分类、)；  特征提取； 知识蒸馏；对预训练的Bert模型进行修改和扩展。</p><h3 id="1-微调"><a href="#1-微调" class="headerlink" title="1. 微调"></a>1. 微调</h3><p>(主要的应用方式)<br>微调下游任务： 文本分类任务、自然语言推理任务、问答任务、命名实体识别任务</p><h3 id="2-特征提取"><a href="#2-特征提取" class="headerlink" title="2. 特征提取"></a>2. 特征提取</h3><p>利用预训练的Bert模型生成文本的向量表示，然后将这些向量输入到其它机器学习模型中进行后续的任务处理。</p><h3 id="3-知识蒸馏"><a href="#3-知识蒸馏" class="headerlink" title="3. 知识蒸馏"></a>3. 知识蒸馏</h3><p>得到更轻量且适合特定业务场景的模型。</p><h3 id="4-模型修改和扩展"><a href="#4-模型修改和扩展" class="headerlink" title="4. 模型修改和扩展"></a>4. 模型修改和扩展</h3><h2 id="1-4-从预训练Bert中提取嵌入"><a href="#1-4-从预训练Bert中提取嵌入" class="headerlink" title="1.4 从预训练Bert中提取嵌入"></a>1.4 从预训练Bert中提取嵌入</h2><p>要进行具体的实战，先看看怎么 从预训练bert中提取嵌入。</p><h1 id="2-实战1-文本分类任务"><a href="#2-实战1-文本分类任务" class="headerlink" title="2. 实战1:文本分类任务"></a>2. 实战1:文本分类任务</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-了解Bert模型&quot;&gt;&lt;a href=&quot;#1-了解Bert模型&quot; class=&quot;headerlink&quot; title=&quot;1. 了解Bert模型&quot;&gt;&lt;/a&gt;1. 了解Bert模型&lt;/h1&gt;&lt;p&gt;BERT 是 Bidirectional Encoder Represe
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="002.深度学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="004.系列课程" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/004-%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="ML" scheme="https://quano.gitee.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>1.架构设计方法论理解</title>
    <link href="https://quano.gitee.io/wk/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/001.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://quano.gitee.io/wk/平台工具/01.架构设计/01.架构设计体系与方法论/001.架构设计方法论的理解/</id>
    <published>2024-05-07T14:55:57.000Z</published>
    <updated>2024-07-20T15:37:08.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对架构的认识"><a href="#1-对架构的认识" class="headerlink" title="1.对架构的认识"></a>1.对架构的认识</h1><h2 id="1-1-架构是什么"><a href="#1-1-架构是什么" class="headerlink" title="1.1 架构是什么?"></a>1.1 架构是什么?</h2><p>对于技术人员，“架构”是一个很常见的词。  整个系统的架构、架构设计评审、开源系统(mysql、hadoop)的架构、大公司的架构 (微信、淘宝架构) 等。  <strong><em>虽然“架构”这个词常见，但深究一下<span style="color: red;">“架构”到底指什么</span>，大部分人可能不一定能够准确的回答出来</em></strong>，比如：</p><ul><li>架构和框架什么关系？有什么区别？</li><li>linux有架构、MySQL有架构、微信也有架构、当我们谈到这些架构是，到底在谈什么架构？</li></ul><p>要解释这些问题， 首先要搞清楚几个相关而且相似的概念：<strong><em>系统与子系统、模块与组件、框架和架构</em></strong>。</p><ul><li>系统：一群有关联的组成，根据某种规则运行，能完成个别元件不能单独完成的工作的群体。(整体、总体; 关键词： 关联、规则、能力) </li><li>子系统：(观察视角的差异) 一个系统可能另外一个更大的系统的子系统；一个系统也可能包含多个子系统</li><li><span style="color: red;">模块和组件</span>：（在实际工作中也容易混淆）模块和组件都是系统的组成部分，只是从不同的角度拆分系统。<ul><li>从逻辑角度拆分出来的称作 模块； 划分模块的主要目的是职责分离</li><li>从物理的角度拆分 的带的组件； 划分组件的目的是 单元复用</li></ul></li></ul><p>举例：一个简单的网站系统(比如学生信息管理系统)。 从逻辑的角度拆分，可以分为“登录注册模块” “个人信息模块”； 从物理的角度拆分，可以拆分为nginx、web服务器、mysql等组件。<br>组件更多的是体现复用，而模块体现的是系统的逻辑组成.</p><p><span style="color: red;">框架与架构</span>： (比较相似的概念，有较强的的关联关系)</p><ul><li>框架 是组件规范：例如mvc、mvp、j2ee等； 框架提供基础功能的产品。</li><li><strong><em>软件架构：指软件系统的“基础结构”， 创造这些基础结构的准则，以及这些结构的描述</em></strong></li></ul><p>但： 平常经常会遇到一些似是而非的说法。 比如：“我们的系统是MVC架构”， “重构成MVP架构”， “基于SSH框架开发”，“是SSH的架构”<br>这些说法都是对的，原因在于架构的定义中：“基础结构”这个概念， 并没有明确说 从什么角度来分解，采用不同的角度或者维度，可以将系统分为不同的结构。</p><p>比如，学生信息管理系统中，从<strong><em>业务逻辑的角度分解</em></strong>，系统的架构是”有哪些模块，模块之间的关系“；<br>从<strong><em>物理部署的角度分解</em></strong>， 系统的架构是”用了什么组件，之间的关系(数据流向)“<br>从<strong><em>开发规范的角度分解</em></strong>，系统采用MVC框架来开发，因此架构又变成了MVC架构，”由Controller、View、Model 组成；之间什么关系(数据流向)”</p><p>这些架构， 都是“学生管理系统”正确的架构，只是从不同的角度来分解而已， 这也是IBM的RUP将<strong><em>软件架构视图</em></strong>分为著名的“<strong><em>4+1视图</em></strong>”的原因。</p><p>最终的架构定义： <span style="color: red;">软件架构</span> 指<span style="color: red;"><strong>软件系统的顶层结构</strong></span>。 (这个定义看似简单，但把系统、子系统、组件、模块、架构等概念都串起来了， 包含的信息丰富)</p><h2 id="1-2-怎么学习架构设计"><a href="#1-2-怎么学习架构设计" class="headerlink" title="1.2 怎么学习架构设计"></a>1.2 怎么学习架构设计</h2><p>我们工作中见到过很多架构设计，也做过一些架构设计。 但是我们做的好不好呢，很多人尤其开发人员做的系统上线后才发现很多设计上的问题，没有系统的规划和解决。</p><p>是因为 没有系统化的 架构设计思想和能力。 没有完整的从头到尾，从需求分析、软件系统的复杂度分析，到详细设计和时间 完整的结合业务场景做系统设计。  </p><p>不管是我们遇到的 各个领域的架构 比如搜索架构、安全风控架构， 还是其中的数据架构、子系统架构。</p><p><strong><em>其实最重要的是 结合实际业务场景，搞清楚架构设计的目的了；学习系统的架构设计方法和思路； 实践总结经验。</em></strong></p><p><span style="font-size: 12px;"><em>tips:了解架构模式及技术的发展历程， 在什么背景下出现，解决了什么问题。 无论是在平常的工作还是系统架构设计中，最重要的是发现和识别清楚问题。<br>解决问题的方法有很多。其次是选择合适的方法(合适的架构模式和技术)</em></span></p><h1 id="2-架构设计的历史背景"><a href="#2-架构设计的历史背景" class="headerlink" title="2.架构设计的历史背景"></a>2.架构设计的历史背景</h1><h2 id="2-1-结构化程序设计"><a href="#2-1-结构化程序设计" class="headerlink" title="2.1 结构化程序设计"></a>2.1 结构化程序设计</h2><p>20 世纪 60 年代 ，高级语言的出现后，随着软件的规模和复杂度的大大增加，60年代中期出现一些软件危机。 典型表现有<strong><em>软件质量低下、项目无法如期完成、项目严重超支等</em></strong>，因为软件而导致的重大事故时有发生。（1963 年美国的水手一号火箭发射失败事故， 由于一行FORTRAN代码错误导致）</p><p>大型软件项目的延期、成本超支，结构化程序设计方案应运而生。<br>结构化程序设计的主要特点是抛弃 goto 语句，采取“自顶向下、逐步细化、模块化”的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块 化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构 化程序方法成为了 20 世纪 70 年代软件开发的潮流。</p><h2 id="2-2-面向对象程序设计"><a href="#2-2-面向对象程序设计" class="headerlink" title="2.2 面向对象程序设计"></a>2.2 面向对象程序设计</h2><p>然而随着硬件的快速发展，业务需求越来越复杂，以及编程应用领域越来越广泛，第二次软件危机很快就到来了。<br>根本原因还是在于软件生产力远远跟不上硬件和业务的发展。</p><p>第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机主要体现在软件的“扩展”变得非常复杂</p><ul><li>结构化程序设计虽解决或者缓解了软件逻辑的复杂性；面向对象解决业务变化带来的软件扩展。</li></ul><p>面向对象真正开始流行是在 20 世纪 80 年 代，主要得益于 C++ 的功劳，后来的 Java、C# 把面向对象推向了新的高峰。<br>第二次软件危机促进了面向对象的发展。</p><h2 id="2-3-软件架构的历史背景"><a href="#2-3-软件架构的历史背景" class="headerlink" title="2.3 软件架构的历史背景"></a>2.3 软件架构的历史背景</h2><p>流行在 20 世纪 90 年代开始<br>随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题;当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。</p><ul><li>系统规模庞大，内部耦合严重，开发效率低;</li><li>系统耦合严重，牵一发动全身，后续修改和扩展困难;</li><li>系统逻辑复杂，容易出问题，出问题后很难排查和修复。</li></ul><p>随着软件规模的发展，不同时期产生了 “结构化编程”、“”模块，“面向对象编程”、“对象”，“软件架构”、“组件”。<br>我们可以看 到，“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别只是在于随着 软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。</p><h1 id="3-架构设计的目的"><a href="#3-架构设计的目的" class="headerlink" title="3. 架构设计的目的"></a>3. 架构设计的目的</h1><p>很多人对架构设计的真正目的还是比较模糊。 先来看几个问题：<br>做了架构设计就能提升开发效率么?<br>设计良好的架构能促进业务发展么?<br>不是每个系统都要做架构设计吗<br>为了高性能、高可用、可扩展，所以要做架构设计？ 但不是所有的系统都需要高性能、高可用。</p><p>那架构设计的真正目的是什么呢？</p><p>从架构设计的历史背景看，整个软件技术发展的历史，其实就是一部与<span style="color: red;"><strong><em>“复杂度”</em></strong></span>斗争的历史，架构的出现也不例外。  简而言之，架构也是为了应对软件系统复杂度而提出的一个解决方案</p><h2 id="3-1-系统复杂度"><a href="#3-1-系统复杂度" class="headerlink" title="3.1 系统复杂度"></a>3.1 系统复杂度</h2><p>架构设计的目的架构 是<span style="color: red;">为了解决软件系统复杂度带来的问题</span>。 (回顾架构产生的历史背景和原因)</p><p>结论虽然简洁,但却是架构设计过程中需要时刻铭记在心的一条准则.</p><h2 id="3-2-做架构设计的理解"><a href="#3-2-做架构设计的理解" class="headerlink" title="3.2 做架构设计的理解"></a>3.2 做架构设计的理解</h2><p>通过熟悉和理解需求，识别系统复杂性所在的地方，然后针对这些复杂点进行架构设计。</p><p>架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而 是要识别出复杂点然后有针对性地解决问题。</p><p>理解每个架构方案背后所需要解决的复杂点，然后才能对比自己的业务复杂点，参考复杂 点相似的方案。</p><p>如果系统的复杂度不是在性能这部分，TPS 做到 10 万并没有什么用。</p><p>淘宝的架构是为了解决淘宝业务的复杂度而设计的，淘宝的业务复杂度并不就是我们的业 务复杂度，绝大多数业务的用户量都不可能有淘宝那么大。</p><p>Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度 根本不是在这方面，引入 Docker 没有什么意义。</p><h2 id="3-3-复杂度来源"><a href="#3-3-复杂度来源" class="headerlink" title="3.3 复杂度来源"></a>3.3 复杂度来源</h2><h3 id="3-3-1-高性能"><a href="#3-3-1-高性能" class="headerlink" title="3.3.1 高性能"></a>3.3.1 高性能</h3><p>软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度;另一方面是多台计算机集群为了高性能带来的复杂度。</p><ul><li><p>单机复杂度<br>计算机内部复杂度最关键的地方就是操作系统。<br>操作系统和性能最相关的就是进程和线程。<br>为了解决手工操作带来的低效，批处理操作系统应运而生。<br>为了进一步提升性能，人们发明了“进程”，用进程来对应一个任务，每个任务都有自己独立的 内存空间，进程间互不相关，由操作系统来进行调度。<br>多进程虽然要求每个任务都有独立的内存空间，进程间互不相关，但从用户的角度来看，两个任务之间能够在运行过程中就进行通信，会让任务设计变得更加灵活高效。</p></li><li><p>集群的复杂度<br>虽然计算机硬件的性能快速发展，但和业务的发展速度相比，还是小巫见大巫了，尤其是进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。</p><p>任务分配<br>任务分解</p></li></ul><p>简单的系统更加容易做到高性能<br>可以针对单个任务进行扩展</p><h3 id="3-3-2-高可用"><a href="#3-3-2-高可用" class="headerlink" title="3.3.2 高可用"></a>3.3.2 高可用</h3><p>计算高可用<br>存储高可用</p><p>高可用状态决策</p><ul><li>独裁式：独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，负责收集信息然后进行决策;所有冗余的个体，我们姑且称它为“上报者”，都将状态信息发送给决策者。</li><li>协商式：协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。</li><li>民主式：民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。例如，ZooKeeper 集群在 选举 leader 时就是采用这种方式。</li></ul><h3 id="3-3-3-可扩展性"><a href="#3-3-3-可扩展性" class="headerlink" title="3.3.3 可扩展性"></a>3.3.3 可扩展性</h3><p>业务需求、运行环境方面的变化都会导致软件系统发生变化，而这种软件系统对上述变化的适应能力就是可扩展性。</p><p>预测变化<br>应对变化</p><h3 id="3-3-4-低成本、安全、规模"><a href="#3-3-4-低成本、安全、规模" class="headerlink" title="3.3.4 低成本、安全、规模"></a>3.3.4 低成本、安全、规模</h3><h1 id="4-架构设计三原则"><a href="#4-架构设计三原则" class="headerlink" title="4. 架构设计三原则"></a>4. 架构设计三原则</h1><p>系统架构设计原则</p><p>合适原则：“合适优于业界领先”<br>简单原则：“简单优于复杂” （结构的复杂性、逻辑的复杂性）<br>演化原则：“演化优于一步到位”</p><p>其他原则：高可用原则、可扩展性、可维护性、松耦合原则、性能优化原则、安全性原则、可测试性原则、成本效益原则、一致性原则.</p><h2 id="4-1-合适"><a href="#4-1-合适" class="headerlink" title="4.1 合适"></a>4.1 合适</h2><p>领先的技术方案可能并不完全适配特定系统的实际需求、技术能力、预算限制、维护能力、以及业务发展阶段等因素。<br>例如：一个小型企业的内部管理系统，如果强行采用业界领先但复杂且昂贵的架构，可能会导致资源浪费、维护困难，反而不如选择一个简单、实用且适合其规模和业务特点的架构</p><h2 id="4-2-简单"><a href="#4-2-简单" class="headerlink" title="4.2 简单"></a>4.2 简单</h2><p>简单的架构有以下优点：</p><ol><li>易于理解：开发团队成员能够更快速、更清晰的理解系统的整体结构和工作原理，降低沟通成本和理解偏差。</li><li>易于维护：简单的架构减少了组件之间的交互复杂性，使得故障排查、修复和系统更新更容易运行，降低了维护成本和风险。</li><li>提高开发效率：开发人员可以更高效地进行编码和测试，减少因为复杂逻辑导致的错误和延误。</li><li>曾强可靠性：简单的架构通常具有更少的潜在故障点和意外情况。</li><li>便于扩展：简单的基础架构在添加新功能或模块时，更容易进行规划和整合，不会因为复杂的现有结构而受到过多限制。</li></ol><h2 id="4-3-演化"><a href="#4-3-演化" class="headerlink" title="4.3 演化"></a>4.3 演化</h2><p>演化意味着随着时间的推移，根据业务需求的变化，技术的发展以及用户的反馈逐步改进和完善。这种方式具有以下优点：</p><ol><li>降低风险：避免在一开始就涉及一个过于庞大和复杂的架构，减少了由于前期规划不准确或考虑不周全导致的重大错误</li><li>更好的适应变化：业务需求和技术环境通常是不断变化的。 通过演化的方式，架构能够更灵活地适应这些变化，而不是被最初的”一步到位“的设计所束缚。</li><li>成本效益：逐步投入资源进行改进和扩展，相比一次投入大量资源构建一个可能不完全符合实际需求的架构，更加经济高效。</li><li>增加学习和改进的机会，在演化过成汇总，团队能够不断积累经验，发现问题并及时调整，从而使架构越来越优化。</li></ol><h2 id="4-4-其它原则"><a href="#4-4-其它原则" class="headerlink" title="4.4 其它原则"></a>4.4 其它原则</h2><h2 id="4-5-系统架构设计原则案例"><a href="#4-5-系统架构设计原则案例" class="headerlink" title="4.5 系统架构设计原则案例"></a>4.5 系统架构设计原则案例</h2><h1 id="5-架构设计流程"><a href="#5-架构设计流程" class="headerlink" title="5. 架构设计流程"></a>5. 架构设计流程</h1><p>识别复杂度<br>设计备选方案<br>评估和选择备选方案<br>详细方案设计</p><h1 id="不同的架构分类"><a href="#不同的架构分类" class="headerlink" title="不同的架构分类"></a>不同的架构分类</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-对架构的认识&quot;&gt;&lt;a href=&quot;#1-对架构的认识&quot; class=&quot;headerlink&quot; title=&quot;1.对架构的认识&quot;&gt;&lt;/a&gt;1.对架构的认识&lt;/h1&gt;&lt;h2 id=&quot;1-1-架构是什么&quot;&gt;&lt;a href=&quot;#1-1-架构是什么&quot; class=&quot;he
      
    
    </summary>
    
      <category term="平台工具" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"/>
    
      <category term="01.架构设计" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="01.架构设计体系与方法论" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="架构设计" scheme="https://quano.gitee.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>001.TensorFlow识别MNIST.md</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/002.%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/004.%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/001.TensorFlow%E8%AF%86%E5%88%ABMNIST/"/>
    <id>https://quano.gitee.io/wk/算法/002.深度学习/004.系列课程/001.TensorFlow识别MNIST/</id>
    <published>2024-04-28T14:55:57.000Z</published>
    <updated>2024-08-02T13:09:25.503Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是 通过Softmax对MNIST进行分类，通过一个简单的前馈神经网络模型实现.<br>以此来:<br>(1).熟悉 算法工程 工作内容都有那些.<br>(2).熟悉TensorFlow框架的原理和使用<br>(3).熟悉Softmax和简单的网络模型<br>(4).熟悉基于python的TensorFlow框架工具</p><h1 id="TensorFlow识别-MNIST"><a href="#TensorFlow识别-MNIST" class="headerlink" title="TensorFlow识别 MNIST"></a>TensorFlow识别 MNIST</h1><p>具体实现见：<a href="https://www.kaggle.com/code/novatensor/digit-rec-tensorflow">kaggle-digit-rec-tensorflow:ipynb</a></p><p>TensorFlow Version: 2.11.0</p><p>书中 使用的是 python2.7、tensorflow 1.14.0； 使用方式上有些差异. (可以关注下差异)</p><h2 id="1-1-import"><a href="#1-1-import" class="headerlink" title="1.1 import"></a>1.1 import</h2><p>引入依赖<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  <span class="comment"># 用于图像相关 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense, Flatten</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.utils <span class="keyword">import</span> to_categorical</span><br></pre></td></tr></table></figure></p><h2 id="1-2-数据下载"><a href="#1-2-数据下载" class="headerlink" title="1.2 数据下载"></a>1.2 数据下载</h2><p>tf2.x 也可以通过 下载数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入依赖</span></span><br><span class="line"><span class="comment"># 原始数据是 784 * 70000 的二维数组(mnist[&#x27;data&#x27;]). 及70000条数据， 每条是 784维 的灰度图像.</span></span><br><span class="line">mnist = loadmat(<span class="string">&quot;/kaggle/input/mnist-original/mnist-original.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># label 是 1*70000的二维数组。</span></span><br><span class="line">mnist[<span class="string">&#x27;label&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="1-3-数据查看"><a href="#1-3-数据查看" class="headerlink" title="1.3 数据查看"></a>1.3 数据查看</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据形状</span></span><br><span class="line">images = mnist[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(images.shape)</span><br><span class="line">images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看其中某一条图像</span></span><br><span class="line">plt.imshow(images[<span class="number">20000</span>].reshape(<span class="number">28</span>,<span class="number">28</span>))</span><br></pre></td></tr></table></figure><h2 id="1-4-数据预处理"><a href="#1-4-数据预处理" class="headerlink" title="1.4 数据预处理"></a>1.4 数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(images.shape)</span><br><span class="line">mnistImages = images.T</span><br><span class="line"><span class="built_in">print</span>(mnistImages.shape)</span><br><span class="line"><span class="comment"># 归一化图像数据</span></span><br><span class="line">mnistImages = mnistImages / <span class="number">255.0</span></span><br><span class="line"><span class="comment">#images[60000]</span></span><br><span class="line"></span><br><span class="line">labels = mnist[<span class="string">&#x27;label&#x27;</span>].squeeze()</span><br><span class="line"><span class="built_in">print</span>(labels.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">plt.imshow(mnistImages[<span class="number">20100</span>].reshape(<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line"><span class="built_in">print</span>(labels[<span class="number">20100</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将标签转换为独热编码(为什么)</span></span><br><span class="line">model_labels = tf.keras.utils.to_categorical(labels, num_classes=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(model_labels.shape)</span><br><span class="line">model_labels[<span class="number">30000</span>]</span><br></pre></td></tr></table></figure><p>创建TensorFlow数据集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建TensorFlow数据集</span></span><br><span class="line">train_images = mnistImages[:<span class="number">60000</span>]</span><br><span class="line">train_labels = model_labels[:<span class="number">60000</span>]</span><br><span class="line">test_images = mnistImages[<span class="number">60000</span>:]</span><br><span class="line">test_labels = model_labels[<span class="number">60000</span>:]</span><br><span class="line"></span><br><span class="line">train_dataset = tf.data.Dataset.from_tensor_slices((train_images, train_labels)).batch(<span class="number">32</span>)</span><br><span class="line">test_dataset = tf.data.Dataset.from_tensor_slices((test_images, test_labels)).batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(train_images.shape)</span><br><span class="line"><span class="built_in">print</span>(train_labels.shape)</span><br></pre></td></tr></table></figure></p><h2 id="1-5-创建模型并训练"><a href="#1-5-创建模型并训练" class="headerlink" title="1.5 创建模型并训练"></a>1.5 创建模型并训练</h2><p>创建一个简单的序贯模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的序列模型</span></span><br><span class="line">model = Sequential([</span><br><span class="line">    <span class="comment">#Flatten(input_shape=(784,)),  # 将28x28图像展平成784维向量</span></span><br><span class="line">    Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">784</span>,)), <span class="comment"># 第一个隐藏层，具有128个神经元和ReLU激活函数</span></span><br><span class="line">    Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),  <span class="comment"># 添加一个具有128个神经元的隐藏层，使用ReLU激活函数</span></span><br><span class="line">    Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>) <span class="comment"># 添加一个输出层，具有10个神经元（对应10个类别），使用softmax激活函数</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,  <span class="comment"># 使用分类交叉熵作为损失函数</span></span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])  <span class="comment"># 跟踪训练和测试的准确率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型概况</span></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(train_dataset, epochs=<span class="number">5</span>, batch_size=<span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-6-评估模型"><a href="#1-6-评估模型" class="headerlink" title="1.6 评估模型"></a>1.6 评估模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">loss, accuracy = model.evaluate(test_dataset)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Test accuracy: <span class="subst">&#123;accuracy&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data_index = <span class="number">10108</span></span><br><span class="line">single_data = mnistImages[data_index]</span><br><span class="line"><span class="built_in">print</span>(single_data.shape)</span><br><span class="line"><span class="built_in">print</span>(labels[data_index])</span><br><span class="line"><span class="comment"># 输入需要 一个行向量， 和训练数据类似.</span></span><br><span class="line">prediction = model.predict(single_data.reshape(<span class="number">1</span>,<span class="number">784</span>))</span><br><span class="line"><span class="comment"># 打印 - 非科学计数法</span></span><br><span class="line">np.set_printoptions(suppress=<span class="literal">True</span>)</span><br><span class="line">result = np.array(prediction[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取预测结果中概率最高的类别索引</span></span><br><span class="line">predicted_digit = np.argmax(prediction[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 打印预测的数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Predicted digit: <span class="subst">&#123;predicted_digit&#125;</span>&quot;</span>)</span><br><span class="line">plt.imshow(mnistImages[<span class="number">10108</span>].reshape(<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>基础知识：Softmax回归(线性的多元分类模型).</p><p>Softmax目的：将打分结果(向量) 转化为 0-1区间的概率.</p><p>假设 x是单个样本的特征， W、b 是 Softmax模型的参数。 </p><ul><li>对样本的理解： 这里 一条数据就是 一个样本，包含了一个特征向量。 （业务中: 也可以用id表示一个样本 ? )</li></ul><p>在MNIST中，x就代表输入的图片， 它是一个 784维度的向量，而W是一个矩阵。<br>它的形状是 (784,10) , b是一个10维的向量。10代表的是类别数。</p><h3 id="1-2-1-Softmax"><a href="#1-2-1-Softmax" class="headerlink" title="1.2.1 Softmax"></a>1.2.1 <span style="color: red;">Softmax</span></h3><p><strong><em>Softmax回归</em></strong>是一个线性的多类分类模型。 实际上是直接从 Logiistic回归模型转化而来的。<br>区别在于Logistic回归模型为两类分类模型，而Softmax模型为多分类模型.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">什么是回归?</span><br><span class="line">回归是统计学和机器学习中的一种重要的分析方法，用于建立变量之间的关系模型，通常用于预测连续型变量的数值...</span><br><span class="line">见：机器学习基本概念和算法</span><br><span class="line"></span><br><span class="line">什么是逻辑回归?</span><br><span class="line">(重要)在二分类问题中，采用逻辑函数 将线性组合的输出 转换为0-1之间的概率值，用于描述事件发生的概率.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>逻辑回归公式:<br>$ h_\theta(x) = \frac{1}{1 + e^{-\theta^Tx}} $</p><p>Softmax回归公式:<br>$ Y_k = \frac{e^{Logit_k}}{\sum_{j=1}^{K} e^{Logit_j}} $</p><h2 id="1-3-使用Softmax对MNIST分类"><a href="#1-3-使用Softmax对MNIST分类" class="headerlink" title="1.3 使用Softmax对MNIST分类"></a>1.3 使用Softmax对MNIST分类</h2><h3 id="1-3-1-计算Logit"><a href="#1-3-1-计算Logit" class="headerlink" title="1.3.1 计算Logit"></a>1.3.1 计算Logit</h3><p>(<span style="color: red;">简单的线性模型</span>)</p><p>通过一下公式计算各个类别的Logit<br>$ \text{Logit} = z = W^T x + b $</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W 是权重矩阵，</span><br><span class="line">x 是输入的特征向量， 可以是经过前层神经网络处理后的特征表示.</span><br><span class="line">b 是一个偏置向量，为每个类别提供一个可学习的偏置项.</span><br></pre></td></tr></table></figure><h3 id="1-3-2-使用Softmax函数"><a href="#1-3-2-使用Softmax函数" class="headerlink" title="1.3.2 使用Softmax函数"></a>1.3.2 使用Softmax函数</h3><p>(<span style="color: red;">激活函数-Softmax函数， 用于将线性组合转换为每个类别的概率分布</span>)</p><p>使用Softmax函数将它转换为各个类别的概率值将</p><h3 id="1-3-3-Softmax回归在TensorFlow中的实现"><a href="#1-3-3-Softmax回归在TensorFlow中的实现" class="headerlink" title="1.3.3 Softmax回归在TensorFlow中的实现"></a>1.3.3 Softmax回归在TensorFlow中的实现</h3><p>代码详见：<a href="https://www.kaggle.com/code/novatensor/digit-rec-tensorflow/edit">Kaggle:digit-rec-tensowflow</a></p><p>todo：别的算法, 分别的结果评估、效果比对</p><p>总结算法公共工作过程？Tensorflow的原理和使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要是 通过Softmax对MNIST进行分类，通过一个简单的前馈神经网络模型实现.&lt;br&gt;以此来:&lt;br&gt;(1).熟悉 算法工程 工作内容都有那些.&lt;br&gt;(2).熟悉TensorFlow框架的原理和使用&lt;br&gt;(3).熟悉Softmax和简单的网络模型&lt;br&gt;(4)
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="002.深度学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="004.系列课程" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/004-%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="ML" scheme="https://quano.gitee.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>0.华为HCIE课程</title>
    <link href="https://quano.gitee.io/wk/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/05.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88_%E6%8A%80%E8%83%BD/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/001.%E5%8D%8E%E4%B8%BAHCIE/"/>
    <id>https://quano.gitee.io/wk/平台工具/云计算/05.解决方案_技能/课程学习/001.华为HCIE/</id>
    <published>2024-04-27T14:55:57.000Z</published>
    <updated>2024-04-28T13:24:08.732Z</updated>
    
    <content type="html"><![CDATA[<p>HCIE： 云服务专家解决方案架构师</p><blockquote><p>学习阶段: 4个 ;  学习周期: 2周  ; 每周学时: 3-10小时</p></blockquote><ul><li>第一阶段：企业上云技术基础 （企业上云顶层设计、云底层技术）</li><li>第二阶段：企业上云架构设计 （云架构设计）</li><li>第三阶段：企业上云实施和运维（云迁移实施、云运维与优化）</li><li>第四阶段：企业上云应用与实践（云服务使能、云行业场景最佳实践）</li></ul><h2 id="一、企业上云技术基础"><a href="#一、企业上云技术基础" class="headerlink" title="一、企业上云技术基础"></a>一、企业上云技术基础</h2><ul><li>企业上云顶层设计</li><li>云底层技术</li></ul><h3 id="1-企业上云顶层设计"><a href="#1-企业上云顶层设计" class="headerlink" title="1. 企业上云顶层设计"></a>1. 企业上云顶层设计</h3><h4 id="1-1云转型时代"><a href="#1-1云转型时代" class="headerlink" title="1.1云转型时代"></a>1.1云转型时代</h4><p>了解云转型的挑战</p><p>驱动力和面临的挑战</p><ul><li>背景：（以物理机为主的 传统IT架构 比如F5等）  ；应对新的信息化需求。</li><li>企业IT架构3个阶段： 传统物理机架构 -&gt; 虚拟化架构  -&gt; 云架构(云计算应运而生)</li><li>解决的痛点（为什么要上云）： 对数据进行有效的处理、开发、管理是非常重要的， 传统架构中基本依托于物理的存储设备； 使用数据库和数据管理工具，受限于数据库系统的性能、数据量的急剧增长； 大规模数据处理性能表现不好。 影响业务效率。<br>云化 提供了性能强大的数据服务：数据库服务、大数据相关的数据处理工具服务。  企业可以直接使用云上的这些数据服务来处理和管理企业自身的数据资产；对自己大量的业务数据进行数据挖掘分析，帮助企业进行数据化智能分析，以此来辅助经营和决策。从而为企业创造新的价值。 还有各个解决方案、融合大数据、AI相关技术 帮助构建全生命周期管理平台。  帮助客户解决 在更为复杂的场景下 由于多样性数据、多样性系统、多样性业务 所带来的数据接入难 数据融合分析难 促进消费难的挑战 助力行业数字化转型、释放数据价值、提升业务体验 让业务更敏捷</li></ul><p><strong>传统数据管理</strong></p><p><strong>传统IT基础设施方面</strong>：虚拟化技术、 烟囱式架构、数据/资源孤岛、统一平台、云平台、统一的平台、底层资源、上层平面、业务敏捷 对客户需求精准把控、容器技术。  免去了工程师 重复去规划底层资源的隔离，配额、环境配置等 使得业务标准可度量。让企业从原来的需要大量设备和系统维护人员 向需求更多的业务运营人员转变， 依此来实现硬件、系统、应用到人员的降本增效。</p><p><strong>传统开发模式</strong></p><p>以上3点是 技术驱动 。 还有业务驱动：将各个资源整合在一起。</p><p>政策驱动、云转型焦点问题（扩展性、高可用、性能、安全、成本）<br>客户视角：五章可循、效率低、难开展</p><ul><li>发展趋势：云出现早起，基于对云不成熟的担忧， 云转型主力军主要是一个互联网企业。 现在 随着云计算不断的完善和成熟，也有越来越多的传统企业 在对企业架构进行云改。</li><li>上云过程中的难点：</li><li><p>上云过程中的方法：</p><blockquote><p>tips: 怎么融合这些点 进行讲述.</p></blockquote></li></ul><h4 id="1-2上云整体设计"><a href="#1-2上云整体设计" class="headerlink" title="1.2上云整体设计"></a>1.2上云整体设计</h4><p>了解上云设计方法</p><h3 id="2-云底层技术"><a href="#2-云底层技术" class="headerlink" title="2. 云底层技术"></a>2. 云底层技术</h3><h4 id="2-1-华为云技术介绍"><a href="#2-1-华为云技术介绍" class="headerlink" title="2.1 华为云技术介绍"></a>2.1 华为云技术介绍</h4><h4 id="2-2-擎天架构"><a href="#2-2-擎天架构" class="headerlink" title="2.2 擎天架构"></a>2.2 擎天架构</h4><h4 id="2-3-裸金属技术"><a href="#2-3-裸金属技术" class="headerlink" title="2.3 裸金属技术"></a>2.3 裸金属技术</h4><h4 id="2-4-OBS对象存储技术"><a href="#2-4-OBS对象存储技术" class="headerlink" title="2.4 OBS对象存储技术"></a>2.4 OBS对象存储技术</h4><h4 id="2-5-企业级云网络-KYON-技术"><a href="#2-5-企业级云网络-KYON-技术" class="headerlink" title="2.5 企业级云网络(KYON)技术"></a>2.5 企业级云网络(KYON)技术</h4><h4 id="2-6-华为云边缘技术"><a href="#2-6-华为云边缘技术" class="headerlink" title="2.6 华为云边缘技术"></a>2.6 华为云边缘技术</h4><h2 id="二、企业上云架构设计"><a href="#二、企业上云架构设计" class="headerlink" title="二、企业上云架构设计"></a>二、企业上云架构设计</h2><h3 id="1-云架构设计"><a href="#1-云架构设计" class="headerlink" title="1. 云架构设计"></a>1. 云架构设计</h3><h4 id="1-1-应用上云概述"><a href="#1-1-应用上云概述" class="headerlink" title="1.1 应用上云概述"></a>1.1 应用上云概述</h4><h4 id="1-2-云上可扩展性设计"><a href="#1-2-云上可扩展性设计" class="headerlink" title="1.2 云上可扩展性设计"></a>1.2 云上可扩展性设计</h4><h4 id="1-3-云上可用性设计"><a href="#1-3-云上可用性设计" class="headerlink" title="1.3 云上可用性设计"></a>1.3 云上可用性设计</h4><h4 id="1-4-云上性能设计"><a href="#1-4-云上性能设计" class="headerlink" title="1.4 云上性能设计"></a>1.4 云上性能设计</h4><h4 id="1-5-云上安全设计"><a href="#1-5-云上安全设计" class="headerlink" title="1.5 云上安全设计"></a>1.5 云上安全设计</h4><h4 id="1-6-云上成本设计"><a href="#1-6-云上成本设计" class="headerlink" title="1.6 云上成本设计"></a>1.6 云上成本设计</h4><h4 id="研讨：云上架构设计研讨"><a href="#研讨：云上架构设计研讨" class="headerlink" title="研讨：云上架构设计研讨"></a>研讨：云上架构设计研讨</h4><p>什么是研讨？研讨的目的？</p><h4 id="实验1：云上架构设计"><a href="#实验1：云上架构设计" class="headerlink" title="实验1：云上架构设计"></a>实验1：云上架构设计</h4><h4 id="实验2：云上架构设计综合实践"><a href="#实验2：云上架构设计综合实践" class="headerlink" title="实验2：云上架构设计综合实践"></a>实验2：云上架构设计综合实践</h4><h2 id="三、企业上云实施和运维"><a href="#三、企业上云实施和运维" class="headerlink" title="三、企业上云实施和运维"></a>三、企业上云实施和运维</h2><p>云迁移实施、云运维与优化）</p><h3 id="1-云迁移实施"><a href="#1-云迁移实施" class="headerlink" title="1. 云迁移实施"></a>1. 云迁移实施</h3><h4 id="1-1-华为云上云迁移服务"><a href="#1-1-华为云上云迁移服务" class="headerlink" title="1.1 华为云上云迁移服务"></a>1.1 华为云上云迁移服务</h4><h4 id="1-2-网络迁移"><a href="#1-2-网络迁移" class="headerlink" title="1.2 网络迁移"></a>1.2 网络迁移</h4><h4 id="1-3-主机迁移"><a href="#1-3-主机迁移" class="headerlink" title="1.3 主机迁移"></a>1.3 主机迁移</h4><h4 id="1-4-存储数据迁移"><a href="#1-4-存储数据迁移" class="headerlink" title="1.4 存储数据迁移"></a>1.4 存储数据迁移</h4><h4 id="1-5-数据库迁移"><a href="#1-5-数据库迁移" class="headerlink" title="1.5 数据库迁移"></a>1.5 数据库迁移</h4><h4 id="1-6-容器化改造"><a href="#1-6-容器化改造" class="headerlink" title="1.6 容器化改造"></a>1.6 容器化改造</h4><h4 id="研讨：迁移方案研讨"><a href="#研讨：迁移方案研讨" class="headerlink" title="研讨：迁移方案研讨"></a>研讨：迁移方案研讨</h4><h4 id="实验3：云迁移实验"><a href="#实验3：云迁移实验" class="headerlink" title="实验3：云迁移实验"></a>实验3：云迁移实验</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HCIE： 云服务专家解决方案架构师&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习阶段: 4个 ;  学习周期: 2周  ; 每周学时: 3-10小时&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：企业上云技术基础 （企业上云顶层设计、云底层技术）&lt;/li
      
    
    </summary>
    
      <category term="平台工具" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"/>
    
      <category term="云计算" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="05.解决方案_技能" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/05-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8A%80%E8%83%BD/"/>
    
      <category term="课程学习" scheme="https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/05-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%8A%80%E8%83%BD/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="云计算" scheme="https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="解决方案" scheme="https://quano.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="HCIE" scheme="https://quano.gitee.io/tags/HCIE/"/>
    
  </entry>
  
  <entry>
    <title>3.Softmax函数(ivew形式)</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%BD%E6%95%B0/003.%E5%87%BD%E6%95%B0Softmax/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/002.数学知识/函数/003.函数Softmax/</id>
    <published>2024-04-12T15:55:57.000Z</published>
    <updated>2024-07-02T17:24:54.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-请描述Softmax函数的数学定义。"><a href="#1-请描述Softmax函数的数学定义。" class="headerlink" title="1. 请描述Softmax函数的数学定义。"></a>1. 请描述Softmax函数的数学定义。</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>Softmax函数是一种在机器学习和深度学习中常用的激活函数，特别是在处理多分类问题时。<br>它将一个向量或一组实数转换成概率分布，使得每个元素的值都在0到1之间，并且所有元素的和为1。</p><h2 id="1-2-函数定义-公式"><a href="#1-2-函数定义-公式" class="headerlink" title="1.2 函数定义(公式)"></a>1.2 函数定义(公式)</h2><p>给定一个样本的特征向量 $z$，Softmax函数定义如下：<br>$ \text{Softmax}(z_i) = \frac{e^{z_i}}{\sum_{j=1}^{K} e^{z_j}} $<br>其中：</p><ul><li>$z_i$ 是输入向量中第 $i$ 个元素的值。</li><li>$K$ 是类别的总数。</li><li>$e^{z_i}$ 是 $z_i$ 的指数（自然对数的底数）。</li><li>分母是对所有类别指数的和。</li></ul><h2 id="1-3-数学特性"><a href="#1-3-数学特性" class="headerlink" title="1.3 数学特性"></a>1.3 数学特性</h2><ul><li>非负性：由于指数函数 $e^{x}$ 总是正的，Softmax函数的输出也总是非负的。</li><li>归一化：输出值的总和为1，因此可以解释为概率分布。</li><li>可微性：Softmax函数是连续可微的，这使得它在梯度下降算法中易于优化。</li></ul><h2 id="1-4-用途"><a href="#1-4-用途" class="headerlink" title="1.4 用途"></a>1.4 用途</h2><ul><li><p>多分类问题<br>在多分类问题中，Softmax函数通常用于神经网络的输出层，将模型的输出（即每个类别的原始分数或对数几率）转换为每个类别的概率估计。这样，具有最高概率的类别将被选择作为模型的预测结果。</p></li><li><p>在计算损失函数的梯度<br>Softmax函数的导数在计算损失函数（如交叉熵损失）的梯度时非常重要，因为它涉及到概率的对数，这在多分类问题中是常见的损失函数。</p></li></ul><h2 id="1-5-扩展-为什么是指数函数"><a href="#1-5-扩展-为什么是指数函数" class="headerlink" title="1.5 (扩展)为什么是指数函数"></a>1.5 (扩展)为什么是指数函数</h2><ul><li>归一化：Softmax函数的目标是将一个向量转换为概率分布，即所有输出值都是非负的，并且总和为1，<br>$e^{x}$ 能够确保即使输入值$x$很大或很小，函数的输出也能持在合理的范围内</li><li>区分度：指数函数能够放大输入值之间的差异。这有助于在多个类别中区分出最可能的类别。</li><li>数学性质：数函数具有许多有用的数学性质，如可微性、连续性等，这些性质使得Softmax函数在优化算法（如梯度下降）中易于处理。</li></ul><h1 id="2-Softmax函数如何应用于多分类问题？"><a href="#2-Softmax函数如何应用于多分类问题？" class="headerlink" title="2. Softmax函数如何应用于多分类问题？"></a>2. Softmax函数如何应用于多分类问题？</h1><p>Softmax函数通常用于多分类问题中，其作用是将模型的原始输出转换为表示概率分布的向量，以便对多个类别进行分类。在多分类问题中，Softmax函数通常作为神经网络输出层的激活函数之一。</p><h2 id="2-1-模型输出"><a href="#2-1-模型输出" class="headerlink" title="2.1 模型输出"></a>2.1 模型输出</h2><p>神经网络的输出层会输出一个原始的<strong><em>分数向量</em></strong>，该向量的每个元素对应于一个类别。这些分数可以是线性变换的结果，如全连接层的输出。</p><h2 id="2-2-Softmax转换"><a href="#2-2-Softmax转换" class="headerlink" title="2.2 Softmax转换"></a>2.2 Softmax转换</h2><p>将这个原始的分数向量作为Softmax函数的输入。<br>Softmax函数会对这些分数<strong><em>进行指数化并归一化，得到一个概率分布</em></strong>，其中每个元素表示对应类别的预测概率。</p><h2 id="2-3-概率解释"><a href="#2-3-概率解释" class="headerlink" title="2.3 概率解释"></a>2.3 概率解释</h2><p>这些预测概率可以被解释为模型对每个类别的置信度。</p><h2 id="2-4-损失计算"><a href="#2-4-损失计算" class="headerlink" title="2.4 损失计算"></a>2.4 损失计算</h2><p>在训练过程中，模型的预测结果会与真实标签进行比较，通常使用交叉熵损失函数来计算预测结果与真实标签之间的差异。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-请描述Softmax函数的数学定义。&quot;&gt;&lt;a href=&quot;#1-请描述Softmax函数的数学定义。&quot; class=&quot;headerlink&quot; title=&quot;1. 请描述Softmax函数的数学定义。&quot;&gt;&lt;/a&gt;1. 请描述Softmax函数的数学定义。&lt;/h1
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="002.数学知识" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="数学" scheme="https://quano.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2.深度学习中的函数</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%BD%E6%95%B0/002.%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/002.数学知识/函数/002.深度学习_激活函数/</id>
    <published>2024-04-11T15:55:57.000Z</published>
    <updated>2024-06-09T20:13:26.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p>定义：激活函数是神经网络中的一种非线性函数，用于在神经网络的各个层之间引入非线性变换。<br>目的：激活函数是用来加入非线性因素的， 因为线性模型的表达能力不够。引入非线性激活函数，可使深层神经网络的表达能力更为强大.</p><p>将神经元的输入信号转换为输出信号，从而引入非线性因素，使得神经网络能够学习和表示更加复杂的函数关系。</p><p>激活函数通常应用在神经网络的隐藏层和输出层，以及某些特殊的网络结构中。</p><p>常见的激活函数包括 Sigmoid 函数、Tanh 函数、ReLU 函数等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线性激活函数是指激活函数本身是线性的情况。</span><br><span class="line">例如，线性函数 $f(x) = ax + b$ 就是一种线性激活函数。</span><br><span class="line">但是，线性激活函数在深度神经网络中并不常用，因为它们的组合等价于一层线性变换，</span><br><span class="line">无法引入非线性因素，从而限制了神经网络的表达能力。</span><br></pre></td></tr></table></figure><h2 id="1-激活函数满足的条件"><a href="#1-激活函数满足的条件" class="headerlink" title="1. 激活函数满足的条件"></a>1. 激活函数满足的条件</h2><ul><li>非线性</li><li>可微性：优化器大多用梯度下降更新参数</li><li>单调性：当激活函数是单调的，能保证 单层网络的损失函数是凸函数</li><li>近似恒等性：当参数初始化为随机小值时，神经网络更稳定.</li></ul><p>激活函数输出值的范围：</p><ul><li>输出为有限值时，基于梯度的优化方法更稳定</li><li>输出为无限值时，建议调小学习率</li></ul><p>藏剑的激活函数有：sigmoid，tanh，ReLU，Leaky ReLU，PReLU，RReLU</p><h3 id="激活函数使用建议"><a href="#激活函数使用建议" class="headerlink" title="激活函数使用建议"></a>激活函数使用建议</h3><ol><li>初学者 首选 ReLU激活函数</li><li>学习率 设置较小值</li><li>输入特征标准化，即让输入特征满足以0为均值，1位标准差的正态分布.</li><li>初始化问题：初始化参数中心化， 即让随机生成的参数满足0为均值，2/当前层输入特征个数开根号下为标准差的正态分布.</li></ol><h2 id="函数详解"><a href="#函数详解" class="headerlink" title="函数详解"></a>函数详解</h2><h3 id="1-softmax"><a href="#1-softmax" class="headerlink" title="1. softmax"></a>1. softmax</h3><p>Softmax函数是一种常用的激活函数，通常用于多分类问题的神经网络输出层，将神经网络的原始输出转换为表示概率分布的向量。</p><p>对神经网络 全连接层输出进行变换，使其服从概率分布，即每个值都位于[0,1]区间且和为1.</p><p><strong><em>与其他激活函数（如ReLU、Sigmoid等）相比，Softmax函数的主要不同之处在于它的输出是一个<span style="color: red;">概率分布</span>，而不是单个神经元的激活值。</em></strong></p><p>详解见下一篇.</p><h3 id="2-ReLU"><a href="#2-ReLU" class="headerlink" title="2. ReLU"></a>2. ReLU</h3><p>ReLU（Rectified Linear Unit）函数是一种常用的非线性激活函数</p><h4 id="2-2-函数公式"><a href="#2-2-函数公式" class="headerlink" title="2.2 函数公式"></a>2.2 函数公式</h4><p>$ f(x) = \max(0, x) $</p><h4 id="2-3-数学特性"><a href="#2-3-数学特性" class="headerlink" title="2.3 数学特性"></a>2.3 数学特性</h4><ul><li>非线性：因为它在 $x$ ≤ 0 时输出为零，而在 $x$ &gt; 0 时输出与输入 $x$ 相等。</li><li>简单：计算非常简单(只需要比较输入 $x$ 和零的大小，并输出较大的那个值).这种简单性质使得ReLU函数在计算上非常高效，可以加速神经网络的训练和推断过程。</li><li>稀疏激活性：…</li><li>导数的简单性：ReLU函数在 $x$ = 0 处不可导，但在其他地方是可导的，导数为单位阶跃函数。这种简单的导数性质使得反向传播算法可以高效地计算梯度，从而实现神经网络的训练。</li><li>抑制梯度消失：ReLU函数的性质使得它能够在一定程度上抑制梯度消失问题，有助于训练深度神经网络。ReLU函数使得正的梯度可以直接传播到输入，从而在一定程度上缓解了深层网络中梯度消失的问题。</li></ul><p>ReLU函数具有非线性、简单、稀疏激活、简单导数和抑制梯度消失等数学特性，使得它成为深度学习中一种常用的激活函数。</p><p>资料：<a href="https://blog.csdn.net/in546/article/details/119621649">https://blog.csdn.net/in546/article/details/119621649</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;激活函数&quot;&gt;&lt;a href=&quot;#激活函数&quot; class=&quot;headerlink&quot; title=&quot;激活函数&quot;&gt;&lt;/a&gt;激活函数&lt;/h1&gt;&lt;p&gt;定义：激活函数是神经网络中的一种非线性函数，用于在神经网络的各个层之间引入非线性变换。&lt;br&gt;目的：激活函数是用来加入非线性
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="002.数学知识" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="数学" scheme="https://quano.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>1.导数与微分</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%BE%AE%E7%A7%AF%E5%88%86/001.%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/002.数学知识/微积分/001.导数与微分/</id>
    <published>2024-04-10T15:55:57.000Z</published>
    <updated>2024-06-16T18:58:58.865Z</updated>
    
    <content type="html"><![CDATA[<p>数学背景： 函数与极限(数列与极限).</p><h1 id="导数概念"><a href="#导数概念" class="headerlink" title="导数概念"></a>导数概念</h1><p>在微积分中，导数是<strong><em>描述函数变化率</em></strong>的概念。<br>导数可以理解为函数在某一点的斜率，表示函数在该点附近的局部变化情况。</p><h2 id="1-导数定义"><a href="#1-导数定义" class="headerlink" title="1. 导数定义"></a>1. 导数定义</h2><p>导数是函数对其自变量的变化率或斜率的度量。</p><p>给定一个函数 $f(x)$，它的导数 $f’(x)$ 或 $ \frac{df}{dx} $ 在某一点 $x$ 处的定义如下：<br>$ f’(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h} $<br><strong><em>这个极限表示当自变量 $x$ 的增量 $h$ 趋近于零时，函数在点 $x$ 处的平均变化率的极限 (<span style="color: red;">函数值$f(x + h)的变化量与 $h$ 的比率$</span>)。</em></strong><br><strong><em>$h$即自变量的增量 $ \delta x $，是一个趋近于零的实数</em></strong>。</p><p>导数告诉我们函数在 $x$ 处的瞬时变化率，即函数曲线在该点处的切线的<strong><em>斜率</em></strong>。</p><p>另一种常见的表示形式是利用微分符号 $dx$ 来表示导数，即：<br>$ f’(x) = \frac{df}{dx} $<br>这表示函数 $f(x) $ 相对于自变量 $x$ 的变化率。</p><p><span style="font-size: 12px;">tips: $h$ 是在定义导数时用来表示自变量 $x$ 的微小变化量，是一个无限接近于0的数。 $dx$ 是微积分中用来表示自变量$x$的微小变化量的标志，通常与微分和积分相关的符号一起使用 </span></p><h2 id="2-导数的集合意义"><a href="#2-导数的集合意义" class="headerlink" title="2. 导数的集合意义"></a>2. 导数的集合意义</h2><p>导数$ f’(x) $ 在 何上表示曲线 $y=f(x)$ 在点$ M(x_0, f(x_0)) $ 处的切线的斜率，即<br>$ f’(x_0) = tan a $</p><h2 id="3-函数可导性与连续型的关系"><a href="#3-函数可导性与连续型的关系" class="headerlink" title="3. 函数可导性与连续型的关系"></a>3. 函数可导性与连续型的关系</h2><p>可导 比连续.  连续不一定可导.</p><p>函数在某点连续 是函数在该点可导 的必要条件，但不是充分条件. </p><h2 id="4-多变量函数的导数"><a href="#4-多变量函数的导数" class="headerlink" title="4. 多变量函数的导数"></a>4. 多变量函数的导数</h2><p>对于多变量函数 $f(x)$，其中 $\mathbf{x} = (x_1, x_2, \ldots, x_n)$ 是一个包含 $n$ 个自变量的向量，其导数有两种常见的形式：<span style="color: red;">偏导数和全导数</span>。</p><h3 id="4-1-偏导数-Partial-Derivatives"><a href="#4-1-偏导数-Partial-Derivatives" class="headerlink" title="4.1 偏导数(Partial Derivatives)"></a>4.1 偏导数(Partial Derivatives)</h3><p>偏导数是多变量函数在某一点关于其中一个自变量的导数。偏导数用 $ \frac{\partial f}{\partial x_i} $ 表示，<strong><em>表示函数  $f$关于 $x_i$ 的变化率</em></strong>，而将其他自变量视为常数。</p><h3 id="4-2-梯度-Gradient"><a href="#4-2-梯度-Gradient" class="headerlink" title="4.2 梯度(Gradient)"></a>4.2 梯度(Gradient)</h3><p><strong><em>梯度是多变量函数的导数的一种推广，它是一个向量，包含函数对所有自变量的偏导数</em></strong>。</p><ul><li>梯度 $\nabla f(\mathbf{x}) $ 是一个向量，其分量表示了函数 $f(x)$ 在每个方向上的变化率。</li></ul><p>梯度用符号 $\nabla f(\mathbf{x})$ 表示，定义为：<br>$ \nabla f(\mathbf{x}) = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \ldots, \frac{\partial f}{\partial x_n} \right) $</p><p>梯度  $\nabla f(\mathbf{x})$ 指示了函数 $f$ 在点 $ \mathbf{x} $ 处的最大变化率方向。<span style="color: red;">它的方向是函数在该点上升最快的方向</span>，而其<strong><em>模长</em></strong>则是这个方向上的变化率。</p><p><span style="font-size: 12px;">tips: 在数学和物理中，模长（Magnitude）通常指的是一个向量的长度或大小，也称为向量的模或向量的大小。<br>它是一个标量，用于表示向量的大小，而不考虑其具体的方向。 </span></p><ul><li><strong><em>换句话说，沿着梯度的方向，函数值 $f(x)$ 的变化速率是最快的，而这个速率就是梯度的模长</em></strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数学背景： 函数与极限(数列与极限).&lt;/p&gt;
&lt;h1 id=&quot;导数概念&quot;&gt;&lt;a href=&quot;#导数概念&quot; class=&quot;headerlink&quot; title=&quot;导数概念&quot;&gt;&lt;/a&gt;导数概念&lt;/h1&gt;&lt;p&gt;在微积分中，导数是&lt;strong&gt;&lt;em&gt;描述函数变化率&lt;/em&gt;&lt;/
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="002.数学知识" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="微积分" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
      <category term="数学" scheme="https://quano.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>1.高中_62中常考函数图像</title>
    <link href="https://quano.gitee.io/wk/%E7%AE%97%E6%B3%95/001.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%BD%E6%95%B0/001.%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6_62%E7%A7%8D%E5%B8%B8%E8%80%83%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F/"/>
    <id>https://quano.gitee.io/wk/算法/001.机器学习/002.数学知识/函数/001.高中数学_62种常考函数图像/</id>
    <published>2024-04-10T15:55:57.000Z</published>
    <updated>2024-06-09T20:13:28.813Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/read/cv27018632/">https://www.bilibili.com/read/cv27018632/</a></p><h1 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h1><ul><li>$y = C$  特殊的<strong><em>线性函数</em></strong>，常值函数</li><li>$y = x$  特殊的<strong><em>线性函数</em></strong>，称为 恒等函数 或 身份函数</li><li>$y = mx + b $  线性函数</li><li>$y = \frac{1}{x} $</li><li>$y = x^2$</li><li>$y = \sqrt{x} $  平方根函数</li></ul><hr><ul><li>$y = a^x$ (当0&lt; $a$  &lt; 1时； 当$a$  = 1时；当$a$  &gt; 1时) <strong><em>指数函数</em></strong>的一种形式，其中$a$ 是底数，$x$ 是指数</li><li>$y = e^x$ <strong><em>自然指数函数</em></strong></li><li>$y = \log_{a} x $  对数函数 (当$a$ &gt; 1 时；当 0 &lt; $a$ &lt; 1 时)</li><li>$y = \ln(x) $ 自然对数函数(以 $e$ 为底的对数，通常记为 $lnx$)</li></ul><h2 id="1-线性函数"><a href="#1-线性函数" class="headerlink" title="1. 线性函数"></a>1. 线性函数</h2><p>线性函数的定义和区别：</p><ul><li>线性函数的图形是<strong><em>直线</em></strong>，而非线性函数的图形可以是曲线、折线或其他形状，取决于具体的函数形式。</li></ul><h3 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 特性</h3><p>一次关系、可加性、简单性(线性函数简单易懂，容易计算，且具有明确的解释)</p><ul><li><p><strong><em>均匀性</em></strong><br>线性函数满足均匀性或齐次性原则<br>即如果将所有输入值乘以一个常数 $k$ ，输出也将乘以 $k$。数学上，这意味着 $ y = mx + b = kmx + kb = k\left(\frac{y}{b}\right) $</p></li><li><p><strong><em>叠加性</em></strong><br>即多个输入的线性组合可以通过分别计算每个输入的线性函数然后相加得到。也就是说，$ y = m(x_1 + x_2) + b = mx_1 + mx_2 + b $</p></li></ul><h2 id="2-指数函数"><a href="#2-指数函数" class="headerlink" title="2. 指数函数"></a>2. 指数函数</h2><p>指数函数是典型的非线性函数，因为它不满足线性函数的叠加性和均匀性原则。</p><h3 id="2-1-底数的影响"><a href="#2-1-底数的影响" class="headerlink" title="2.1 底数的影响"></a>2.1 底数的影响</h3><p>底数 $ a $ 的值<strong><em>影响函数的增长或衰减速率</em></strong>。</p><h3 id="2-2-特殊案例"><a href="#2-2-特殊案例" class="headerlink" title="2.2 特殊案例"></a>2.2 特殊案例</h3><ul><li>当 $a$ = 1 时，函数退化为常数函数 $y$ = 1.</li><li>当 $a$ = $e$(自然对数的底数) 时，函数是自然指数函数 $y = e^x$.</li></ul><h3 id="2-3-微积分"><a href="#2-3-微积分" class="headerlink" title="2.3 微积分"></a>2.3 微积分</h3><p>…</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><ul><li>$sin x$</li><li>$cos x$</li><li>$tan x$</li></ul><h1 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h1><h1 id="S曲线"><a href="#S曲线" class="headerlink" title="S曲线"></a>S曲线</h1><ul><li>$\sigma(x) = \frac{1}{1 + e^{-x}} $ sigmoid函数。其中 $e$ 是自然对数的底。这个函数的输出范围在0到1之间，常用于二元分类问题中作为激活函数。</li><li>$\tanh(x) = \frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} $ 双曲正切函数。这个函数的输出范围在 -1 到 1 之间，是Sigmoid函数的另一种形式，通常用于神经网络中的隐藏层。</li><li>$\arctan(x) $ 这个函数的输出范围是从 $ -\frac{2}{\pi} $ 到 $ \frac{2}{\pi} $</li><li>$y = \frac{x}{\sqrt{1 + x^2}} $ 代数函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/read/cv27018632/&quot;&gt;https://www.bilibili.com/read/cv27018632/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;普通函数&quot;&gt;&lt;a href=&quot;#普通函数&quot; class
      
    
    </summary>
    
      <category term="算法" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="001.机器学习" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="002.数学知识" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="函数" scheme="https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/002-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="数学" scheme="https://quano.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
