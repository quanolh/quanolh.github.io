{"pages":[{"title":"Categories","date":"2024-01-28T09:38:34.160Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2024-01-28T09:38:34.161Z","path":"tags/index.html","text":""},{"title":"About","date":"2024-01-28T09:38:34.160Z","path":"about/index.html","text":""}],"posts":[{"title":"","date":"2024-02-18T17:16:21.723Z","path":"wk/项目管理/软件工程/Linux/Linux系统状态/","text":"内存使用linux free 命令下free/available区别","tags":[],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"","date":"2024-02-18T17:16:21.723Z","path":"wk/项目管理/软件工程/Linux/内存/002.JAVA进程占用内存查看/","text":"使用ps查看JAVA进程使用的内存和虚拟内存( Linux内存管理 )$ ps -p ${pid} -o rss,vszRSS VSZ7152568 17485844 linux top命令VIRT,RES,SHR,DATA的含义","tags":[],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"},{"name":"内存","slug":"项目管理/软件工程/Linux/内存","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/%E5%86%85%E5%AD%98/"}]},{"title":"","date":"2024-02-18T17:16:21.722Z","path":"wk/项目管理/软件工程/Linux/Linux网络命令/","text":"查看端口被哪个进程使用linux如何查看端口被哪个进程占用？","tags":[],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"","date":"2024-02-18T17:16:21.711Z","path":"wk/平台工具/工具组件/Elasticsearch/002.Es插件安装/","text":"","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Elasticsearch","slug":"平台工具/工具组件/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Elasticsearch/"}]},{"title":"","date":"2024-02-18T17:16:21.708Z","path":"wk/平台工具/工具组件/规则引擎/规则引擎比较/","text":"Drools 一款老牌的java规则引擎框架. 十几年前. (十几年后还依旧保持着开源和更新:难得) LiteFlow 功能和特性也非常棒 很适合用在高复杂度的核心业务上。 同时又能保持业务的灵活性. 比较一下 2款框架, 都适合用在什么样的场景，有什么异同点，以及在相同的场景下表现力如何。 一、规则引擎的 作用和目的. 解决易变逻辑和业务耦合的问题。 规则驱动逻辑。 【随时热变更】 12相比较： 流程引擎(实现了将多个业务参与者之间按照某种预定义的规则进行流转，通常需要涉及到***角色信息***)简单来说就是，流程引擎主要解决业务在不同角色之间的流转问题，如请假流程，审批流程，往往要经过多个角色。规则驱动角色流转。 二、Drools、LiteFlow 异同点.都是优秀的开源框架,能把业务中的逻辑给剥离出来. 拥有自己表达式语法。 123451. Drools强调逻辑的片段规则化(可以 把核心易变部分写成一个规则文件)。 等同于原先写在java里的代码现在搬迁到了规则文件。规则文件里的代码全都是可以热变更的。2. 而LiteFlow是基于组件式的思想设计的。更强调组件的规则化，覆盖范围是整个业务，编排的最小单位是组件，规则文件用来串联组件间的流转。- 同时LiteFlow也支持片段式的代码规则化，因为LiteFlow也支持业务逻辑的脚本化。规则支持热变更。 三、评判一个规则引擎是否合格的主要因素有：123456789101. 有没有灵活的规则表达式来支持2. 规则和Java之间能否非常方便的联动3. API调用是否方便，和各种场景系统的集成如何4. 侵入性耦合比较5. 规则的学习成本，是否容易上手.6. 规则表达式是否有语言插件7. 规则能否和业务松耦合，存储于其他地方.8. 规则的变更能否实时改变逻辑9. 是否有界面形态来支持非技术人员的使用10. 框架的性能表现 四、规则表达式Drools的规则表达式为Java量身定制的基于Charles Forgy的RETE算法的规则引擎的实现。 五、 其他问题 面向的用户是谁？ 专业技术人员？ 运营人员？ 产品人员？ 风控产品、风控策略？. 规则引擎深度对比，LiteFlow vs Drools！","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"规则引擎","slug":"平台工具/工具组件/规则引擎","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"}]},{"title":"","date":"2024-02-18T17:16:21.702Z","path":"wk/平台工具/工具组件/组件安装配置/hotJar/","text":"title: hotjartoc: truetags: [组件安装配置] date: 2019-02-24 09:56:24hotjar官网功能简介 网页热图、鼠标轨迹记录、转换漏斗(识别访问者离开)、表单分析、反馈调查、收集反馈、问卷、招聘测试等注册 由于该网站使用的谷歌Recaptcha验证被墙，导致无法弹出验证码注册，因此需翻墙注册… 免费在线翻墙浏览器 UZER.ME云应用 ，注册登录后打开火狐浏览器即可 注册成功后以后就不需翻墙了安装使用 添加输入你要使用的站点地址 将安装代码复制至你的html页面中后，访问一下你安装好的页面，然后点击 I have installed the tracking code 按钮，接下来就可以自定义使用各功能的(某些需付费解除限制) 下面以添加使用Incoming反馈为例，按照步骤设置反馈的位置、颜色、语言、提示等即可，很简单的，不认识英文的去先把四级过了，最后记得点击激活 Active 保存即可","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"","date":"2024-02-18T17:16:21.684Z","path":"wk/平台工具/程序语言/Java/锁/","text":"史上最全 Java 中各种锁的介绍","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2024-02-18T17:16:21.679Z","path":"wk/平台工具/程序语言/Python/pandas/001.README/","text":"","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"pandas","slug":"平台工具/程序语言/Python/pandas","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/pandas/"}]},{"title":"","date":"2024-02-18T17:16:21.672Z","path":"wk/平台工具/程序语言/Python/http请求/get/","text":"","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"http请求","slug":"平台工具/程序语言/Python/http请求","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/http%E8%AF%B7%E6%B1%82/"}]},{"title":"","date":"2024-02-18T17:16:21.668Z","path":"wk/平台工具/程序语言/C++/编译器/编译器了解/","text":"和java中的maven, 一样 c.c ++ 使用 make cmake 进行编译. maven 中的 plugins 类似 make中的 Makefile文件。 其中定义了一些可执行的 编译操作(类似install, package.) 比如rocksdb中的编译： 12345make jclean clean rocksdbjava 或者make jclean clean rocksdbjavastatic 在Makefile中定义了一些 具体的编译执行逻辑。 比如rocksdbjava 是用来 TODO, 执行流程是TODO 再比如 rocksdbjavastatic 是用来 TODO , 执行流程是 TODO.","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"编译器","slug":"平台工具/程序语言/C/编译器","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"","date":"2024-02-18T17:16:21.665Z","path":"wk/平台工具/程序语言/C++/5.初始化内存分配/","text":"","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"","date":"2024-02-18T17:16:21.663Z","path":"wk/平台工具/程序语言/C++/rocksdb源码学习/002.Java版本支持/","text":"主要是源码java目录下的文件。 Cross-building 交叉编译。 java目录下的README.1make jclean clean rocksdbjavastaticreleasedocker 即可编译java版本使用rocksdb的jar.","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"rocksdb源码学习","slug":"平台工具/程序语言/C/rocksdb源码学习","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/rocksdb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}]},{"title":"","date":"2024-02-18T17:16:21.662Z","path":"wk/平台工具/程序语言/C++/rocksdb源码学习/003.相关依赖/","text":"根目录下的 Makefile包含了很多第三方依赖库. 需要下载安装. 由于每次编译rocksdb 都需要执行安装。 所以统一安装好之后，不用重复安装。 bzip2http://www.bzip.org/downloads.html https://github.com/philr/bzip2-windows/releases zlib下载:https://github.com/madler/zlib/releases 安装 1234./configuremakemake checksudo make install 在make install这一步，由于要把zlib安装到/usr/local/lib 路径下，所以可能需要root 权限。安装成功后，可以在/usr/local/lib下找到 libz.a。 libz.a是一个静态库，为了使用zlib的接口，我们必须在连接我们的程序时，libz.a链接进来。只需在 链接命令后加-lz /usr/llocal/lib/libz.a 即可。 举个例子， 我们有一个使用zlib库的应用程序, 源文件只有一个：zpipe.c， 里面调用了zlib的接口，这时执行以下命令编译既可： 12gcc -o zpipe.o -c zpipe.cgcc -o zpipe zpipe.o -lz /usr/local/lib/libz.a snappy下载: https://github.com/google/snappy/releases 安装 12mkdir buildcd build &amp;&amp; cmake ../ &amp;&amp; make 使用cmake编译。 和zlib的编译方式有些不同。 make","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"rocksdb源码学习","slug":"平台工具/程序语言/C/rocksdb源码学习","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/rocksdb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}]},{"title":"","date":"2024-02-18T17:16:21.648Z","path":"wk/算法/基础算法/状态机/002.状态机匹配字符串/","text":"匹配实现. 匹配过程就是根据输入遍历图的过程, 这里DFA和NFA用了同样的代码, 但实际上因为DFA的特性是不会产生回溯的, 所以DFA可以换成非递归的形式 edge边、棱 作不及物动词时意为“缓缓移动；侧着移动”","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"算法/基础算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"状态机","slug":"算法/基础算法/状态机","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E6%9C%BA/"}]},{"title":"","date":"2024-02-18T17:16:21.646Z","path":"wk/算法/基础算法/字符串匹配/001.相关概念/","text":"算法 BF算法: brute force 暴力匹配算法。 O(mn) RK算法: (Rabin-Karp算法:人名命名) 引入hash算法. 群举 对 主串的所有子串. 与模式串做比较. 重点在于hash算法的优化. 难点：需要设计一个 可以应对各种类型字符串的hash算法. BM算法(boyer-moore): 性能是KMP的 3-4倍. 121. 日常开发中 可能很多BF的使用场景. 因为 日常开发中的 主串、模式串 都很短； 并且匹配上就终止. 所以大部分场景 执行效率高很多》2. Kiss设计原则. 朴素匹配 算法思想简单、实现简单、不容易出错. 串主串、 模式串 BM 算法 坏字符规则. 好后缀规则. BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现BM算法。 KISS（Keep it Simple and Stupid）设计原则。 解决问题方面 组织的培训、团队技能能力的沉淀有提升的地方 代码的质量把控，上线一个策略需要的支持, 什么流程比较合理. 其实是需要有人可以把控的. 比如 产品那边上线识别模型, 做策略. 有些不知道找谁. 模型怎么调度、需要谁支持. 怎么支持.","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"算法/基础算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"字符串匹配","slug":"算法/基础算法/字符串匹配","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"","date":"2024-02-18T17:16:21.646Z","path":"wk/算法/基础算法/字符串匹配/002.字符集概念与认识/","text":"UnicodeUnicode仅仅只是一个字符集,规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。 它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。 1. Unicode编码规范Unicode编码标准，可表示目前全世界所有语言的所有字符。同时兼容ASCII编码。 UCS 只是规定如何编码，并没有规定如何传输、保存这个编码。例如“汉”字的 UCS 编码是 6C49，我可以用 4 个ascii 数字来传输、保存这个编码；也可以用 utf-8 编码 3 个连续的字节 E6 B1 89 来表示它。关键在于通信双方都要认可。UTF-8、UTF-7、UTF-16 都是被广泛接受的方案。UTF 是 “UCS Transformation Format” 的缩写。 UCS2 2的16次方 65535. UCS4 2. utf-8问题： 计算机不知道 是 2 个字节表示的是一个字符，还是1个字节表示一个字符. 3. java中string 占用几个字节string采用灵活的 方式存储. 一个英文字符占1个字节, 而中文字符根据编码的不同所占字节数也不同。在UTF-8编码下，一个中文字符占3个字节；而使用GBK编码时一个中文字符占2个字节。","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"算法/基础算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"字符串匹配","slug":"算法/基础算法/字符串匹配","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"","date":"2024-02-18T17:16:21.639Z","path":"wk/算法/001.机器学习/NLP/NLP系列/001.NLP基础任务/","text":"","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"},{"name":"NLP系列","slug":"算法/001-机器学习/NLP/NLP系列","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/NLP%E7%B3%BB%E5%88%97/"}]},{"title":"","date":"2024-02-18T17:16:21.639Z","path":"wk/算法/001.机器学习/NLP/NLP系列/002.BERT/","text":"背景自google在2018年10月底公布BERT在11项nlp任务中的卓越表现后. BERT（Bidirectional Encoder Representation from Transformers)就成为NLP领域大火、整个ML界略有耳闻的模型. 词向量模型— 这里主要横向比较一下word2vec，ELMo，BERT这三个模型，着眼在模型亮点与差别处。 传统意义上来讲，词向量模型是一个工具，可以把真实世界抽象存在的文字转换成可以进行数学公式操作的向量，而对这些向量的操作，才是NLP真正要做的任务。 因而某种意义上，NLP任务分成两部分，预训练产生词向量，对词向量操作（下游具体NLP任务）。 从word2vec到ELMo到BERT，做的其实主要是把下游具体NLP任务的活逐渐移到预训练产生词向量上。下面是一个大体概括，具体解释后面会写到。。","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"},{"name":"NLP系列","slug":"算法/001-机器学习/NLP/NLP系列","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/NLP%E7%B3%BB%E5%88%97/"}]},{"title":"","date":"2024-02-18T17:16:21.629Z","path":"wk/算法/001.机器学习/003.知识图谱/学习结构/001.学习目录/","text":"001.学习目录.md 入门 什么是知识图谱 发展历程 有什么用 知识图谱构建","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"003.知识图谱","slug":"算法/001-机器学习/003-知识图谱","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"学习结构","slug":"算法/001-机器学习/003-知识图谱/学习结构","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9E%84/"}]},{"title":"","date":"2024-02-18T17:16:21.629Z","path":"wk/算法/001.机器学习/003.知识图谱/学习结构/002.什么是知识图谱/","text":"002.什么是知识图谱.md 知识图谱学习笔记 通俗易懂解释知识图谱 数据挖掘.","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"003.知识图谱","slug":"算法/001-机器学习/003-知识图谱","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"学习结构","slug":"算法/001-机器学习/003-知识图谱/学习结构","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%A6%E4%B9%A0%E7%BB%93%E6%9E%84/"}]},{"title":"","date":"2024-02-18T17:16:21.619Z","path":"wk/算法/003.图像识别/OCR/004.OpenCV/","text":"OpenCV是一个计算机视觉和机器学习软件库. C++语言编写. 为什么有OpenCV. 他的目的或者主要作用是什么？？ 提供标准的API.(图像处理,计算机视觉方面很多通用的算法) 支持多种语言的接口.多平台支持 (为图像研究和应用领域提供方面快捷高效的算法工具) 1.OpenCV 的 dnn模块专门用来实现深度神经网络相关的功能. OpenCV自己并不能训练神经网络模型，但是他可以载入的深度学习框架(例如tensorFlow,Caffe等) 训练好的模型,然后使用该模型做inference(预测) 而且OpenCV在载入模型时会使用自己的dnn模块对模型重写,使得模型的运行效率更高. 所以先用自己熟悉的深度学习框架训练好，然后使用OpenCV的dnn模块载入. 2.使用OpenCV的dnn模块实时目标检测使用OpenCV的dnn模块实时目标检测","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"OCR","slug":"算法/003-图像识别/OCR","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/OCR/"}]},{"title":"","date":"2024-02-18T17:16:21.606Z","path":"wk/数据/数据处理/DataStore/Mysql/Mysql常用sql/","text":"12345678select element_info,GROUP_CONCAT(`user_id`) as user_list,bg,user_source,user_count,type_id,date8,model_id,freezed_status,add_time,admin_name,update_time From ( select bg.element_info,bd.user_id,bd.bg,bd.user_source,bd.add_time, bg.user_count,bg.type_id,bg.date8,bg.model_id,bg.freezed_status,bg.admin_name,bg.update_time from badgang_detail as bd left join badgang as bg on bd.count_id = bg.id ) as a group by element_info limit 10 ;select element_info,GROUP_CONCAT(`user_id`) as user_list,bg,user_source,user_count,type_id,date8,model_id,freezed_status,add_time,admin_name,update_time From ( select bg.element_info,bd.user_id,bd.bg,bd.user_source,bd.add_time, bg.user_count,bg.type_id,bg.date8,bg.model_id,bg.freezed_status,bg.admin_name,bg.update_time from badgang_detail as bd left join badgang as bg on bd.count_id = bg.id ) as a group by element_info 1310754318@qq.com","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mysql","slug":"数据/数据处理/DataStore/Mysql","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mysql/"}]},{"title":"","date":"2024-02-18T17:16:21.602Z","path":"wk/数据/数据处理/DataStore/Kafka/kafkaListener/listener/","text":"Spring-Kafka（八）—— KafkaListener定时启动（禁止自启动","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"},{"name":"kafkaListener","slug":"数据/数据处理/DataStore/Kafka/kafkaListener","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/kafkaListener/"}]},{"title":"","date":"2024-02-18T17:16:21.596Z","path":"wk/数据/数据处理/组件安装配置/Hadoop组件安装/6.sqoop安装配置/","text":"下载 https://sqoop.apache.org/ nearby mirror hive -e “load data local inpath ‘id_all.txt’ overwrite into table nlp.temporary_id”; hive -e “load data local inpath ‘/data1/nlp/liukuo/jd_data/jd_34levelcity/title’ into table nlp_dev.jd_title_0” CREATE TABLE nlp.test_dbs ( DB_ID bigint, DESC string , DB_LOCATION_URI string, NAME string , OWNER_NAME string , OWNER_TYPE string) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘\\t’ LINES TERMINATED BY ‘\\n’ STORED AS TEXTFILE hive -e “load data local inpath ‘/home/zhangquanquan/hive_dbs_table_data.txt’ into table nlp.test_dbs”","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"Hadoop组件安装","slug":"数据/数据处理/组件安装配置/Hadoop组件安装","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/Hadoop%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"","date":"2024-02-18T17:16:21.592Z","path":"wk/数据/数据处理/组件安装配置/数据qa环境搭建/001.Hive环境搭建/","text":"","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"数据qa环境搭建","slug":"数据/数据处理/组件安装配置/数据qa环境搭建","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E6%95%B0%E6%8D%AEqa%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"","date":"2024-02-18T17:16:21.592Z","path":"wk/数据/数据处理/组件安装配置/数据qa环境搭建/002.Hive-DDL记录/","text":"12345678CREATE EXTERNAL TABLE `nlp.ods_strategy_stats`( `content` string COMMENT &#x27;日志内容&#x27;)COMMENT &#x27;topic boss.nlp4.safe.strategy_stats 导入的hive表&#x27;PARTITIONED BY ( `ds` string, `hour` string)LOCATION &#x27;hdfs://dap/basicdata/kafka/boss/nlp4/safe/strategy_stats&#x27;) 1234567891011ALTER TABLE ods_strategy_stats ADD COLUMNS (uid STRING COMMENT &#x27;用户ID&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (bg STRING COMMENT &#x27;身份&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (us STRING COMMENT &#x27;用户来源&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (traceId STRING COMMENT &#x27;轨迹ID&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (sid STRING COMMENT &#x27;策略ID&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (rid STRING COMMENT &#x27;规则ID&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (sinkAction STRING COMMENT &#x27;处置动作&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (sinkResult STRING COMMENT &#x27;处置是否成功&#x27;);ALTER TABLE ods_strategy_stats ADD COLUMNS (action STRING COMMENT &#x27;原始动作&#x27;);","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"数据qa环境搭建","slug":"数据/数据处理/组件安装配置/数据qa环境搭建","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E6%95%B0%E6%8D%AEqa%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"","date":"2024-02-18T17:16:21.592Z","path":"wk/数据/数据处理/组件安装配置/常用命令整理/001.hdfs常见命令/","text":"","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"常用命令整理","slug":"数据/数据处理/组件安装配置/常用命令整理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"}]},{"title":"","date":"2024-02-18T17:16:21.588Z","path":"wk/数据/数据处理/Flink/flink整理/1.Fink介绍/","text":"Flink的一些特性stream and batch processing, sophisticated state management, event-time processing semantics, and exactly-once consistency guarantees for state。流和批处理、复杂的状态管理、事件时间处理语义，以及对状态的一次一致性保证 can be deployed on various resource providers such as YARN, Apache Mesos, and Kubernetes but also as stand-alone cluster on bare-metal hardware. Configured for high availability, Flink does not have a single point of failure可以部署在各种资源提供者(如纱线、Apache Mesos和Kubernetes)上，也可以作为裸机硬件上的独立集群。配置为高可用性，Flink没有单点故障 Flink has been proven to scale to thousands of cores and terabytes of application state, delivers high throughput and low latency, and powers some of the world’s most demanding stream processing applications.Flink已经被证明可以扩展到数千个内核和tb级的应用程序状态，提供高吞吐量和低延迟，并支持世界上一些要求最高的流处理应用程序。 Use Cases 常见应用程序类型 Event-driven Applications Data Analytics Applications Data Pipeline Applications Tutorial 一.事件驱动的应用程序 反欺诈 异常行为检测 业务流程监控 二.数据分析应用程序三.数据管道应用程序","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink整理","slug":"数据/数据处理/Flink/flink整理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%95%B4%E7%90%86/"}]},{"title":"","date":"2024-02-18T17:16:21.588Z","path":"wk/数据/数据处理/Flink/flink整理/2.Flink学习资料/","text":"Tutorials Windows flink learning blog flink-tensorflow 不错的blog:微服务\\实时特征系统 美团技术团队:流计算框架 Flink 与 Storm 的性能对比 Service Mesh：下一代微服务 http://servicemesh.cn/ Istio知识图谱 v0.1 发布及社区图书孵化","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink整理","slug":"数据/数据处理/Flink/flink整理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%95%B4%E7%90%86/"}]},{"title":"","date":"2024-02-18T17:16:21.587Z","path":"wk/数据/数据处理/Flink/flink整理/4.Flink概念/","text":"无限数据源,有限数据源 DataStream EventTime 与 Watermark 123当我们说“统计过去一小时内点击量”，这里的“一小时”是指什么呢？ 在 Flink 中它可以是指 ProcessingTime ，也可以是 EventTime，由用户决定。- ProcessingTime：事件被处理的时间。也就是由机器的系统时间来决定。- EventTime：事件发生的时间。一般就是数据本身携带的时间。 一般需要基于业务的EventTime 来处理 1234// 1. 告诉 Flink 我们现在按照 EventTime 模式进行处理，Flink 默认使用 ProcessingTime 处理，所以我们要显式设置下env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);// 2. 第二件事情是指定如何获得业务时间，以及生成 Watermark。 1Watermark 是用来追踪业务事件的概念，可以理解成 EventTime 世界中的时钟，用来指示当前处理到什么时刻的数据了。由于我们的数据源的数据已经经过整理，没有乱序，即事件的时间戳是单调递增的，所以可以将每条数据的业务时间就当做 Watermark。这里我们用 AscendingTimestampExtractor 来实现时间戳的抽取和 Watermark 的生成。 文件来模拟真实数据源,本地验证 Flink 应用程序正确性的常用方式 Flink 零基础实战教程：如何计算实时热门商品 5分钟滑动一次，查看指定动作（开聊，发消息）最多的用户，推出来。【important】 设置一个阈值，可以调整，比如3分钟开聊最多的。 然后过滤。过滤正常的用户。 状态特征。 实时特征的存储。 安全的一个方向。","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink整理","slug":"数据/数据处理/Flink/flink整理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%95%B4%E7%90%86/"}]},{"title":"","date":"2024-02-18T17:16:21.587Z","path":"wk/数据/数据处理/Flink/flink整理/5.智能异常检测平台/","text":"如何基于Flink+TensorFlow打造实时智能异常检测平台目的：监控体系，用于提前发现问题降低损失","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink整理","slug":"数据/数据处理/Flink/flink整理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%95%B4%E7%90%86/"}]},{"title":"","date":"2024-02-18T17:16:21.586Z","path":"wk/数据/数据处理/Flink/flink整理/3.FlinkApi/","text":"DataStream启动很多算子。和其它教程，建议看官网的教程学习一下。然后总结下。 Apache Flink Documentation","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink整理","slug":"数据/数据处理/Flink/flink整理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%95%B4%E7%90%86/"}]},{"title":"","date":"2024-02-18T17:16:21.585Z","path":"wk/数据/数据处理/Flink/flink技术点/窗口触发器与Evictors/","text":"title: 3.窗口触发器date: 2020-03-20 11:55:57banner:tags: categories:窗口触发器与Evictors 需要指定Time Notion. Apache Flink：使用EventTime与WaterMark进行流数据处理 Flink学习资料:Flink 灵魂两百问，这谁顶得住？ 状态编程由于同样引入了时间，我们可以想到，最简单的方法其实与之前的热门统计类似，只需要按照用户ID分流，然后遇到登录失败的事件时将其保存在ListState中，然后设置一个定时器，2秒后触发。定时器触发时检查状态中的登录失败事件个数，如果大于等于2，那么就输出报警信息。 CEP 定义匹配模式 在数据流中匹配出定义好的模式 Flink 灵魂两百问，这谁顶得住？ 1小时内一个ip下的用户数 一分钟内一个ip下的用户数","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink技术点","slug":"数据/数据处理/Flink/flink技术点","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"","date":"2024-02-18T17:16:21.582Z","path":"wk/数据/数据存储/003.文档/","text":"文档HBase官方文档","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据存储","slug":"数据/数据存储","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"","date":"2024-02-18T17:16:21.559Z","path":"wk/MicroService/技术框架/RPC/thrift/thrift安装/","text":"thrift安装.md ubunut18(Dep)安装太麻烦,容器出错. copy build后的可执行文件 到/usr/local/bin/ 目录下即可. 可执行文件： 12345678910# 准备工作sudo apt-get install automake bison flex g++ git libboost-all-dev libevent-dev libssl-dev libtool make pkg-config# 下载[thrift](https://www.apache.org/dyn/closer.cgi?path=/thrift/0.11.0/thrift-0.11.0.tar.gz)# 安装./configure &amp;&amp; makemake install","tags":[],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"thrift","slug":"MicroService/技术框架/RPC/thrift","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/thrift/"}]},{"title":"","date":"2024-02-18T17:16:21.555Z","path":"wk/MicroService/技术框架/RPC/Netty/疑问/","text":"为什么 ChannelOutboundInvoker 有用 ChannelPromise, ChannelPromise.. Inbound没有. 理解应该是，如果outbound写出去了. 就isDone 了. url = “http://ip:port/fabio/extract“requests.post(url=url, data=post_data,headers={‘Content-Type’:’application/json’})","tags":[],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Netty","slug":"MicroService/技术框架/RPC/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/Netty/"}]},{"title":"","date":"2024-02-18T17:16:21.548Z","path":"wk/MicroService/技术框架/Netty/疑问/","text":"为什么 ChannelOutboundInvoker 有用 ChannelPromise, ChannelPromise.. Inbound没有. 理解应该是，如果outbound写出去了. 就isDone 了. url = “http://ip:port/fabio/extract“requests.post(url=url, data=post_data,headers={‘Content-Type’:’application/json’})","tags":[],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"","date":"2024-02-18T17:16:21.542Z","path":"wk/MicroService/技术框架/Mybatis/手写mybatis/","text":"手写mybatis 这么写参数校验(validator)就不会被劝退了~","tags":[],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"MicroService/技术框架/Mybatis","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Mybatis/"}]},{"title":"","date":"2024-02-18T17:16:21.538Z","path":"wk/MicroService/技术框架/SpringBoot/自定义starter/","text":"首先我说一个我们都遇到过的一个问题。 组里有很多的项目在持续，陆续也有新项目开启。 那一般开启新项目怎么做？？ 12341. 每个人搭建出来的项目都不一样， 比如 依赖的技术组件，版本，项目结构，打包，启动方式（启动脚本）。 依赖的第三方包的选择，版本选择。","tags":[],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"MicroService/技术框架/SpringBoot","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot/"}]},{"title":"客户端最新技术","date":"2024-02-18T14:55:57.000Z","path":"wk/平台工具/编程相关/客户端开发/001.客户端最新技术/","text":"最新的客户端技术语言：Java / Kotlin ; Objective-C / Swift 关键词：移动端跨平台、Flutter、C++ 开发(音视频相关) 沟通能力、学习能力、快速响应变化. 开发平台. Gradle、Android性能. Android框架源码. 网络协议、多线程. 分析和解决实际问题的能力和态度. 跨平台（React Native、Flutter） JD要求 了解Android Framework 系统架构、有Android 源码分析经验。 有App性能优化的经验，包括网络、内存、CPU等. 有C++编程经验，可以独立封装JNI接口. 具备扎实的OC和Swift语言基础，有良好的编码习惯和代码风格.","tags":[{"name":"Android","slug":"Android","permalink":"https://quano.gitee.io/tags/Android/"},{"name":"客户端","slug":"客户端","permalink":"https://quano.gitee.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"IOS","slug":"IOS","permalink":"https://quano.gitee.io/tags/IOS/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"编程相关","slug":"平台工具/编程相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"name":"客户端开发","slug":"平台工具/编程相关/客户端开发","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"沟通-重要性","date":"2024-02-08T01:56:24.000Z","path":"wk/项目管理/000.沟通能力(重要)/000.沟通的重要性/","text":"领导眼中工作价值 = 你的工作价值 * 沟通能力.","tags":[{"name":"沟通","slug":"沟通","permalink":"https://quano.gitee.io/tags/%E6%B2%9F%E9%80%9A/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"000.沟通能力(重要)","slug":"项目管理/000-沟通能力-重要","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/000-%E6%B2%9F%E9%80%9A%E8%83%BD%E5%8A%9B-%E9%87%8D%E8%A6%81/"}]},{"title":"云计算认识","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/000.README/","text":"云计算最初的目标云计算最初的目标是对资源的管理，管理的主要是计算资源、网络资源、存储资源三个方面。 {:width=”600px”} 发展历史追溯到20世纪50年代，当时计算机技术和网络技术的发展为云计算的出现奠定了基础。 云计算之前的计算模式是：传统的数据中心和客户端/服务器模式。 这种方式存在硬件和软件资源的浪费、数据安全和隐私保护问题，以及难以实现计算资源的灵活扩展等问题。 随着互联网的发展和大数据处理的需求增加，传统的计算模式已经无法满足需求，因此云计算技术应运而生。 云计算是一种基于互联网的计算模式，它将计算资源集中起来，通过虚拟化技术实现计算资源的灵活扩展和动态调度，从而提高了资源的利用率和灵活性。 优点特性：安全性、灵活性（时间灵活性、空间灵活性）、降低成本、提高资源利用率。 关键技术和应用云计算的发展历程中，出现了许多关键技术和应用。例如：分布式计算、网格计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂等。 分布式计算：一种将一个大型计算任务分解成若干个小部分，然后在多台计算机上并行处理的技术。（提高计算效率和计算能力，并且可以充分利用计算机资源） 网格计算：分布式计算的一种，它将一个需要大量计算的任务分解成若干个小任务，然后在网格中的多个计算机上进行处理。（强调网络：对计算资源的调度管理，以充分利用空闲的计算资源，提供效率和利用率） 效用计算：一种提供服务的模型，服务提供商提供客户需要的计算资源和基础设施管理，并根据应用所占用的资源情况进行计费，而不是仅仅按照速率进行收费。效用计算可以降低客户的硬件和软件成本，提高资源利用率和管理效率。 负载均衡：一种将计算任务分配到多个处理器或计算机上并行处理的技术。通过负载均衡，可以避免单点故障和性能瓶颈，提高系统的可靠性和性能。 并行计算：一种将一个大型计算任务分解成若干个小任务。 网络存储：一种数据存储方式，它将数据存储在多个硬盘或存储设备上，并通过网络进行访问和管理。网络存储可以提高数据可靠性和可扩展性，并且可以方便地实现数据共享和备份。 热备份冗杂：一种数据备份和冗余技术，用于保障系统的可用性和稳定性。它可以在系统运行的同时进行数据备份和冗余，保证系统持续运行，降低系统故障对业务的影响。 每种技术的应用：用于数据安全、系统稳定性、机器学习、容灾、云计算、分布式存储、大数据处理等 发展比较相比于以前传统的数据中心和客户端/服务器模式，实现了计算资源的集中管理和动态调度，为大数据处理、企业应用、移动应用等领域提供了强大的支持。 云计算分类云服务类型角度、计算原理角度、部署模式角度。 {:width=”600px”}","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"云计算-产品","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/01.产品技术架构/001.产品/","text":"以阿里云为例，主要分为几个方面： 计算、容器、存储、网络、安全、中间件、数据库、大数据计算、AI、等等。 云计算的产品和解决方案之间的关系可以理解为是一种有机组合。云计算的产品包括计算、存储、网络、安全、人工智能、大数据、物联网等方面，而解决方案则是基于这些产品，通过有效组合和配置，解决系统性问题的一种方法。 具体来说，云计算的产品是实现云计算解决方案的基础组件，解决方案则是将这些基础组件进行有机组合，以满足用户的实际需求。云计算解决方案的构建过程通常需要考虑用户的需求、业务场景、技术环境等多个因素，通过合理的配置和优化，实现云计算资源的共享、效率和节能，提高用户的业务效率和竞争力。 云计算产品和解决方案的提供商可以根据用户需求定制化产品和服务，提供符合用户需求的解决方案。同时，随着技术的不断发展和用户需求的变化，云计算产品和解决方案也需要不断迭代和创新，以满足市场的变化和用户的需求。 总之，云计算的产品和解决方案之间的关系是一种有机组合，通过合理的配置和优化，实现云计算资源的共享、效率和节能，提高用户的业务效率和竞争力。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"01.产品技术架构","slug":"平台工具/云计算/01-产品技术架构","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/01-%E4%BA%A7%E5%93%81%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}]},{"title":"云计算-技术和架构概述","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/01.产品技术架构/002.技术和架构/","text":"云计算是一种基于互联网的计算方式，它通过虚拟化技术将硬件资源（如服务器、存储设备和数据库）转化为动态可扩展的虚拟资源，并通过网络提供给用户使用。云计算的技术和架构包括以下几个方面： 云计算技术 虚拟化技术：云计算的核心技术之一。将物理硬件资源虚拟化为多个虚拟资源，实现资源的共享、灵活调度和高效利用。虚拟化技术包括服务器虚拟化、存储虚拟化、网络虚拟化等。 分布式技术：分布式技术是云计算的重要组成部分，它通过将数据和应用程序分布到多个节点上，实现负载均衡和高可用性。分布式技术包括分布式文件系统、分布式数据库等。 容器化技术：容器化技术是一种轻量级的虚拟化技术，它将应用程序及其依赖项打包到一个独立的容器中，实现应用程序的快速部署和管理。容器化技术包括Docker、Kubernetes等。 微服务架构：微服务架构是一种将应用程序拆分成多个小型服务的架构模式，每个服务都运行在独立的进程中，并使用轻量级通信协议进行通信，实现高内聚、低耦合的设计原则。微服务架构包括Spring Cloud、Dubbo等框架。 自动化运维：自动化运维是云计算的重要特征之一，它通过自动化工具和流程来降低运维成本，提高运维效率。自动化运维包括自动化部署、自动化监控、自动化备份等。 云安全技术：安全技术是保障云计算安全的重要手段，它通过数据加密、访问控制、安全审计等手段来保护云端数据和应用程序的安全。云安全技术包括身份认证、访问控制、数据加密等。 虚拟化技术存储虚拟化： 基于存储设备的虚拟化、基于网络的虚拟化存储。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"01.产品技术架构","slug":"平台工具/云计算/01-产品技术架构","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/01-%E4%BA%A7%E5%93%81%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}]},{"title":"技术架构思考总结","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/01.产品技术架构/003.技术架构的思考和总结/","text":"","tags":[{"name":"架构","slug":"架构","permalink":"https://quano.gitee.io/tags/%E6%9E%B6%E6%9E%84/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"01.产品技术架构","slug":"平台工具/云计算/01-产品技术架构","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/01-%E4%BA%A7%E5%93%81%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}]},{"title":"云计算解决方案-底层思维","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/02.解决方案/001.底层思维/","text":"一个解决方案的组成：比如 架构、需求、用到的技术、解决的问题、优缺点 等。 领域划分。安全、技术平台、基础设施领域解决方案分析。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"解决方案","slug":"解决方案","permalink":"https://quano.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"02.解决方案","slug":"平台工具/云计算/02-解决方案","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/02-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"云计算解决方案-5大场景","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/02.解决方案/002.解决方案架构师5大场景/","text":"一、 5大场景1. 生产数字化中国是制造大国，接下来10年，咱们要尽快成为制造强国，顺势而为，吃透制造场景，就拥有了制造业的架构能力。 工业互联网、产业互联网、网物联网 2. 供应链数字化未来像小米这样只搞研发设计，制造OEM化的公司多如牛毛。 谁掌握了无边界组织的精髓。 3. 营销数字化客户管理、品牌互动、精准营销只要是零售、不管是卖手纸、卖手机 全都营销数字化转型。 4. 财务数字化老板 是半个精明的财务能用数字化 帮老板把钱捋顺 5. 经营数字化老板，决策拍脑袋，对错全靠民。 数组 二、架构师的不同、区别总结。包含关系：企业架构 &gt; 解决方案架构 &gt; 技术架构. 1. 技术架构解决的问题：特点系统技术层面的结构性问题。目的：在技术层保证软件的质量（效率、成本、性能-质量、安全-稳定性） 2. 解决方案架构解决的问题：系统性问题，不局限与技术层面.目的：使系统满足客户的需求，包括功能、安全性、合规性、成本等. 在技术架构的基础上。 包括网络安全、需求场景、成本、安全-合规等 3. 企业架构解决的问题：企业中系统本身，系统间的结构性问题目的：通过对系统结构性调整来使企业内的系统能够支撑企业的战略发展需求. (合规性、安全性、成本) - 不同架构和技术的实现，带来的一些问题。 三、架构师需要具备的能力技术层面：网络、存储、 面向市场的解决方案架构师。 8-10年的经验。 三、个人思考总结","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"解决方案","slug":"解决方案","permalink":"https://quano.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"02.解决方案","slug":"平台工具/云计算/02-解决方案","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/02-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"云计算解决方案-售前区别","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/02.解决方案/003.解决方案架构是和售前的区别/","text":"解决方案架构师（SA） SA能力极其复合。横跨售前、售中、售后；也就是具有出方案、拿订单、抓落地的 广谱能力。 而售前的能力往往只聚焦在售前， 对于落地能力（不怎么样） SA 虽然能力具有广谱性，但80%的 SA往往只做出方案 和拿订单的活。 至于抓落地的苦杯活，往往敬而远之。（因为挖坑比填坑赚钱…） 所以时下的SA都是“管挖不管埋”； 至于售前也就是攒攒WORD、堆堆PPT， 做这些垃圾活，可以说毫无存在感。甚至感觉自己啥都不是。 听说过“围标”吗？ SA往往做主标；也就是SA投的标，会中标； 至于售前，往往是陪标的（当托） 售前陪标的使命，就是不中标 基于客户的需求 还有自己的产品去 制作方案。然后向客户传递方案；解决客户的痛点。 （与程序员的区别：看客户的需求、看自己的产品；基于客户的场景、业务流程，帮客户去解决问题） 不是纯产品的架构师，更多的是站在客户的角度。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"解决方案","slug":"解决方案","permalink":"https://quano.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"02.解决方案","slug":"平台工具/云计算/02-解决方案","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/02-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"云计算解决方案-面试","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/02.解决方案/004.解决方案架构面试/","text":"议题1. 基于XXX(AWS、阿里云)平台的服务设计一个架构 分析：都有哪些可用的服务和产品. 云服务器、容器、弹性伸缩、数据库、….. 对不同分类的产品非常熟悉. 分析客户需求. 给了两周时间学习AWS和准备Presentation的内容.花时间好好看AWS资料，并且不建议缩短时间，让提前两天做好PPT发给HR. 例：”初创公司基于Lamp架构设计的方案，用户有10大痛点，如果迁移到AWS上该如何设计？“ 【Presentation时间是50分钟】 2. 基于你过往的工作当中你认为最好的架构，设计并讲解如何设计的资料亚马逊”AWS解决方案架构师”","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"解决方案","slug":"解决方案","permalink":"https://quano.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"02.解决方案","slug":"平台工具/云计算/02-解决方案","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/02-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"阿里云-Serverless","date":"2024-02-03T14:55:57.000Z","path":"wk/平台工具/云计算/03.阿里云/001.Serverless/","text":"37df3367815823fa6a74ef48ceb506656481592d6be2999baead838b6c9d87386a3b8b78ae531c4f89e542b1e20e3bbf7eed79e75656e689a8c2ef57745a4f2a924d3b7f6951d9f4ae0b1356aa0e5ced92f40ead4ed258e3338ea1e646dfc8e1dd6b93ddfa675b503639cfbca4c0cb97a18b322f4cbb76b1118fc954f976725b56b94ef75683413d513b482c421ebab7982358b346c476156234a8c47b964b04a8c9f84266059dab1d3692177c4d35887f8a50f842d51bddad0febeebfa5d7bffb87fe81e2204ea90e33876210d72dc123d6151483fb163a41e1914deec545c3c1ae91b5e8ce5c61fe91d4b50c75614ed881790c508bbd12aae54fd6b88c1d9963f826208a152060691240d08ba42f24557a4016f462bc98bcfa058e5b692b70ee715627e30cb2642090919f8937d8b04c4e3d2a59745dc52372f650c8f0057a77caead768297055582c783813617494ad3a0fa6104fc0cd2348a4229031b36870d6a6f20479019b103874057d1a4c96c62d4c45ab2f0d9876089480950dc421c63fe98e7499960b7922cf58e0179727984195fa7a06d03bc65d1dd0db0f48336e42986643c37cac4810bdf53fe0ed60414e380fddd1d73a838157f189e6a2757949c520e48de0216be260883cb38fdfa4d96bf7428f18ee5692646eada0388b05b682197f573abfb2c34495e196efd4a3a6065114a6485b8658bc4e595acf34980947a79015fc737734490ba8c6771eb23117bdbf046ec853d9d424074d38083d1ee3ddada057d95bc4a8c6e227fec76c8282466f408ad3acfd26cd6e08befb9fadace98f1ea87b7233f4471c4c2bedfa2aaf3c481a096408429c0fbff02a7d8c13414d9644e3fe6b03f5a052e27a60a5258aff151cbe3325a34a5ecf0387fb967e35f15b17f6339f88459e25879d49776b2903c648e877d36c829e0a81703990bdfd44515ad005cab4fdd8b3ccf72bc1856079c44461211bfa0671a804271f90b7ad9b468b44b9202a643c9da05374c55bcda22f882cea6e42da33ac4911707206a2de6084d5b92b0209f7c0c620d70760b73254eb515c3ddbbb85cc40e55c3fd113932286a0cf2b58e310bb9a0a762ad3aaf1b3c3857835b892c7b65073f0cbab497ba20b2b79a3b3aa9bf2175dfa1632e64c9957793dfb0c4af488dbf3014313c412d7cf4cbb12310e1174cd6cc6cdcecb5efd15215d37354b1b81377788757e69659791e24f4229f19ee21184ee7a6bfe79a05cf5311fa27c80a0f4ee4152912449203d3c8fc354fea82e15c37880e8be0fce406e06228e420df2d33c7532fed480a70b0e9807575140125a431c97c3b20dbd425dd1bd6d7b0d0239c4a4e18f639b1ae099f0d57bc315fca7f46ad24df0ddefb5667853e2bd5c00d25bbb8e30b3cfed44b6ad099094aeb9736db57cb979e3dc27fa53c2516b370499d0ffea6a344e194c0ffec4d4e67dc8ba539cfee89601f810b79644110fef7dddb63971b29e12031646d4698d5d7ea7476f79d8229de386f3a342b9df0919e2a0f4e4691577915e52ecd7b1794752b641424778e371fdccaa9a7b517db1579e6458566ba0638be780202dedf49a6d74b21033b087123a2fec787e62dc0a2b3297d68f84837cf098b726ca5ceeeb30e27669a419386358fc3fdc1935b72fae5c547001125e4ec162d8dfaa31a8967d8f241ff5ad57454d3573e15e04c42cb1f4f2e6d4b7bce138ec8a39f99dc363e9c591904297dc502b9f0ee491b97de602324d9f4a4357a1e803ab2f313e94a716bc2f853bde5cbef3ae99587c3316a2844ccf806ce45c4ee6a341431e07c7d55cdf6e9ef0116e54a0f0e01f202bd695ca935504b3a87d654a64c9f0f27781831b1e3270cee03528423c4eb462a1d9ffd222a3a14a7f15e47b8e418854b1cd8e377c927fd7a28305a9eda37823da0242306afe911f8dd882d83098dc0b77855e22362a804f591930d14a58e2e2f7f239199145732cd6bb47e6f619aa13a00b98a8aef792b77cd22198ba39881ec1ced6fd0ebaf99c3e14b186e6d83f1cba401604a3d7f8b376371f9bcbd6ff0607a0685700b8d5a5ad4ca9076a32209a4e6fd5d4f1351cdb87d9a631644078f5ce62ac71e6c5c15b65b8fea421356c0bfca295d8a2b33e730856ccd76c1977d3e653c8a26024be312d9902fbfb272818575c0f3cc96f04c7ae2e6c8d52cc547f00a7e82904f839d129c9103b232a4562c6d5099089dd0ce2056540ead6a6e1a6de38436129f5af94dd936cf07cbd42b4b6f9055c5fe6fedd3e6fb06f537e27c987789d27661dda3ce318e6e4ab0162b958bbd2b30731c4b8b14bf7839db2a9d3383d1314d39f6526e008ac24688ad01412613d2fdcd75606f07d97d6bfa8126469db5e13d05045231ea89648d3a8ad8980ec091e09f29db7999ea618996d3e1093b75bd9186ea8613d067d7c38a8882a26ef280857009e769135eaed54d98358c5e1f15f72cdca44bb2aa51994596022e6e4eb49bc5dc1e7fec642ae88d8b0e5c95b75f2ac1eaafe3e7f267d434afbc93bef3c52b924508336858fc93edc5ffcee09d3cb7e2df5df0f0135f8502601e080b4b1a33fb8ae0333925e57fb6d493bb2cd04962aed2b25c90f03eae03ded46bccec80d90e1f6793b32207e749457455caa46fe92676aee04b8c15b864405b4860df52e0da058b315eed1018b68d7dd9aa0a9357591db434c5362ab3f864d2c8b5f02d52f16d8e5be9cf6f69fda621dc8ff7802b431af714e0319371a9a02175454ede3b140f881e6c324090e4b21cea917a195e6360323b950b8b614b2af89f36360a26c053a5f3ee56c8550f58abcee96d637fe956d0926813541d89cb37d405144b19795a53302200ccfbcef37996da29f039c79e87da3010ca2f60c5adc8c35f8188c27c1ca18a51d246212629c3829f61ab3bcabdb914a49dbf2e1645b7d549b5049f796aa9d384ab3e083ecbbe66dc836eddef927e5d07ded0b95a8640bb840d4e259fa53de57fd8418da8d375454b135a215e498159c6339f3a42bc5eca603480e1e9cf329f3cb71ae6318a9567c9b2b6011c4993197e1258f68e9c23758d6ffae436f11850d1a0db2fbeea3c2581bc6d4d524505bab4f61fe935e76a8d3a454764fb64141c02d19f5f3cc01d3adcd35ed85ea31ede2214c61f6f72da46b486f4037b899cd95f509d97ef382a3fecdf3031ff950bdc41c72f3528dfbcf629595077f088ad27459279e7fdd96ea6692d13d85375cbb25c7f7d725799707c080661ca542a2257792932825b699c914d713c1dedc1ce7d82a9025e5991d504b37917bb4c1eaaa10a1bdb787351e04ba22a9c8926f78071a58588a460224a2d17f8a886b60cba93ceaa0887d3fbc680ec67600b2956611069fc00b6f425e4104443438a17320c873be67ddf789b479aca8266c3ed7a09df85de664a77686edc92612dba7fa1f1bebf8109fc004cea67739a4764b46c945d9536e1eb11eb1ec1685e8f08efe7d329f29d9ff38c15ecf52add1b38c34fc9f6069c55bfb68e5e4ba436c86005e23ab082090237df2f1ee179b6c7b122908fb9e957dd3f48beba2f28e508209a20cb505b07c48242d241e8f0b61dc436fc51900e95dd97053fb4e8e70c380a52d7b8cfb32c68a27b0c4e2a83368cd807465f8cdf06148d12dba88bede878237a7ee88b53d2455434e56ca655b9b37f6d8aa2a401f7b36b0b41c0f81e525b837674d0fb580bfee52e54b30208c7177bf9c73e8d96056afdba97c6a354eaf784f2ff9a9795dfec2ff9a8686f6edd8fd6c27c05246012d02d6fa17f003bca76072217a42cc38d002f666ea8e49a509e9689735f30df47d4a22c88b19472f587312fdcd6d5272a8a7314d70dce188ab158be7d451d8c43a9b03e4729ccf1aac244d2e57ed878a315bff860f98979f1b3644a4458d48923023e24c4c29295d2ad7be3a5b96abd60472e355104f43757fc0e61823645408f0f42a0cbb2b9a21edd5a3cd38a0bf8842cadf8d0db7049610fe730874b0ee3b4e36b1d1fb33ee33d3589cf716b406d05f430fb6e6f6389917c68d5b6ccdea835b5226ba826c00d085767401be5ffb2d1002e6bcf8b73fe40784807dcfa16ab15c42554ca487090b8bfd19de746f6ec2dcaf005414c213e772c36319fd510fa56715c435292d76392b1d21ce3c9cb4c8647ac4b1dfcfc722722e93fee57cac2e6e4895df611def7e659dc8b1c78143d857f277d07df07bfe62e71a1d0791e9664dc1508eb81d4a22fc0ff11f4920301cca896bbc319e22d21907339e23aadfb572121bf35a5b273ef56ef1caa0e43ec5025cb892f4265f899d8743ed6fa485b7e769fb1c2b2a231d1ce2524612592068b662eac1768bb5062834f9c43b5de74655cdc607e09786c20e8f70235bde8a6d864dad70cbc4d7754a6b2d0af0c55b8e1ed4a9d7edf4d616b35267839371255073dd6d4d065ce2088203b10308ebbfdf898d86998f23da06047a6ab170e0d6a8bc08d899fab50ad8197477cfba2f0e6a968bad5a59e58ccc107b6ab25c1577932db7ff67e26bbdd77be3d543c3688b4951db9afc15d723e5291930c7a476ce568447d23ebdf9b42a987e38e8bc306a714d1d508e6fbce440cf1ea698ad40f33e5d37b83946c2b6100ed6bd9fcc32c4313817a116c4060081fbf767d7a6cad5e47e4f6818ac57e80eec340f2c97d3af2eb5e9a2ab701016c50d07d8f31c422a0aecf3c3f64406c76107b023fd6e16cc73dd1eed33049c010ce7a4e6835f9e623d16febce25dbe1443338eaee37af64e28bbe260ff218870a834d4f38dd69e5e62cef2c45c0dc0a3268800ab12231d2f84ef00d8ab0f6d94cdc8e4e6a38221003936a67a70c4f7d268568028ffdc17825432091f6b75f3a3c0543d932ec5d00277ac90e7b3d6cbdadd211ec3b6aaec48d815816cd1090cf5bd0eead29a7832b687202a16ccc6be84ad119f3d71285af89bc563ea835aca857052e73b5baf030751e5bfb4e85164814bbd0a2690d6ca702a3c25e9250a6dec01089e01fc4332224544e6eba75fb9afd853507a98553b3c3a7cd9b4021186b11b453d22d88615513468e0cf466477a41c34ebb102e91bd2deb193aaad9fbcd0c3fd06944f59eb20583fda5a1548716741e34f543f03844cf00b7cee45db2ca23179002c43f6124a358773afa2a3e96f1fc1df3b34f92848bc2d076009c62f9b88d368e12fc3da3b25800e0eff06f85f10095abe4b2017673e24a5beb28c7d210ba708ac735f Hey, password is required here.","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Serverless","slug":"Serverless","permalink":"https://quano.gitee.io/tags/Serverless/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"03.阿里云","slug":"平台工具/云计算/03-阿里云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/03-%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"001.机器识别基本概念.md","date":"2024-01-28T14:55:57.000Z","path":"wk/算法/003.图像识别/001.机器视觉基本概念/","text":"机器视觉（Computer Vision）是一门涉及计算机科学和人工智能的交叉学科，其目标是使计算机系统能够理解和解释视觉信息，模仿人类视觉系统的能力。以下是一些机器视觉的基本概念： 图像： 图像是由像素组成的二维矩阵，每个像素表示图像的一个小元素。机器视觉系统通常以图像作为输入。 图像处理： 图像处理涉及对图像进行预处理、增强和分析的一系列技术。常见的图像处理任务包括滤波、边缘检测、图像变换等。 特征提取： 特征是图像中具有信息量的部分，特征提取是从图像中选择和提取关键信息以用于进一步分析和识别的过程。常见的特征包括边缘、角点、颜色直方图等。 图像识别和分类： 图像识别是将图像分为不同的类别或标签的任务。图像分类是机器学习中的一个重要问题，涉及训练模型以自动识别图像中的对象或场景。 目标检测： 目标检测是在图像中定位并识别多个目标的任务。与图像分类不同，目标检测需要标示目标在图像中的位置。 图像分割： 图像分割是将图像划分为具有语义意义的区域的任务。目标是将图像中的每个像素分配到相应的类别。 三维重建： 三维重建是根据多个视角的二维图像推断出场景的三维结构。这在计算机视觉和计算机图形学中都是重要的问题。 深度学习： 深度学习是一种机器学习方法，通过使用深度神经网络来学习和表示复杂的图像特征。深度学习已经在图像识别、目标检测等任务中取得了显著的成功。 todo: 总结以前同事工作相关的概念. 总结之前的项目，变为自己的项目经历. 最新模型架构用到的一些知识点，补全. yolo等. 找鹏波聊一聊 图像相关的技术. 图像处理基本算法有哪些： 图像处理涉及多种基本算法，这些算法可以用于对图像进行预处理、增强、分析和处理。以下是一些常见的图像处理基本算法： 灰度化（Grayscale Conversion）： 将彩色图像转换为灰度图像，通常通过对RGB通道的加权平均来实现 直方图均衡化（Histogram Equalization）： 通过调整图像的灰度直方图，增强图像的对比度 滤波（Filtering）： 使用不同类型的滤波器进行图像平滑（低通滤波器）或边缘增强（高通滤波器） 去噪（Denoising）、边缘增强（Sharpening）、 模板匹配： Blob分析： 图像缩放（Image Resizing）： 图像旋转（Image Rotation）： 资料：图像处理算法：从基础到先进实践","tags":[{"name":"机器视觉","slug":"机器视觉","permalink":"https://quano.gitee.io/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"}]},{"title":"1.RCNN","date":"2024-01-28T14:55:57.000Z","path":"wk/算法/003.图像识别/目标检测/002.RCNN/","text":"定义RCNN是一种目标检测框架。首个将 CNN 引入目标检测领域的算法模型. 在特征提取阶段使用CNN（AlexNet）其它阶段使用的还是传统目标检测的方法. 背景最初的 R-CNN 在2013年提出，但速度较慢，因为它需要对每个提议框进行单独的卷积操作。 后续衍生出很多优化版本：Fast R-CNN（2015）、Faster R-CNN（2015）、Mask R-CNN（2017） 架构R-CNN目标检测主要分为四个大的阶段. 1. 产生候选区域 对于输入的图片，使用Selective Search方法（了解即可），选择出2000个候选区域（每个区域大小不一） 2. 特征提取 使用AlexNet对每一个候选区域提取特征，得到2000 * 4096维的特征向量 AlexNet是一个经典的深度卷积神经网络.在2012年的ImageNet 中获得了第一名。 AlexNet有11层：5个卷积层和3个全连接层，3个池化层. TODO：有助于对于滤波器的理解 12注1：在进行特征提取之前，需要先对上一步生成的候选区域进行调整，使其变为227*227，这是因为AlexNet输入是固定的，当然，其实卷积操作的输入可以不固定，全连接层的输入大小才是固定的，这也是后面几个模型会改进的。注2：调整的方法比较暴力，不管输入是多大的图片，直接缩放到227*227 3. 候选区域类别判断 将2000 * 4096维特征向量送入到21个（20个类别+1个背景）SVM分类器中，每一个SVM分类器包含4096个参数，所以可以看成两个矩阵相乘，即 ，这样就得到了每一个候选区域是某个类别的概率值。因为一张图片出现有上千个物品的可能性微乎其微，所以必定有大量的候选区域是重叠的，因此需要去除冗余的候选框。作者在此处使用非极大值抑制（NMS）方法来去除冗余候选框，对于每一个类别中IoU大于给定阈值的候选区域。这样就得到了每一个类别得分最高的一些候选区域。 4. 使用回归器对候选框位置调整 对于上一步经过NMS筛选后的候选区域，其精度必定不够，所以需要进行进一步的调整，因为该部分在Faster RCNN中也有用到，所以具体的细节放在后文 RCNN框架 总结在文章中，作者认为 R-CNN 较之前的算法，能够取得30%的改进是基于以下两点： 使用了CNN来提取候选区域的特征 使用迁移学习，因为目标检测领域的数据相比图像分类任务要少很多，所以使用在图像分类上训练好的模型，经过 fine-tune 可以很好的运用在目标检测上。 可以理解为：R-CNN是个实验品，首个引入 CNN进行目标检测的算法。 主要是因为 性能差，训练繁琐，效果一般. R-CNN的不足 速度慢，因为需要对selective search算法生成2K个候选区域分别提取特征，而又由于候选区域的重叠问题，所以这中间有着大量的重复计算（这也是后面的改进方向）。 训练步骤繁琐，需要先预训练CNN，然后微调CNN，再训练20个SVM，20个回归器，期间还要涉及用NMS去除候选冗余框,（光看着就让人头皮发麻） Fast R-CNNR-CNN的改进：在R-CNN和SPPNet的基础上进行改进 准确率提升：与R-CNN、SPPNet相比，有着更高的准确率 多阶段训练-&gt; 单阶段训练：通过使用多任务损失，将模型训练由多阶段转变为单阶段训练 一次性更新，无需分步：训练时可以一次更新网络的所有层，不再需要分步更新参数 不再需要硬盘来存储CNN提取的特征数据 流程主要分三步： 候选区域生成：使用 Selective Search 方法生成2K个图片候选区域 对整张图片进行特征提取得到相应的特征图（大的改进，参考了SPPNet）；并将上一步生成的候选区域映射到特征图中 使用ROI Pooling将所有的候选区域特征统一缩放到7 * 7大小；然后将这2K个特征向量展平。并连接到全连接层上，得到两个输出结果，一个是K+1类(类别数+背景类)的概率，还有一个是每个类的预测边框。 参考卷积神经网络经典回顾之AlexNet","tags":[{"name":"图像识别","slug":"图像识别","permalink":"https://quano.gitee.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"目标检测","slug":"算法/003-图像识别/目标检测","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"算法","date":"2024-01-27T14:55:57.000Z","path":"wk/算法/000.README/","text":"001.机器学习. 机器学习相关概念、传统机器学习 002.深度学习 深度学习算法，及常见的模型架构 003.图像识别深度学习专业领域：图像识别(CV)方向. 004.NLP深度学习专业领域：自然语言处理(NLP)方向. 005.大模型 todo 模型训练相关知识. 梯度下降等 总结目前实际业务中 用到的算法. 总结之前 实际业务中，用到的算法. 多与人交流. 资料微软人工智能教育与学习共建社区 机器学习100天。https://github.com/Avik-Jain/","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"2.云容灾备份","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/云计算/政务云/002.云容灾备份/","text":"云容灾备份云容灾备份是指将企业的关键业务数据和系统镜像备份到云端，以确保在发生灾难性事件时能够快速、可靠地恢复业务。以下是与云容灾备份相关的一些关键技术： 云备份服务： 云服务提供商通常提供专门的云备份服务，允许企业将数据和系统备份到云端。这些服务通常提供自动化的备份计划、增量备份、快速恢复等功能。 数据复制与同步： 利用云中的数据复制和同步技术，可以实现实时或定期将本地数据同步到云端。这有助于保持云中的备份数据与本地数据的一致性。 虚拟机备份： 对虚拟机进行备份是云容灾备份的重要组成部分。云服务商提供的虚拟机备份服务可以将整个虚拟机的状态、配置和数据备份到云端，以便在需要时进行快速恢复。 快照技术： 云服务商通常提供快照技术，可以在瞬间捕获存储卷的状态。这使得在需要时可以快速还原到先前的状态，提供了有效的容灾备份方案。 异地多活： 在多个地理位置部署业务节点，实现异地多活，确保即使在一个地区发生灾难时，其他地区的节点仍能够继续提供服务。 自动化备份策略： 制定自动化的备份策略，包括定期的全量备份和增量备份。自动备份可以减少人为错误，并确保备份过程的规律性。 容灾演练： 定期进行容灾演练，验证备份数据的可用性和恢复过程的有效性。演练有助于发现潜在问题，并提高应对灾难的能力。 安全性与合规性： 在备份和恢复过程中要确保数据的安全性和合规性，采用加密技术、身份验证机制等手段，保护备份数据不被非法访问。 监控与报警： 设置监控和报警系统，实时监测备份状态和存储容量，及时发现潜在问题并采取措施。 云存储服务： 选择可靠的云存储服务作为备份的存储介质，确保数据的可靠性和持久性。 云容灾备份是企业信息化建设中重要的一环，通过使用云服务，企业可以更加灵活、高效地实现业务的容灾和恢复。 容灾演练、 机房演练、异地多活、set化。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"政务云","slug":"平台工具/云计算/政务云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%94%BF%E5%8A%A1%E4%BA%91/"}]},{"title":"1.政务云","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/云计算/政务云/001.政务云介绍/","text":"什么是政务云标准定义：云技术在政府行业的应用。 定义：是指运用云计算技术，统筹使用政府已有的机房、计算、存储、网络、安全等资源，为政府部门提供基础设施、支撑软件、应用系统等综合服务的平台。 政务云： 政务云是一种云计算服务，专门为政府机构和公共部门提供的云服务。政务云通常具有高度安全性和合规性，以满足政府数据处理的特殊需求。政务云可以提供各种基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）等服务，以支持政府的信息化建设和数字化转型。 信息化建设、转型目的：提高效率、优化决策制定、提升服务质量、加强安全和合规性、促进创新和科技发展、节约资源. 12345政务云可以降低政府信息化成本、提高政府工作效率、促进各部门间的信息共享和业务协同等方面的优势，是政府信息化发展的重要方向之一。政务云可以通过云服务平台的方式提供各种服务，如政务信息资源共享交换平台、电子政务服务平台、公共服务平台等。政务云的应用范围很广，可以涉及到政府办公、公共安全、城市管理、环境保护等各个领域。优势：严格的数据保密、高可用性、高容错性；具有天然防ARP攻击和MAC欺骗，快照备份，数据永久不丢失等特点；资源利用率高；可靠性、易用性、安全性、灵活性、成本控制； 政务云怎么建设以下是政务云建设的一般步骤： 需求分析： 明确政府机构的业务需求、数据规模、安全性要求等。有助于确定政务云的规模和功能。 基础设施规划：根据需求分析的结果，进行政务云基础设施的规划。这包括数据中心建设、服务器、存储设备、网络设备等硬件基础设施的选型和布局。 云平台选择：选择合适的云计算平台，可以是公有云、私有云，或混合云。政务云通常需要考虑数据隐私、安全性和合规性等因素，因此在选择云平台时需要仔细评估其安全性和服务能力。 网络建设： 建设稳定、高速的网络是政务云的关键。确保政务云与各级政府机构、企事业单位的网络连接畅通，提供可靠的服务。 数据安全： 由于政务涉及敏感数据，数据安全是政务云建设的重中之重。采用加密技术、访问控制、身份认证等手段，确保数据在存储和传输过程中的安全性。 服务管理：设计和实施政务云服务的管理体系，包括资源分配、性能监控、故障处理、用户权限管理等。政务云需要提供灵活的服务管理功能，以满足不同部门的需求。 培训和支持： 提供相关人员的培训，使其能够熟练使用政务云服务。同时建立支持和维护机制，确保政务云系统能够稳定运行，并及时响应和解决问题。 合规性和审计：确保政务云建设符合相关法规和合规标准。建立审计机制，对政务云的运行进行定期审查，以确保其合法性和安全性。 迁移和整合：如果政府机构已有一定的信息系统，需要考虑如何将现有系统迁移到政务云上，并确保与政务云平台的整合。 监测和优化：建设完成后，需要进行监测和性能优化，以确保政务云系统的稳定性和效率。 政务云怎么维护、使用、评估政务云的维护、使用和评估是一个持续的过程，需要结合具体的业务需求和技术发展不断进行优化和改进。以下是关于政务云维护、使用和评估的一些建议： 维护：监控和管理： 建立监控系统，对政务云的硬件、网络和服务进行实时监测。及时发现并解决潜在问题，确保政务云的稳定运行。 安全管理： 定期进行安全审查和漏洞扫描，确保政务云系统的安全性。更新安全策略、加密措施，并持续加强用户身份验证和访问控制。 备份和恢复： 定期进行数据备份，并测试数据恢复的可行性。确保在数据丢失或系统故障时能够迅速进行恢复。 性能优化： 定期进行性能评估，优化政务云的资源分配和服务性能。确保政务云能够满足日益增长的需求。 升级和更新： 定期检查并升级政务云平台的软硬件组件，以应对新的技术挑战和提升系统性能。 使用：培训和支持： 提供政务云服务的培训，使使用人员熟悉系统的功能和操作方式。建立及时的技术支持渠道，解答用户的问题和解决技术难题。 合理使用资源： 确保政务云资源的合理分配和使用，避免资源浪费。对于多部门共享的云资源，实施合理的资源隔离和分配机制。 用户权限管理： 建立严格的用户权限管理体系，确保用户只能访问他们需要的信息和服务，降低数据泄露和滥用的风险。 数据治理： 实施有效的数据管理策略，包括数据分类、保密级别划分等。确保政务云上的数据符合相关法规和政策。 灵活扩展： 采用可扩展的架构，以便政务云能够根据需求进行灵活的扩展和缩减。 评估：服务水平协议（SLA）： 定期评估政务云服务提供商是否遵守服务水平协议，以确保政务云提供商履行合同中的承诺。 业务成效评估： 评估政务云对业务效率和服务质量的影响。收集用户反馈，了解系统的优点和改进的空间。 成本效益评估： 定期评估政务云的成本效益。比较使用云服务与传统部署方式的成本，确保政务云的投资带来了实际的经济效益。 合规性和安全评估： 定期进行合规性和安全性评估，确保政务云满足法规和政策要求，并保障系统的安全性。 技术趋势分析： 持续关注新的技术趋势和发展，评估是否有新的技术可以带来更好的性能、安全性和效率。 政务云的维护、使用和评估需要与相关利益相关者密切合作，包括政府机构、IT专业人员、云服务提供商等，以确保政务云系统始终能够适应不断变化的需求和技术环境。 网络规划怎么做，有什么经验？ 网络规划是一项综合性的工作，涉及到网络拓扑、设备选择、带宽规划、安全性、扩展性等多个方面。以下是进行网络规划时需要考虑的一些建议： 需求分析： 确定网络规划的目标和需求。了解组织的业务需求、用户数量、数据流量等信息，以便确定网络设计的基础。 网络拓扑设计： 设计网络拓扑结构，包括局域网（LAN）、广域网（WAN）、子网划分等。选择合适的拓扑结构，考虑组织的业务特点和未来的扩展需求。 设备选择： 根据网络规模和需求选择合适的网络设备，包括交换机、路由器、防火墙等。考虑设备的性能、可靠性、安全性等因素。 IP地址规划： 进行IP地址规划，确保每个设备在网络中都有唯一的标识。考虑IP地址的分配方式、子网划分等因素，以支持未来的扩展。 带宽规划： 根据业务需求和数据流量预测进行带宽规划。确保网络中的带宽能够满足各个业务部门的需求，避免瓶颈出现。 安全性考虑： 强调网络安全性。考虑使用防火墙、入侵检测系统（IDS）、虚拟专用网络（VPN）等技术来保护网络的安全性。进行访问控制和身份验证的规划。 无线网络规划： 如果需要无线网络，进行无线网络规划。确定无线接入点的位置、信道规划、安全性设置等。 网络管理和监控： 设计网络管理和监控系统，确保能够及时发现和解决网络故障。使用网络管理工具和监控系统进行性能监测。 扩展性考虑： 考虑未来的业务扩展，确保网络设计具有良好的扩展性。选择支持易于扩展的设备和技术。 备份和灾难恢复： 设计网络的备份和灾难恢复策略。确保关键数据和系统能够在发生故障或灾难时迅速恢复。 合规性： 确保网络规划符合法规和行业标准，特别是涉及敏感信息的行业，如金融、医疗等。 培训和文档： 对网络管理员和用户提供培训，编写网络文档，确保相关人员了解网络结构和操作方法。 网络规划是一个动态的过程，需要不断调整和优化以适应业务的发展和新的技术趋势。与业务部门、IT团队、安全团队等的紧密协作是成功网络规划的关键。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"政务云","slug":"平台工具/云计算/政务云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%94%BF%E5%8A%A1%E4%BA%91/"}]},{"title":"3.元原生技术","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/云计算/政务云/003.云原生相关技术/","text":"云原生是一种软件开发和部署的方法论，旨在更好地利用云计算环境的弹性、可扩展性和容错性。云原生技术包括一系列工具、框架和最佳实践，用于构建和管理在云环境中运行的应用。以下是一些常见的云原生技术： 容器化技术：Docker： 提供了轻量级、可移植的容器化解决方案，使应用程序及其依赖项能够在不同环境中一致运行。Kubernetes： 开源的容器编排和管理平台，用于自动化应用程序的部署、扩展和操作。Kubernetes 提供了弹性、自愈和自动化的特性。 微服务架构：服务拆分： 将应用程序拆分成小型、独立的服务，每个服务专注于一个具体的业务功能。服务通信： 使用轻量级通信协议（如REST或gRPC）实现服务之间的通信。服务发现和注册： 使用服务注册中心（例如Consul、Etcd）进行服务发现和注册。 持续集成和持续交付（CI/CD）：Jenkins、GitLab CI、CircleCI等： 提供持续集成和持续交付的工具，支持自动化构建、测试和部署。ArgoCD： 用于管理和自动化 Kubernetes 中应用程序的持续交付。 自动化运维：Infrastructure as Code（IaC）： 使用工具如Terraform、Ansible等来描述和管理基础设施，实现可重复性和自动化。自动化监控和日志： 使用工具如Prometheus、Grafana、ELK Stack等来监控应用程序性能和收集日志。 服务网格：Istio、Linkerd等： 提供了在微服务架构中管理服务间通信、负载均衡、故障注入、安全性等方面的功能。 云原生数据库：CockroachDB、TiDB： 支持水平扩展的分布式数据库系统，适用于云原生应用的数据库需求。Amazon DynamoDB、Google Cloud Firestore： 托管的 NoSQL 数据库服务，适用于云环境。Serverless 计算： AWS Lambda、Azure Functions、Google Cloud Functions： 无服务器计算平台，允许开发人员在云中运行代码而无需关心基础设施。 云原生安全：微服务安全： 采用零信任模型、身份验证和授权来保护微服务间的通信。容器安全： 使用容器安全工具和最佳实践，确保容器环境的安全性。 混合云和多云管理：KubeVirt、Anthos： 允许将传统虚拟机工作负载集成到 Kubernetes 集群中，实现混合云环境。管理工具如Rancher、Red Hat Advanced Cluster Management等： 用于在多云环境中管理和监控 Kubernetes 集群。这些技术共同构成了云原生生态系统，支持开发人员构建、部署和管理在云环境中运行的应用程序。","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"政务云","slug":"平台工具/云计算/政务云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%94%BF%E5%8A%A1%E4%BA%91/"}]},{"title":"4.公有云_企业私有云","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/云计算/政务云/004.公有云_企业私有云/","text":"各种业务场景和模型，深入理解业务需求。 对业务上云方案有较丰富的经验.","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"政务云","slug":"平台工具/云计算/政务云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%94%BF%E5%8A%A1%E4%BA%91/"}]},{"title":"5.阿里云_腾讯云","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/云计算/政务云/005.阿里云_腾讯云/","text":"产品、技术、架构.","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"政务云","slug":"平台工具/云计算/政务云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%94%BF%E5%8A%A1%E4%BA%91/"}]},{"title":"10.总结","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/云计算/政务云/010.总结/","text":"","tags":[{"name":"云计算","slug":"云计算","permalink":"https://quano.gitee.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"云计算","slug":"平台工具/云计算","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"政务云","slug":"平台工具/云计算/政务云","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E4%BA%91%E8%AE%A1%E7%AE%97/%E6%94%BF%E5%8A%A1%E4%BA%91/"}]},{"title":"1.wiki中使用数学公式","date":"2024-01-27T14:55:57.000Z","path":"wk/平台工具/工作相关/WikiMe/001.wiki中使用公式/","text":"参考：https://myblackboxrecorder.com/use-math-in-hexo/ 1. 安装MathJax卸载自带的hexo-math以避免冲突 123npm uninstall hexo-math --savenpm install hexo-renderer-mathjax --save 2. 更新MathJax的CDN链接暂时不更新也可以. 打开/node_modules/hexo-renderer-mathjax/mathjax.html， 修改为： 1&lt;script src=&quot;//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 3. 更换默认渲染引擎Hexo默认的渲染引擎hexo-renderer-marked对MathJax的支持很不好，我们修改为kramed引擎 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --sav 4. 更改转义规则编辑：/node_modules/kramed/lib/rules/inline.js 12#escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,#em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 修改为： 12escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 5. 验证两种书写方式, 一种居中，一种在靠左边. 123&#123;% raw%&#125; \\[ (f \\ast g)(t) = \\int_&#123;-\\infty&#125;^&#123;\\infty&#125; f(\\tau) \\cdot g(t - \\tau) \\, d\\tau \\] &#123;% endraw %&#125;$ (f \\ast g)(t) = \\int_&#123;-\\infty&#125;^&#123;\\infty&#125; f(\\tau) \\cdot g(t - \\tau) \\, d\\tau $ \\[ (f \\ast g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau) \\cdot g(t - \\tau) \\, d\\tau \\] $ (f \\ast g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau) \\cdot g(t - \\tau) \\, d\\tau $ 6. 公式写法 LaTeX写法","tags":[{"name":"Wiki","slug":"Wiki","permalink":"https://quano.gitee.io/tags/Wiki/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"WikiMe","slug":"平台工具/工作相关/WikiMe","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/WikiMe/"}]},{"title":"1.CNN","date":"2024-01-27T14:55:57.000Z","path":"wk/算法/002.深度学习/002.常见算法/001.CNN/","text":"概念介绍卷积卷积一种数学运算，是一种积分变换的数学方法；在两个函数之间产生第三个函数的运算. 定义和公式（1）定义设:f(t),g(t)是R1上的两个可积函数，作积分：$ \\int_{-\\infty}^{\\infty} f(\\tau) \\cdot g(t - \\tau) \\, d\\tau $ 随着t的不同取值，这个积分就定义了一个新函数，称为函数 f 与 g 的卷积，记为: ℎ(t) = (f * g) (t) （2）卷积的公式如下： a. 连续形式(连续时间卷积)： 给定两个函数 f(t) 和 g(t)，它们的卷积 ℎ(t) 定义为：​ $ (f \\ast g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau) \\cdot g(t - \\tau) \\, d\\tau $ 这里的积分表示对变量 $ \\tau $ 的积分。 b. 离线形式(离散时间卷积)：对于离散时间的情况，给定两个序列 f[n] 和 g[n]，它们的卷积 (f∗g)[n] 定义为： $ (f \\ast g)[n] = \\sum_{k=-\\infty}^{\\infty} f[k] \\cdot g[n - k] $ 这里的求和表示对变量 k 的求和。 1234解释：对函数 f ， g的卷积 (f∗g)(n) 的卷积 解释：先对g函数进行翻转，相当于在数轴上把g函数从右边褶到左边去，也就是卷积的“卷”的由来。然后再把g函数平移到n，在这个位置对两个函数的对应点相乘，然后相加，这个过程是卷积的“积”的过程。 以上是教科书上 对于卷积数学运算(一种积分变换) 给出的定义. 那究竟为什么这么设计，这么计算，背后的意义是什么？如果一个公式给不出结合实际的直观的通俗的解释，就觉得少了点什么. 意义以上 从计算的方式上对公式进行了解释，从数学上讲无可挑剔，但进一步追问，为什么要先翻转再平移，这么设计有何用意？ 所以有2个需要解释的问题： 卷积这个名词是怎么解释？“卷”是什么意思？“积”又是什么意思？ 卷积背后的意义是什么，该如何解释？ 所谓两个函数的卷积，本质上就是先将一个函数翻转，然后进行滑动叠加。 卷积的“卷”，指的的函数的翻转，从 g(t) 变成 g(-t) 的这个过程. 卷积的“积”，指的是积分/加权求和. 在连续情况下，叠加指的是对两个函数的乘积求积分，在离散情况下就是加权求和，为简单起见就统一称为叠加。整体看来是这么个过程： 翻转——&gt;滑动——&gt;叠加——&gt;滑动——&gt;叠加——&gt;滑动——&gt;叠加…..多次滑动得到的一系列叠加值，构成了卷积函数。 12345卷积公式表示f和g在一个变量上加权平均，其中g经过翻转和平移后与f相乘，并在整个定义域上积分；在这个积分过程中， g(t-T)表示的是 g在t时刻的局部模式，而f(T)表示f在t时刻的局部贡献。本质意义：提供一种有效的方法 来描述和处理 2个函数（序列、信号）之间的交互效应。卷积的定义和性质，使得它成为一种强大的工具，有助于理解和处理 具有复杂相互作用的系统；卷积的局部感知和权重共享的特性，使得它能够输入信号的局部模式。 举例例1：信号分析 输入信号是 f(t) ，是随时间变化的。 系统响应函数是 g(t) 《比如：随时间指数下降的》。 例2：两个函数的卷积 $ f(t) = e^{-t} $g(t)=u(t) 其中，u(t) 是单位阶跃函数，表示在 t=0 处跃升为1。 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport matplotlib.pyplot as plt# 定义函数def f(t): return np.exp(-t)def g(t): return np.piecewise(t, [t &lt; 0, t &gt;= 0], [0, 1])# 连续时间范围t = np.linspace(-1, 5, 1000)# 计算函数值ft = f(t)gt = g(t)# 计算卷积结果convolution_result = np.convolve(ft, gt, mode=&#x27;full&#x27;) * (t[1] - t[0]) # 使用 np.convolve 计算卷积# 绘图plt.figure(figsize=(10, 6))plt.subplot(3, 1, 1)plt.plot(t, ft, label=&#x27;$f(t) = e^&#123;-t&#125;$&#x27;)plt.title(&#x27;Function $f(t)$&#x27;)plt.legend()plt.subplot(3, 1, 2)plt.plot(t, gt, label=&#x27;$g(t) = u(t)$&#x27;)plt.title(&#x27;Function $g(t)$ (Unit Step)&#x27;)plt.legend()# 仅绘制有效范围内的卷积结果plt.subplot(3, 1, 3)plt.plot(t, convolution_result[:len(t)], label=&#x27;$f * g$&#x27;)plt.title(&#x27;Convolution Result: $(f * g)(t) = 1 - e^&#123;-t&#125;$&#x27;)plt.legend()plt.tight_layout()plt.show() 图像处理在图像处理中，卷积是一种常用的操作，用于处理图像的特征提取、滤波和边缘检测等任务. 理解图像处理中的卷积可以通过以下几个关键点： 局部特征提取、滤波操作、权重共享、下采样、卷积神经网络（CNN） 图像一般可以表示为矩阵形式。对图像的处理函数（如平滑，或者边缘提取），也可以用一个g矩阵来表示。 我们在处理平面空间的问题，已经是二维函数了 给定图像 I 和卷积核 K，卷积操作的结果图像 I_{\\text{conv}} 的每个像素可以通过以下公式计算： $I{\\text{conv}}(x, y) = \\sum{i=0}^{h-1} \\sum_{j=0}^{w-1} I(x - i, y - j) \\cdot K(i, j)$ 其中： $ I_{\\text{conv}}(x, y) $ 是卷积操作后得到的图像的像素值. I(x - i, y - j) 是原始图像的像素值，i 和 j 是卷积核的坐标. K(i,j) 是卷积核的权重. 123这个公式表示，在卷积操作中，卷积核在图像上滑动，每个位置都与图像的局部区域进行加权相乘并求和，得到卷积后的像素值。卷积核的选择和权重决定了卷积操作的具体效果，例如边缘检测、模糊等。需要注意的是，这是一个简化的二维卷积公式。在实际应用中，可能还涉及到通道（颜色通道）的处理，以及不同类型的卷积操作（如反卷积、分离卷积等）。 CNN一种包含卷积操作的 深度神经网络(或者说是一类深度学习神经网络). 专门用于处理和分析具有网格状结构的数据，CNN的设计灵感来自于生物学中对动物视觉系统的理解，通过卷积层和池化层等结构实现对图像特征的提取。 定义和由来CNN的发展历程是深度学习研究的一个关键里程碑. （1）对于CNN的定义： 一种包含卷积操作的 深度神经网络(或者说是一类深度学习神经网络). 因此有几个特点：卷积操作、深度神经网络、 另外，CNN的主要特点包括： 卷积层、池化层、权重共享、多层网络结构、适用于图像处理任务. 核心思想： 通过使用卷积层（Convolutional Layer）和池化层（Pooling Layer）对输入数据进行局部感知和共享权重，从而实现对图像等结构化数据的特征提取和高效处理。 CNN通常包含多个卷积层、池化层和全连接层。 （2）由来Yann LeCun等人于1998年提出的卷积神经网络结构，用于手写数字的识别。卷积层的出现在LeNet-5模型，用于手写数字识别。LeNet-5是一个经典的卷积神经网络.包括 卷积层、池化层和全连接层。 其中卷积层和池化层的引入使其在处理图像数据上具有优势。 深度学习的复兴： 2012年AlexNet的成功标志着深度学习的复兴。随后，研究者们陆续提出了一系列基于CNN的模型，包括VGG、GoogLeNet、ResNet等，这些模型在图像分类、目标检测、语义分割等领域取得了显著的成果。 卷积层（Convolutional Layer）卷积层是CNN的核心组件，通过卷积操作从输入数据中提取局部特征。卷积操作使用卷积核（filter）在输入数据上滑动，计算局部区域的加权和。 池化层（Pooling Layer）池化层用于减小特征图的空间尺寸，降低计算复杂度，并增强模型对平移和旋转的不变性。常见的池化操作包括最大池化和平均池化。 （1）最大池化对于每个池化窗口（通常是2x2或3x3的小区域）中的值，选择其中的最大值作为池化后的值。这个过程可以通过以下公式表示： $ \\text{Max Pooling}(x, i, j) = \\max{p,q} x{(i \\times \\text{stride} + p),(j \\times \\text{stride} + q)} $ （2）平均池化对于每个池化窗口中的值，计算其平均值作为池化后的值。 $ \\text{Average Pooling}(x, i, j) = \\frac{1}{\\text{pool_size}} \\sum{p,q} x{(i \\times \\text{stride} + p),(j \\times \\text{stride} + q)} $ 激活函数（Activation Function）在卷积层之后，通常会应用激活函数，如ReLU（Rectified Linear Unit），用于引入非线性特性，增强模型的表达能力。 全连接层（Fully Connected Layer）通常会有全连接层用于将高级特征映射到输出类别。在图像分类任务中，全连接层用于输出各个类别的概率分布 除了映射作用，还可以通过全连接引入非线性映射，增加模型的表达能力，使其能够适应更复杂的数据分布。 LeNet-5一种经典的 CNN架构模型，是CNN的重要里程碑。 （1）三层卷积出于对任务的需求、计算资源的考虑。（通过增加卷积层数，模型可以学习更多复杂的特征，但也会增加计算负担。） （2）激活函数每一层都使用了 Sigmoid 激活函数。这是在网络设计初期常用的一种激活函数。 引入非线性性，允许网络学习更复杂的特征；捕捉输入数据的复杂关系。 在当时的研究时期，Sigmoid 激活函数是常用的选择，但在后来的深度学习研究中，ReLU（Rectified Linear Unit）等激活函数逐渐成为更为流行的选择，因为它们在训练中具有更好的性能。 图形处理核心概念上文介绍了CNN(卷积神经网络相关概念和实现)。那CNN实质是一种图像处理算法。 不管是CNN还是其他算法，在图像处理中，都涉及到一些核心概念和操作，如：局部特征提取、滤波操作、权重共享、下采样 下面具体介绍下这些概念。 局部特征提取：从原始数据中提取有意义、具有代表性的信息的过程。比如卷积操作，从原始图像中提取为特征图(卷积的结果)。卷积操作常用于提取图像中的局部特征，例如边缘、纹理等。 滤波操作：通过卷积运算在信号或图像上应用滤波器的过程。滤波的目的是通过去除或增强信号中的特定频率成分，达到平滑、降噪、边缘检测等目的。因此，滤波操作通常涉及卷积操作，可以看作卷积的一种应用。 区别：滤波操作和特征提取在某种程度上有交叉，但它们的重点和目的略有不同。 可以理解为：滤波操作指 123滤波操作目的主要用于对信号或图像进行平滑、降噪、锐化等处理。特征提取目的主要从原始数据中提取具有代表性和有用信息的特征，以便更好地表示数据的本质。滤波操作有时也能起到特征提取的作用，但它们的设计和目标通常更倾向于信号处理的需求。相反，特征提取更注重从数据中提炼有意义的信息，使得后续的任务（如分类、检测）能够更好地利用这些信息。 todo: 滤波操作、卷积操作、特征提取 三者概念的关系和区别. 滤波操作就是卷积操作，通过卷积实现 图像的平滑、降噪、锐化等处理 卷积操作还可以用于特征提取 滤波和特征提取是相关但不完全相同的概念。（相关在于都是通过卷积操作实现、都应用于信号或图像处理、都是属于对数据的局部感知） 只是目的不同： 滤波的目标通常是改变输入数据的频谱特性，实现平滑、去噪等效果；而特征提取的目标是从输入数据中提取有用的信息，例如图像中的纹理、形状等。 其他相关概念：填充、步长、通道数 （1）填充（ Padding ）指在输入数据的边缘添加一定数量的像素，使得输出数据的尺寸能够与输入数据相匹配。也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常用 0 或者复制边界像素来进行填充。（2）步长（Stride）是指卷积核在每一次卷积操作中滑动的距离。步长的大小可以影响输出数据的大小，也可以影响特征提取能力和计算复杂度。当步长增大时，输出数据的尺寸会减小，特征提取能力会变弱，但计算速度会加快。（3）通道数（Channel）也称为深度或特征图数量，是指卷积神经网络中每一层输出的特征图数量。通道数的大小直接影响了卷积神经网络的特征提取能力和计算复杂度。通过增加通道数，可以增强卷积神经网络的特征提取能力，但也会增加计算复杂度。 多通道卷积. 总结 学习的过程：系统架构，涉及的概念，每个概念的目的、关系。 这是一个学习的过程. 其中相关概念的目的，可以通过追溯历史、重要里程碑去发现. 还可以通过一些工具辅助加深理解，比如python实现具体的计算逻辑，展示具体的数学计算图形. 资料：如何通俗易懂地解释卷积卷积神经网络经典回顾之LeNet-5","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"002.深度学习","slug":"算法/002-深度学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"002.常见算法","slug":"算法/002-深度学习/002-常见算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/002-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"}]},{"title":"1.Yolo","date":"2024-01-27T14:55:57.000Z","path":"wk/算法/003.图像识别/目标检测/003.Yolo/","text":"定义YOLO是一种目标检测模型。(you only look once)只需要浏览一次就可以识别出图中的物体的类别和位置 目标检测：计算机视觉中比较简单的一个任务；用来在一张图篇中找到某些特定的物体。 识别物体的种类、标出物体的位置. 背景因为只需要看一次，YOLO被称为Region-free方法，相比于Region-based方法，YOLO不需要提前找到可能存在目标的Region。 典型的Region-base方法的流程是： 12先通过计算机图形学（或者深度学习）的方法，对图片进行分析，找出若干个可能存在物体的区域。将这些区域裁剪下来，放入一个图片分类器中，由分类器分类。 也被称为单阶段（1-stage）模型 和 两阶段（2-stage）模型. 发展历史YOLO之前的世界: R-CNN什么的. 最初的CNN：通过滑动窗口方式识别一个个物体。( 太慢了，步长越小，处理越慢，浪费时间 ) R-CNN：用滑窗法可能最后得到了几十万个窗口，如果提前扫描一下图片，得到2000个左右的Region，大大节省了时间.管这个叫做Region Proposal，并且提出了一个叫做Selective Search的算法。 但是R-CNN被YOLO打脸了，YOLO说，我更快。 YOLOv1（2016年5月）：第一个YOLO版本、提出一种端到端的目标检测方法、将图像划分为网格、每个网格负责预测多个边界框和对应的类别。「YOLOv1相对较简单，但在实时性能上表现出色」 YOLOv2 / YOLO9000（2016年12月）：改进，使用Anchor Boxes来优化边界框的预测、使用Darknet-19网络结构、YOLO9000扩展了模型的类别，使其能够检测超过9000个类别。 YOLOv3（2018年4月）：重要版本，引入了关键的改进（使用多尺度检测、使用更深的Darknet-53网络结构、使用多层级特征融合）。准确性和速度之间取得了更好的平衡。 YOLOv4（2020年4月）：CSPDarknet53网络结构、YOLOv3的PPM（Path Aggregation Network）、SAM（Spatial Attention Module）。「在目标检测任务中取得了更好的性能」 YOLOv5（2020年6月）：采用轻量级网络结构、新的训练策略「可以在更快的速度下实现高精度目标检测」 特点单次前向传递： YOLO采用单一的神经网络模型，通过一次前向传递即可同时预测图像中所有目标的边界框和类别。 网格划分：将图像划分成网格，并在每个网格上进行目标检测。每个网格负责预测包含在该网格中的目标。 边界框预测： 在每个网格中，通过卷积层预测多个边界框的坐标信息（边界框的左上角和右下角坐标）。 优缺点：优势在于其速度和简洁性；相对于一些两阶段的目标检测算法，可能在检测小目标和处理密集场景时表现稍逊。 目的目标是实现高效而准确的目标检测，尤其在实时应用中取得了显著的成果。 模型架构YOLOv1由Joseph Redmon等人在2016年提出的目标检测算法。 （1）背景 在YOLOv1提出之前，目标检测的实现方法往往较为复杂，需要通过分类的方法来重写回归分支，以实现检测，并且需要复杂的后处理来得到最终的检测结果。这导致检测过程耗时长且复杂。 为了改进这一问题，Joseph Redmon等人提出了YOLOv1，将目标检测任务定义为单个回归问题，直接从输入图像上得到目标的位置和类别，大大简化了检测过程。 此外，Joseph Redmon等人还将YOLOv1设计为一个端到端的算法，使得整个检测过程更加高效和简洁。这种新的目标检测算法在提出后受到了广泛的关注和应用，为计算机视觉领域的发展做出了重要贡献。 Joseph Redmon因提出YOLO系列算法而被称为“YOLO之父”。 不过，由于后期美国军方曾将YOLO智能识别技术用于军事武器开发，Joseph Redmon不希望自己的成果被用在军事上，因此他后来停止了计算机视觉方面的研究和工作。尽管如此，他之前提出的YOLO系列算法仍然在计算机视觉领域发挥着重要作用。 1Joseph Redmon提出YOLOv1时的身份背景，他当时是在华盛顿大学读博士，并在Ali Farhadi教授的指导下进行研究. 因此，他是在学术环境中，具体来说是在华盛顿大学的研究团队中，提出并发表了YOLOv1算法。 （2）模型架构(论文思想) 见论文精读. 算法流程 网络结构 预训练分类网络 训练检测网络 损失函数（L2 Loss） （3）YOLOv1的缺陷 资料论文精读：《You Only Look Once: Unified, Real-Time Object Detection》","tags":[{"name":"图像识别","slug":"图像识别","permalink":"https://quano.gitee.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"目标检测","slug":"目标检测","permalink":"https://quano.gitee.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"Yolo","slug":"Yolo","permalink":"https://quano.gitee.io/tags/Yolo/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"目标检测","slug":"算法/003-图像识别/目标检测","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"1.CNN","date":"2024-01-27T14:55:57.000Z","path":"wk/算法/003.图像识别/目标检测/004.yolo项目总结/","text":"","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"目标检测","slug":"算法/003-图像识别/目标检测","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"fasttext分类工具","date":"2022-11-14T14:55:57.000Z","path":"wk/算法/004.NLP/分类-fasttext/001.fasttext分类工具/","text":"训练12fasttext supervised -wordNgrams 2 -minn 3 -maxn 6 -dim 100 -input %s -output %o例：fasttext supervised -wordNgrams 3 -minn 3 -maxn 6 -dim 100 -input train_data -output contact_model 测试1fasttext test contact_model.bin test.data 数据格式12345# 训练数据我们 加个QQ , 方便 联系 __label__contact# 测试数据__label__contact 能 交换 一下 好友 吗","tags":[{"name":"NLP","slug":"NLP","permalink":"https://quano.gitee.io/tags/NLP/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"004.NLP","slug":"算法/004-NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/004-NLP/"},{"name":"分类-fasttext","slug":"算法/004-NLP/分类-fasttext","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/004-NLP/%E5%88%86%E7%B1%BB-fasttext/"}]},{"title":"有限状态机","date":"2022-07-29T14:55:57.000Z","path":"wk/算法/基础算法/状态机/001.有限状态机/","text":"有限状态及(FA). DFA NFA DFA/NFA区别与转换 DFA化简 DFA/NFA区别与转换DFA 是NFA的一个特例. DFA与NFA的区别在于，NFA的状态转换过程中可以有空串 所以NFA的不确定表现我们可以概括为： 多值映射 带空转移 因此在很多时候，我们都需要将NFA转换为DFA。 语言转化为正规表达式RE RE转化为NFA NFA的确定化&amp;DFA的最小化（状态转换图 状态转移矩阵）","tags":[{"name":"FA","slug":"FA","permalink":"https://quano.gitee.io/tags/FA/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"算法/基础算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"状态机","slug":"算法/基础算法/状态机","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%8A%B6%E6%80%81%E6%9C%BA/"}]},{"title":"OCR概述和认识","date":"2022-03-13T14:55:57.000Z","path":"wk/算法/003.图像识别/OCR/000.OCR概述和认识/","text":"什么是OCR文字识别, 计算机视觉重要方向之一. 自然场景文字识别: STR 文档场景文字识别: DAR 行业应用： 卡证票据信息抽取录入, 工厂自动化、政府工作医院等、在线教育. OCR面临的难点和挑战 - 文字表现多样性1.自然场景的文字表现变化很大 透视变换 尺度太小 文字弯曲 背景干扰 字体多变 都中语言 拍摄模糊 光照不足2. 文档场景的文字密集，需要结构化输出 表格 手写 褶皱 盖章 3. 垂类众多，数据不足 OCR商业方案很难解决OCR垂类场景的所有问题 需要一个OCR套件，打通落地过程中每个环境，包括 数据生产、算法选型和训练,以及模型预测部署. 药品铝塑日期识别、蒙语识别、标牌编号识别 4. 预测效率要求高 在cpu上可以运行，节约资源 在端侧运行，安全和方便部署 效率和效果的折中. 模型大小、推理速度 因此： 一个OCR的工具库是很有必要的。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"OCR","slug":"算法/003-图像识别/OCR","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/OCR/"}]},{"title":"图可视化","date":"2022-03-09T15:55:57.000Z","path":"wk/算法/001.机器学习/003.知识图谱/存储/nebula/003.图可视化/","text":"图可视化","tags":[{"name":"Graph","slug":"Graph","permalink":"https://quano.gitee.io/tags/Graph/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"003.知识图谱","slug":"算法/001-机器学习/003-知识图谱","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"存储","slug":"算法/001-机器学习/003-知识图谱/存储","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%98%E5%82%A8/"},{"name":"nebula","slug":"算法/001-机器学习/003-知识图谱/存储/nebula","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%98%E5%82%A8/nebula/"}]},{"title":"003.Netty线程模型","date":"2022-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/003.Netty线程模型/","text":"背景1. Java线程模型演进单线程、多线程、线程池. 2. Reactor模型无论是c++还是Java、nodejs 编写的网络框架, 大多数都是基于Reactor模型进行设计和开发. Reactor模式基于事件驱动，特别适合处理海量的 IO事件. (1) Reactor单线程模型.由于reactor模式是 异步非阻塞IO, 所有的IO操作都不会导致阻塞. 理论上: 一个线程可以处理所有 IO相关的操作. 从架构层面看，一个 NIO线程 确实可以完成其承担的职责. 问题： 一个NIO线程同时处理成百上前的链路，性能上无法支撑。 瓶颈在于 海量消息的编码、解码、读取和发送（即便是NIO线程CPU负载100%）. NIO线程负载过重之后，处理速度变慢，导致大量客户端连接超时。重发，更加重了NIO线程的负载，最终会导致大量消息积压和处理超时； 可靠性问题： 一旦NIO线程意外跑飞，或者进入死循环，系统通信模块直接不可用，直接故障。 (2) Reactor多线程模型一组NIO线程处理IO操作【NIO操作指的是什么? read\\write?】. 一个专门的NIO线程-Acceptor线程用于监听服务端，接受客户端的TCP连接请求 网络IO操作 - （读、写 等） 由一个NIO线程池负责【线程池可采用标准的JDK线程池实现，包含 一个任务队列和N个可用的线程， 这些NIO线程负责 消息的读取、解码、编码、发送】 一个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止并发操作问题. 重点： 大多数场景下， 此模型可以满足性能要求。 但是，极个别特殊场景， 一个Acceptor（NIO）线程 负责监听和处理所有的客户端连接可能存在性能问题。 例如： 并发百万客户端连接，或者服务端需要对客户端进行安全认证， 单独一个Acceptor线程 可能存在性能不足问题。 这时候，引入新的方式：Reactor 主从多线程模型。 Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的 SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。 解决了 1 个服务端监听线程无法有效处理所有客户端连接的性能不足问题。 12345它的工作流程总结如下：从主线程池中随机选择一个 Reactor 线程作为 Acceptor 线程，用于绑定监听端口，接收客户端连接；Acceptor 线程接收客户端连接请求之后创建新的 SocketChannel，将其注册到主线程池的其它 Reactor 线程上，由其负责接入认证、IP 黑白名单过滤、握手等操作；步骤 2 完成之后，业务层的链路正式建立，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上摘除，重新注册到 Sub 线程池的线程上，用于处理 I/O 的读写操作。 Netty 线程模型bossGroup 线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，如果系统只有一个服务端端口需要监听，则建议 bossGroup 线程组线程数设置为 1。 workerGroup 是真正负责 I/O 读写操作的线程组，通过 ServerBootstrap 的 group 方法进行设置，用于后续的 Channel 绑定。 IO操作有哪些。 OP_READ OP_WRITE OP_CONNECT OP_ACCEPT Reactor是针对这些 事件 分发到不同的线程来进行处理. 问题： 作为服务端 Acceptor 线程，负责处理客户端的请求接入 boss线程和work线程的代码是一致的。 怎么区分？ 是走的逻辑不同？？ NioEventLoop设计原理 串行化设计避免线程竞争：串行执行Handler链. 定时任务与时间轮算法 聚焦而不是膨胀：只负责提供和管理NIO线程 1. 串行化设计避免线程竞争2. 定时任务与时间轮算法Netty中，很多功能依赖定时任务，比较典型的有2种： 客户端连接超时控制； 链路空闲检测 常见的设计理念是在 NioEventLoop中聚合JDK的 定时任务线程池 ScheduledExecutorService. 从性能角度看不是最优：原因： 线程上下文切换，打破了串行化设计理念 存在多线程并发问题. 定时Task和IO线程NioEventLoop可能同时访问并修改一份数据 Jdk的sc..本身存在性能优化空间. 最早面临上述问题的是操作系统和协议栈，例如 TCP 协议栈，其可靠传输依赖超时重传机制，因此每个通过 TCP 传输的 packet 都需要一个 timer 来调度 timeout 事件。这类超时可能是海量的，如果为每个超时都创建一个定时器，从性能和资源消耗角度看都是不合理的。 时间轮算法调度： 根据 George Varghese 和 Tony Lauck 1996 年的论文《Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility》提出了一种定时轮的方式来管理和维护大量的 timer 调度。Netty 的定时任务调度就是基于时间轮算法调度，下面我们一起来看下 Netty 的实现。 Netty 系列之 Netty 线程模型","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"003.Netty线程模型和其他WebServer的比较","date":"2022-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/004.Netty线程模型和其他WebServer的比较/","text":"大家都知晓的是 Netty比其他Server相对性能好，可定制化高. 那具体区别在哪里。 详细探讨下,上一篇详细讲了Netty的线程模型. 一、Netty线程模型.一个boss线程、32(核数2倍)个work线程. 下面看看其他WebSever的线程模型. 二、webmvc常见的 spring-webmvc. (用于 后端API、graphqlServer) 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 1. tomcat线程NioEndpoint组件. Tomcat的NioEndpoint实现了I/O多路复用模型。 创建一个Selector, 在其上注册 事件，等待感兴趣的事件发生. 发生后（比如可读），就创建一个新的线程从Channel读数据. NioEndpoint包含LimitLatch、Acceptor、Poller、SocketProcessor和Executor共5个组件。 LimitLatch连接控制器，控制最大连接数，NIO模式下默认8192. AcceptorAcceptor实现了Runnable接口，因此可以跑在单独线程里，在死循环里调用accept接受新连接，一旦有新连接请求到达，accept方法返回一个Channel对象，接着把Channel对象交给Poller去处理. Poller本质上是一个Selector,跑在单独线程里。 Poller在内部维护一个Channel数组，它在一个死循环里不断检测Channel的数据就绪状态，一旦有Channel可读，就生成一个SocketProcessor任务对象扔给Executor去处理。 Tomcat的高并发设计NioEndpoint完成的三件事： 接受连接、检测IO事件和处理请求，关键是把这三件事情分布定制线程数处理： 专门的线程组去跑Acceptor，并且Acceptor的个数可以配置 专门的线程组去跑Poller，Poller的个数也可以配置 具体任务的执行也由专门的线程池来处理，也可以配置线程池的大小 Tomcat线程模型—全网最清晰的讲解 2. 实际线程情况下面是实际的线程情况： Catalina-utility(2个)[TIMED_WAITING][ at sun.misc.Unsafe.park(Native Method)]container-0(1个)[TIMED_WAITING][at java.lang.Thread.sleep(Native Method)]Live Reload Server(1)[RUNNABLE][at java.net.PlainSocketImpl.socketAccept(Native Method)]http-nio-8869-BlockPoller(1)[RUNNABLE][at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)]http-nio-8869-ClientPoller(1)[RUNNABLE][at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)]http-nio-8869-Acceptor(1)[RUNNABLE][at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)]http-nio-8869-exec-213(10)[WAITING][at sun.misc.Unsafe.park(Native Method)] 解释： 3. tomcat线程和netty线程对比【重点】三、webflux1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webflux&lt;/artifactId&gt;&lt;/dependency&gt; 四、dubbo五、thrift","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"向量点乘与叉乘的概念及几何意义","date":"2022-01-12T15:55:57.000Z","path":"wk/算法/001.机器学习/004.数学知识/向量点乘与叉乘的概念及几何意义/","text":"向量点乘与叉乘的概念及几何意义 点乘的结果是点积，又称数量积或标量积 代数角度： a.b = x1x2 + y1y2 + z1z2 几何角度：点积 是两个向量的长度 与它们夹角余弦的积. 代表 a 早b 方向上的投影 与 b 的长度的乘积. 反映了两个向量的相似度, 结果越大越相似. 基于点积可以判断这两个向量是否是同一方向，是否正交垂直，具体对应关系为： 点积大于0, 则方向相同, 夹角在 0 ~ 90. 点积等于0, 则正交, 相互垂直 点击小于0, 则方向基本相反, 夹角在90到180之间. 点乘代数定义 推导几何定义：（常用来求向量夹角）","tags":[{"name":"向量","slug":"向量","permalink":"https://quano.gitee.io/tags/%E5%90%91%E9%87%8F/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"004.数学知识","slug":"算法/001-机器学习/004-数学知识","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/004-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}]},{"title":"001.Gpu环境相关-nvidia-docker安装测试","date":"2021-10-28T14:55:57.000Z","path":"wk/算法/001.机器学习/001.工作环境/001.Gpu环境相关-nvidia-docker安装测试/","text":"","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"001.工作环境","slug":"算法/001-机器学习/001-工作环境","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001-%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"}]},{"title":"001.jupyterlab","date":"2021-10-28T14:55:57.000Z","path":"wk/算法/001.机器学习/001.工作环境/002.jupyterlab安装/","text":"https://www.cnblogs.com/realwuxiong/p/14139194.html 目标： 创建一个 jupyterlab. 包含以下环境 支持gpu环境. jupyterlab 支持python java语言. 实现步骤如下： 使用基础镜像nvidia/cuda:11.4.1-base-ubuntu18.04 背景： 在win10环境下， cuda版本是 11.4 【NVIDIA-SMI 470.73 Driver Version: 472.12 CUDA Version: 11.4】 基于基础镜像 创建临时环境(用于镜像创建) 1nvidia-docker run -it --rm -p 3333:8888 nvidia/cuda:11.4.1-base-ubuntu18.04 /bin/sh 环境搭建 123456789101112131415apt update apt install wget #获取anaconda apt install bzip2 #安装anaconda wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py37_4.8.3-Linux-x86_64.sh#默认保存在/路径下chmod +x Miniconda3-py37_4.8.3-Linux-x86_64.sh./Miniconda3-py37_4.8.3-Linux-x86_64.sh -b #不提示直接默认安装 python3.6 export PATH=/root/miniconda3/bin:$PATH #指定路径，需要在dockerfile 中定义，在容器内定义后commit 容器后会失效# cuda版本选择 10.1 对应tensorflow 版本2.1.0pip install tensorflow-gpu==2.1.0 -i https://pypi.tuna.tsinghua.edu.cn/simple pip install jupyterlab #pip install jupyterlab https://jupyterlab.readthedocs.io/en/stable/getting_started/installation.htmlpip install msgpack #安装以上后会报缺少此包 tensorflow 对应的cuda版本 jupyterlab&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 1cd /mnt/d/jupyter/quanoc &amp;&amp; nohup jupyter-lab --ip 0.0.0.0 --no-browser --allow-root &gt; jp_nohup.out 2&gt;&amp;1 &amp; 81ed7b8036ba7b3a13b367a31cb1107a2edd3301","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"001.工作环境","slug":"算法/001-机器学习/001-工作环境","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001-%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"}]},{"title":"2. Nvidia-docker环境安装及测试","date":"2021-10-28T14:55:57.000Z","path":"wk/算法/002.深度学习/001.环境准备/001.nvidia-docker/","text":"验证环境1docker run --gpus=all --rm nvidia/cuda:11.0-base nvidia-smi docker notebook 搭建.1234567mkdir -p /mnt/d/jupyter/quanocmkdir -p /mnt/d/jupyter/quanoc/.jupyterchmod 777 -R /mnt/d/jupyter/quanocdocker run --name vk-jupyter --restart=always -d -p 8888:8888 -v /mnt/d/jupyter/quanoc:/home/jovyan jupyter/base-notebook:notebook-5.7.8","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"002.深度学习","slug":"算法/002-深度学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"001.环境准备","slug":"算法/002-深度学习/001-环境准备","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/001-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"}]},{"title":"1. 深度学习环境相关认识","date":"2021-10-28T14:55:57.000Z","path":"wk/算法/002.深度学习/001.环境准备/001.深度学习环境相关认识/","text":"首先总体上介绍下 深度学习相关的环境概念. 以便于 环境的认识和准备. nvidia GPU cuda(cuda Toolkit[11.4]、cudnn) nvidia-docker nvidia是一家公司. NVIDIA是GPU(图形处理器)的发明者，也是人工智能计算的引领者。（创建了世界上最大的游戏平台、世界上最快的超级计算机.） 自动驾驶汽车、智能机器、物联网 GPU图形处理器, 是nvidia发明的 cudaCUDA是 nvidia推出的用于自家GPU的并行计算框架. 在CUDA架构下，显示芯片执行时的最小单位是thread. 数个thread可以组成一个block. 一个block中的thread能存取同一块共享的内存, 而且可以快速进行同步的动作. cuDNNcuda deep Neural Network library 是nvidia打造的针对深度神经网络的加速库， 是一个用于深层神经网络的GPU加速器. 如果要用GPU训练模型，cuDNN不是必须的，但是一般会采用这个激加速库. CUDA on Windows Subsystem for linux[WSL]","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"002.深度学习","slug":"算法/002-深度学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"001.环境准备","slug":"算法/002-深度学习/001-环境准备","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/001-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"}]},{"title":"001.tensorflow认识.md","date":"2021-10-28T14:55:57.000Z","path":"wk/算法/002.深度学习/003.框架工具/001.tensorflow认识/","text":"TensorFlow是一个开源的机器学习框架。 提供了一个强大的工具集，用于构建和训练各种机器学习模型，包括神经网络。 TensorFlow的核心是计算图（Computational Graph）和张量（Tensor）的概念，它允许用户在高度灵活和可扩展的环境中定义和运行各种机器学习任务。 一、tensorflow学习tensorflow官网：轻松创建机器学习模型 借助 TensorFlow，初学者和专家可以轻松创建适用于桌面、移动、网络和云端环境的机器学习模型。请参阅以下几部分，了解如何开始使用。 关键词：TensorFlow 基础知识、创建机器学习项目、TensorFlow.js 、部署现有模型、移动设备和边缘设备、针对生产 移动设备和边缘设备：使用 TensorFlow Lite 在 Android、iOS、Edge TPU 和 Raspberry Pi 等移动设备和嵌入式设备上进行推断针对生产：使用 TFX 部署可用于生产环境的机器学习流水线，以用于训练和推断。 主要特点和功能（1）计算图TensorFlow使用计算图来描述机器学习模型。计算图是一种图形表示，其中节点表示操作，边表示操作之间的数据流。这种图形模型使得 TensorFlow 能够高效地优化计算，分布式执行，以及方便地在不同平台上运行。 （2）张量张量的概念是由 Google Brain 团队在开发 TensorFlow 框架时引入的术语”张量”最早由德国数学家奥古斯特·费迪南德·莫比乌斯（August Ferdinand Möbius）在19世纪中期引入 然而，在机器学习和深度学习的上下文中，张量的概念经常被引用，它在这里更多地是指多维数组或矩阵的概念。 张量是 TensorFlow 中的核心数据结构，它是多维数组，类似于 NumPy 中的数组。张量在计算图中流动，传递数据和梯度。 123张量是一种广义的矩阵，它可以是零阶（标量）、一阶（向量）、二阶（矩阵）等。在深度学习框架中，例如 TensorFlow 和 PyTorch 中，张量是基本的数据结构，用于表示和处理多维数据。具体到 TensorFlow，**张量的概念是由 Google Brain 团队在开发 TensorFlow 框架时引入的**。TensorFlow的名字中的 &quot;Tensor&quot; 指的就是这个多维数组的概念。TensorFlow的计算图模型使用张量作为数据的基本单位，计算图中的节点执行操作，边表示张量之间的流动关系。 在线性代数中，术语 “向量” 通常指一维数组，即一个包含有序数值的集合。在这个上下文中，”向量” 与 “一维数组” 的概念是等价 然而，在机器学习和深度学习的上下文中，术语 “向量” 的使用可以更为广泛，不仅指一维数组，还可能指包含多个元素的任何数组，即多维数组。在这个语境下，一维数组被视为一种特殊情况，即长度为 1 的向量。 一维数组（一维向量）、二维数组（二维向量）、多维数组（多维向量）。 在深度学习中，尤其是使用框架如 TensorFlow 或 PyTorch 时，通常将这些多维数组统称为 “张量”。因此，术语 “向量” 在这个上下文中可能包括一维、二维，乃至更高维度的数组。 （3）灵活性TensorFlow提供了灵活性，允许用户在不同的层次上构建模型，从高级的 Keras API 到低级的 TensorFlow 操作 (4) 自动求导TensorFlow提供了自动求导的功能，简化了梯度计算的过程，这对于训练神经网络是至关重要的。 （5）跨平台支持TensorFlow支持在多种硬件和平台上运行，包括 CPU、GPU 和 TPU（Tensor Processing Unit）等。 （6）大型社区和生态系统 docekr镜像相关(使用)1. tensorflow/tensorflow:latest-gpu命令行模型调试1nvidia-docker run -it tensorflow/tensorflow:latest-gpu 2. tensorflow:latest-gpu-jupyter可用于开发.12345678nvidia-docker run -it -p 8888:8888 tensorflow/tensorflow:latest-gpu-jupyternvidia-docker run --name vk-jupyter -e JUPYTER_ENABLE_LAB=yes --restart=always -d -p 8888:8888 -v /mnt/d/jupyter/quanoc:/home/quanoc tensorflow/tensorflow:latest-gpunvidia-docker run --name vk-jupyter -e JUPYTER_ENABLE_LAB=yes -d -p 8888:8888 -v /mnt/d/jupyter/quanoc:/home/quanoc tensorflow/tensorflow:latest-gpu","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"002.深度学习","slug":"算法/002-深度学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"003.框架工具","slug":"算法/002-深度学习/003-框架工具","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/002-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/003-%E6%A1%86%E6%9E%B6%E5%B7%A5%E5%85%B7/"}]},{"title":"查看java对象大小","date":"2021-09-30T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/JVM/001.Java对象/","text":"查看java对象大小.ObjectSizeCalculator.getObjectSize(obj) https://www.cnblogs.com/ulysses-you/p/10060463.html","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"JVM","slug":"平台工具/程序语言/Java/JVM","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/JVM/"}]},{"title":"nvidia-docker、cuda认识","date":"2021-09-06T05:13:34.000Z","path":"wk/算法/001.机器学习/001.工作环境/win环境/002.nvidia-docker、cuda认识/","text":"docker和nvidia-dockerdocker 容器级别的虚拟化、不是基于硬件虚拟化. 和宿主机共享操作系统内核和资源 轻量 方便的构建&amp;部署应用程序 采用虚拟化控制","tags":[{"name":"nvidia-docker","slug":"nvidia-docker","permalink":"https://quano.gitee.io/tags/nvidia-docker/"},{"name":"cuda","slug":"cuda","permalink":"https://quano.gitee.io/tags/cuda/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"001.工作环境","slug":"算法/001-机器学习/001-工作环境","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001-%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"},{"name":"win环境","slug":"算法/001-机器学习/001-工作环境/win环境","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001-%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/win%E7%8E%AF%E5%A2%83/"}]},{"title":"什么是模型","date":"2021-09-02T14:55:57.000Z","path":"wk/算法/001.机器学习/模型/什么是模型/","text":"机器学习中的模型到底是指什么？ 生活中有些场景中的逻辑结构可以叫做模型. 但在计算机领域 知识领域的模型 我们认为是 模型指机器学习中的模型。 机器学习分为有监督学习、无监督学习。 我们把讨论的范围限定在最常见的有监督学习框架中。 机器学习模型，本质上是一个函数，其作用是实现从一个样本x到样本的标记值Y的映射，即f(x) -&gt; Y. 当然这样说太笼统了，事实上机器学习模型需要在给定样本集合 以及其对应标签 的情况下，用假设已知的函数形式 , 尽可能拟合客观存在的映射函数 ，并且保证 在未知同分布样本上具有尽可能相近的拟合能力。在上述描述里，假设已知的函数形式其实是所有有监督模型的前提基础，因为如果模型的形式不做假设的话，是无法构建任何模型的。在形式已知的情况下，数学模型里势必有一定数量的参数是不确定的，因此机器学习的过程实际上就是通过已知的样本通过一定的方法确定未知参数的过程。最后，模型需要不仅在已知样本上表现优秀，更要在未知样本上具有相近的表现，这就是模型泛化型需要讨论的问题。 建模和模型 建模的目标：解决什么样的问题 收集数据 选择模型并训练模型，根据已收集的数据和已成熟的工具 应用并解释模型 监视模型的表现以确定其有效性 12345-supervised-regression-classification-unsupervised-data mining 整体使用监督学习模型根据google scholar表明，这是五个最常见的监督模型 线性回归： （34.3%）篇论文 逻辑回归: （22.3%） 神经网络： （16.8%） 决策树： 8.4% 支持向量机： 6.6% 总体而言，线性模型显然占主导地位，占监督模型命中率的50%以上。 模型在生物医学科学中的使用 逻辑回归 线性回归 Cox回归 神经网络 泊松回归","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://quano.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"模型","slug":"算法/001-机器学习/模型","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E5%9E%8B/"}]},{"title":"001什么是服务治理","date":"2021-06-24T14:56:24.000Z","path":"wk/MicroService/微服务架构/服务治理/001.什么是服务治理/","text":"在soa话题中多数会提到服务治理,但服务治理的边界没有明确定义,如何通俗理解什么是”服务治理”? 微服务架构 为线索， 阐释下 什么是服务治理 首先需要明确，不管是什么事物需要”治理“，那一定是该事物存在一定问题。比如环境治理。那么服务，或者说微服务为什么需要治理？ 如果服务承担的业务职责简单, 那治理的必要性不大，即使出现问题也能快速发现、定位、回滚 当服务承担的业务职责变多变大，随着更多问题的到来，服务治理开始变得必要；服务治理也与技术架构本身息息相关。 单体服务（monolithic）如果服务属于单体结构，服务治理的挑战更多是当单体架构由于承载的业务庞大，服务 内部逻辑变得复杂，扩展性也变差。这时候往往不需要特别的服务治理手段，而是将单体服务拆分为微服务，即完成”微服务化“，将原有单体服务架构向微服务架构演进。 微服务（microservices）在微服务架构下，出现了新的服务问题，从而需要对微服务进行服务治理。那微服务又有哪些问题需要治理？ 1、服务注册与发现服务注册中心： 微服务之间存在调用依赖，就需要得到目标服务的服务地址，也就是微服务治理的”服务发现“。将服务信息存储到注册中心。 2、可观测性微服务由于较单体应用有了更多的部署载体，需要对众多服务间的调用关系、状态有清晰的掌控。可观测性就包括了调用拓扑关系、监控（Metrics）、日志（Logging）、调用追踪（Trace）等。 3、流量管理由于微服务本身存在不同版本，在版本更迭过程中，需要对微服务间调用进行控制，以完成微服务版本更迭的平滑。这一过程中需要根据流量的特征（访问参数等）、百分比向不同版本服务分发，这也孵化出灰度发布、蓝绿发布、A/B测试等服务治理的细分主题。 4、安全同微服务承载自身独有的业务职责，对于业务敏感的微服务，需要对其他服务的访问进行认证与鉴权，也就是安全问题。 5、控制对服务治理能力充分建设后，就需要有足够的控制能力，能实时进行服务治理策略向微服务分发。 而对于微服务治理，传统的做法都是需要引入微服务研发框架，配合控制平台完成如上服务治理能力的建设。比较常见的微服务研发框架包括SpringCloud、Dubbo等。 这也就来到微服务架构新的时代 — Service Mesh。服务网格是一个微服务基础设施，用于处理微服务通信、治理、控制、可观测、安全等问题，具备业务无侵入、多语言、热升级等诸多特性，是业界下一代微服务架构方向。目前业界较为主流的是Google、IBM、Lyft主导研发的Istio框架，当然也有一些基于Istio实现的易用性更强的平台（如网易轻舟Service Mesh，利益相关），对Service Mesh本身的易用性、可观察性、可运维性等有了进一步增强。可以说Service Mesh架构本身目前站在了服务治理领域的顶峰。 到底什么是服务治理?","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"微服务架构","slug":"MicroService/微服务架构","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"服务治理","slug":"MicroService/微服务架构/服务治理","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"}]},{"title":"k8s安装指南","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/容器云平台/001.k8s安装指南/","text":"首先选择docker适配的k8s版本. docker 版本 20.10.1k8s 1.23.1-00 amd64 安装安装前做的事 关闭swap. 添加k8s源. 版本选择 如果是window wsl. 需要确保 可以使用systemctl 而不是service.方案 12345678# k8s 的阿里源apt-get update &amp;&amp; apt-get install -y apt-transport-httpsapt upgrade -ycurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;-&#x27;EOF&#x27;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOFapt-get update 1. 安装命令12apt install kubelet=1.23.1-00 kubeadm=1.23.1-00 kubectl=1.23.1-00 -y 2. 初始化1kubeadm init --image-repository registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16 3. 安装Kubernetes.安装 Kubernetes 集群有很多成熟的方案，在本地搭建也有 minikube、microk8s 等等，我们这里选择使用 KinD：在容器中来运行 Kubernetes 的一种简单方式。 1234567# 下载 KinD 二进制文件curl -Lo ./kind https://github.com/kubernetes-sigs/kind/releases/download/v0.8.1/kind-$(uname)-amd64# 标记为可执行文件chmod +x ./kind# 移动到 PATH 目录下去mv ./kind /usr/local/bin/# TODO，记得提前下载安装 kubectl 二进制文件 1234567# 下载 KinD 二进制文件curl -Lo ./kind https://github.com/kubernetes-sigs/kind/releases/download/v0.8.1/kind-$(uname)-amd64# 标记为可执行文件chmod +x ./kind# 移动到 PATH 目录下去mv ./kind /usr/local/bin/# TODO，记得提前下载安装 kubectl 二进制文件 4. 用kind创建一个k8s集群.12345678# 检查是否设置了 KUBECONFIG 环境变量echo $KUBECONFIG# 检查是否存在 .kube 目录，不需要手动创建ls $HOME/.kube# 使用 kind 命令创建一个名为 wslk8s 的集群kind create cluster --name wslk8s# 创建后检查 .kube 目录ls $HOME/.kube 5. 在集群中部署应用.比如安装一个kubernetes Dashboard. 1234# 在集群中安装 Dashboardkubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.1/aio/deploy/recommended.yaml# 获取 dashboard 的资源对象kubectl get all -n kubernetes-dashboard 遗留问题 k8s的网络环境. DNS服务. wsl每次启动 怎么重启k8s. kubectl proxy 是什么 什么用. 共享资源下的 占用问题. 分配权重？？ 针对高性能计算性服务. 服务优雅性. 上下线. 其他的概念. 网络环境： k8s的dns服务 1kubectl apply -f dig.yaml dig.yaml1234567891011121314apiVersion: v1kind: Podmetadata: name: dig namespace: defaultspec: containers: - name: dig image: docker.io/azukiapp/dig command: - sleep - &quot;3600&quot; imagePullPolicy: IfNotPresent restartPolicy: Always k8s dns原理 因为/etc/docker/daemon.json 配置原因导致docker启动失败.{ “exec-opts”: [“native.cgroupdriver=systemd”], “log-driver”: “json-file”, “log-opts”: { “max-size”: “100m” }, “data-root”: “/mnt/d/DockerData/dockerDatas”, “storage-driver”: “overlay2”, “storage-opts”: [“overlay2.override_kernel_check=true”], “registry-mirrors”: [“https://tabss8zh.mirror.aliyuncs.com“], “runtimes”: { “nvidia”: { “path”: “/usr/bin/nvidia-container-runtime”, “runtimeArgs”: [] } }} “data-root”: “/mnt/d/DockerData/docker”,docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.23.1 docker默认的数据文件路径为/var/lib/docker 参考文档wsl上k8s 代码自动发布—docker版本(20.10.1)+k8s版本(1.20.1) K8s教程https://kuboard.cn/learning/https://kubernetes.io/zh/k8s中文文档","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"容器云平台","slug":"MicroService/容器云平台","permalink":"https://quano.gitee.io/categories/MicroService/%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0/"}]},{"title":"线程池","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/微服务架构/基础/001.线程池/","text":"线程池高性能队列——Disruptor 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.conversantmedia&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.lmax/disruptor --&gt;&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"微服务架构","slug":"MicroService/微服务架构","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"基础","slug":"MicroService/微服务架构/基础","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E5%9F%BA%E7%A1%80/"}]},{"title":"微服务架构及其重要的10个设计模式","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/微服务架构/基础/002.微服务架构及其重要的10个设计模式/","text":"软件设计模式 是解决 软件设计中 常见问题的通用、可复用的解决方案。 设计模式可以分享通用词汇并使用经实战检验的方案，以免重复造轮子。现在，我将介绍一系列设计模式来实现这些最佳实践。 微服务架构的设计模式1. 独享数据库单体架构迁移至微服务架构过程中，如果数据库不变。 虽然有一些短期收益，但它却是反模式的，特别是在大规模系统中，微服务将在数据库层严重耦合。 整体迁移的目标将面临失败。 团队授权、独立开发等问题不能解决. 优点： 数据由服务完全所有; 服务的开发团队之间耦合度降低。 缺点：服务间的数据共享变得更有挑战性； 在应用范围的保证ACID事物变得困难许多； 细心设计如何拆分单体数据库 是一项极具挑战的任务。 衍生阅读： 分布式数存储、微服务模式：独享数据库 2. 事件源(Event Sourcing)在微服务架构中，特别使用独享数据库时， 微服务之间需要进行数据交换，对于弹性高可伸缩的和可容错的系统，它们应该通过交换事件进行异步通信。 在这总情况， 可能希望进行类似 更新数据库并发送消息这样的原子操作 将无法使用两阶段锁协议（2PL）,以为它无法伸缩。 而NoSql数据库因为大多不支持两阶段锁协议甚至无法实现分布式事务。 在这些场景，可以基于事件的架构使用事件源模式。在传统数据库中，直接存储的是业务体当前“状态”， 而在事件源中任何“状态” 更新事件或其他重要事件都会被存储起来，而不是直接存储实体本身。 优点： 为高可伸缩系统提供原子性操作； 自动记录实体变更历史，包括时序回溯功能； 松耦合和事件驱动的微服务。 缺点： 从事件存储中读取实体成为新的挑战，通常需要额外的数据存储(CQRS模式); 系统整体复杂性增加了，通常需要领域驱动设计； 系统需要处理事件重复（幂等）或丢失； 变更事件结构成为新的挑战。 衍生阅读： 事件驱动；事件驱动模式-云设计模式； 微服务模式：事件驱动。 3. 命令和查询职责分离（CQRS）4. Saga","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"微服务架构","slug":"MicroService/微服务架构","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"基础","slug":"MicroService/微服务架构/基础","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E5%9F%BA%E7%A1%80/"}]},{"title":"工作流引擎","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/微服务架构/工作流引擎/001.readme/","text":"什么情况下，需要使用工作流引擎？ 几大工作流引擎对比 流程引擎介绍","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"微服务架构","slug":"MicroService/微服务架构","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"工作流引擎","slug":"MicroService/微服务架构/工作流引擎","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BC%95%E6%93%8E/"}]},{"title":"分布式链路追踪认识及选型","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/微服务架构/链路追踪/001.trace介绍/","text":"微服务化后所出现的一些矛盾/冲突点 背景: 级联故障和雪崩 的 P0 级别事件后，你小手一摊便葛优躺了。开始进行自我复盘，想起这次排查经历，由于现在什么基础设施都还没有，因此在接收到客户反馈后，你是通过错误日志进行问题检查的。 Google Dapper 论文所介绍的 Dapper. 源于 Google 为了解决可能由不同团队，不同语言，不同模块，部署在不同服务器，不同数据中心的所带来的软件复杂性(很难去分析，无法做定位)，构建了一个的分布式跟踪系统. 自此就开启了业界在分布式链路的启发/启蒙之路，很多现在出名的分布式链路追踪系统都是基于 Google Dapper 论文发展而来，基本原理和架构都大同小异。 选型, 有哪些 Twitter：Zipkin。 Uber：Jaeger。 Elastic Stack：Elastic APM。 Apache：SkyWalking(国内开源爱好者吴晟开源)。 Naver：Pinpoint(韩国公司开发)。 阿里：鹰眼。 大众点评：Cat。 京东：Hydra。 问题: 他们之间都是基于 Google Dapper 演进出来的，那本质上到底有什么区别，怎么延伸出这么多的新产品? 链路跟踪系统的功能 故障快速定位 各个调用环节的性能分析 数据分析等 生成服务调用拓扑图 各大厂分布式链路跟踪系统架构对比","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"微服务架构","slug":"MicroService/微服务架构","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"链路追踪","slug":"MicroService/微服务架构/链路追踪","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"}]},{"title":"吞吐量和延迟","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/技术框架/RPC/doc/吞吐量和延迟/","text":"延迟和吞吐量的关系 对于分布式系统，关于微服务对性能的影响. 延迟和响应事件.延迟 是对于服务本身来说， 响应时间是相对于 调用者来说. 延迟(latency) = 请求响应 出入系统的时间.响应时间(ResponseTime) = 客户端请求开始，一直到响应的时间 = 延迟 + 网络耗时 理想状态下： 延迟越低，吞吐越高，当然这是对单机单线程而言. 微服务相对单体架构 的副作用： 延迟变高. 原来的单个调用, 变成多次 远程调用. 并发度 = 吞吐量 * 延迟. 吞吐量： 表示在单位时间内通过某个网络或接口的数据量 ，包括全部上传和下载的流量。 tomcat没有一味追求大吞吐量。他用nio是为了尽可能多的处理请求的同时不会让用户感受到太大的延迟。 ？？？？","tags":[{"name":"rpc","slug":"rpc","permalink":"https://quano.gitee.io/tags/rpc/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"doc","slug":"MicroService/技术框架/RPC/doc","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/doc/"}]},{"title":"Thrift框架原理及rpc认识","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/技术框架/RPC/doc/001.post/","text":"开源RPC框架如何选型？ 百度开源项目 brpc 进入 Apache 孵化器","tags":[{"name":"rpc","slug":"rpc","permalink":"https://quano.gitee.io/tags/rpc/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"doc","slug":"MicroService/技术框架/RPC/doc","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/doc/"}]},{"title":"Thrift框架原理及rpc认识","date":"2021-06-21T14:56:24.000Z","path":"wk/MicroService/技术框架/RPC/thrift/thrift/","text":"互联网服务的协议汇总 rpc thrift dubbo others http rest graphql 三个问题 接口不通 各个服务经常有超时问题, 找不到原因(rest接口没有问题) 重试怎么用？ 解答及处理思路 接口不通 12341. 配置原因 - server服务未注册成功 - test-client服务未注册成功 - thrift未开启 这就是个初级问题 服务的超时等其他问题, 很莫名其妙 123- 业务逻辑自身耗时较长- thrift性能不行? 相比其他框架- 或者不适合这个服务场景(对thrift认识不够) 怎么做？ 压测, thrift各种io模式的对比和选择. 压测结果 及 各个io模式介绍三个主题内容 thrift框架 链路追踪 （nlp实现, server实现） -&gt; 业务自身耗时、接口超时问题 服务平滑下线、服务治理、监控检查 thrift框架1. 分为以下几大类 TTransport：客户端传输层相关的类； TServerTransport：服务端传输层相关的类； TProtocol：序列化、反序列化相关的类； TServer：服务器的IO事件流模型相关的类； TProcessor：函数，接口调用相关的类； org.apache.thrift.server.TServer - 接受请求的server. 进行请求处理.org.apache.thrift.server.TServerEventHandler - 处理请求 2. Server的几个类型TNonblockingServer - 提供的NIO实现的服务模式，提供非阻塞的服务处理，用一个单线程来处理所有的RPC请求。 THsHaServer (extends TNonblockingServer) - 半同步半异步的服务端模型，需要指定为： TFramedTransport 数据传输的方式。 TThreadedSelectorServer - TThreadedSelectorServer是对THsHaServer的一种扩充与完善. 121. 它将selector中的读写IO事件(read/write)从主线程中分离出来。交给了多个专门负责读写IO事件的SelectorThread2. 同时引入worker工作线程池，负责业务处理。它也是种Half-Sync/Half-Async的服务模型。 TThreadedSelectorServer模式是目前Thrift提供的最高级的线程服务模型 Thrift源码分析（TThreadedSelectorServer） 同步线程模型（阻塞式IO服务模型） TSimpleServer -TThreadPoolServer - 线程池来处理并发的RPC请求. TThreadPoolServer用来executorService_用来处理RPC请求 该模式的处理能力受限于线程池的工作能力，当并发请求数大于线程池中的线程数时，新的请求会进入队列中排队等待处理 socket的读 写数据 和业务线程一起处理 并发数大于线程数时， 后来的请求 server没有 read（io操作）, 等处理完再 read(io操作). read 和 业务逻辑处理 是同步进行的 Netty 线程模型及比较链路追踪（nlp实现, server实现） -&gt; 业务自身耗时、接口超时问题 服务平滑下线、服务治理、监控检查","tags":[{"name":"rpc","slug":"rpc","permalink":"https://quano.gitee.io/tags/rpc/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"thrift","slug":"MicroService/技术框架/RPC/thrift","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/thrift/"}]},{"title":"人生重要的事情","date":"2021-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/教育/哈弗公开课/重要的事情/","text":"高尔夫球代表着重要的东西，比如你的家人 朋友 健康。小石头则代表琐碎重要的东西， 比如你的汽车、工作、房子。沙子呢 就是其他一些小事情。 如果先把沙子倒进罐子 你就没有空间放石头和高尔夫球， 人生也是一样的道理。 如果你把所有时间和精力放到小事情上。 你就没有时间去在意真正重要的事情。 每个人的人生都只有一次。 先把高尔夫球顾好 也就是真正重要的事。 因为其他东西都是沙子而已。 啤酒代表着什么: 代表着无论你的生活有多么紧凑。仍然有时间和朋友把酒言欢。 2 我们生活中有很多这样的事情： 感觉生活把我们摁在地上摩擦，我们可能做了糟糕的决定或者没处理好事情。有时候日子甚至让我们感觉自己一无是处。 但无论发生什么 未来可能发生什么 永远不要丢弃自己的价值。 请千万记住这一点。","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"教育","slug":"项目管理/生活学习/教育","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%95%99%E8%82%B2/"},{"name":"哈弗公开课","slug":"项目管理/生活学习/教育/哈弗公开课","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%95%99%E8%82%B2/%E5%93%88%E5%BC%97%E5%85%AC%E5%BC%80%E8%AF%BE/"}]},{"title":"数据存储","date":"2021-01-08T03:55:57.000Z","path":"wk/数据/数据存储/001.存储概述/","text":"hbase、rocksdb、mysql、mongodb、redis 各个存储的差异. 底层原理的差异. 再不同场景下如何选择. 场景存储结构数据协议、系统能力了解原理之后, 有哪些用途方便快速的锁定并解决问题，在合适的场景选择合适的存储.","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据存储","slug":"数据/数据存储","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"Hbase存储原理","date":"2021-01-08T03:55:57.000Z","path":"wk/数据/数据存储/002.Hbase存储原理/","text":"介绍Hbase的存储模式1. 行式存储与列式存储行式存储特点 是把每一行的所有列存储完, 再存储下一个行的所有列.一行一行横向存储. 列式存储特点 是把每一列的数据存储完, 再存储下一列的所有数据, 直到所有列的数据存储完, 是纵向的存储. 列式存储 每一列的数据都是分开存储. （根据同一列数据的相似性原理，可对数据进行压缩.） 2. 应用场景列式存储应用场景 对于单列 或者相对少的列, 获取频率较高, 推荐列式存储. 大数据的环境，利用数据压缩和扩展的场景 事务使用率不高、读取场景的频率不高、数据量非常大的场景 随机更新某行的频率不高的场景. 行式存储应用场景 关系型数据库的解决方案, 如果表与表之间有很强的关联性，且数据量不大. 最大的优势是 联机事务处理能力。 类似消费、转账 强事务关联性. 行式存储适合事务型应用场景，列式存储更适合分析型应用场景 Hbase读性能不很好的吗，为什么？ HBase索引原理HBase 列族的存储概念","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据存储","slug":"数据/数据存储","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"01.后端架构师技术图谱","date":"2020-12-05T16:56:24.000Z","path":"wk/MicroService/README/","text":"后端架构师技术图谱 后端架构师技术图谱","tags":[{"name":"架构","slug":"架构","permalink":"https://quano.gitee.io/tags/%E6%9E%B6%E6%9E%84/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"}]},{"title":"pandas数据类型","date":"2020-11-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/pandas/002.pandas数据类型/","text":"","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"pandas","slug":"平台工具/程序语言/Python/pandas","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/pandas/"}]},{"title":"DataFrame遍历","date":"2020-11-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/pandas/003.DataFrame遍历/","text":"先读取一个DataFrame1234import pandas as pd#读入数据df = pd.read_table(&#x27;d:/Users/chen_lib/Desktop/tmp.csv&#x27;,sep=&#x27;,&#x27;, header=&#x27;infer&#x27;)df.head() 新版 read_table 使用read_csv 替换了. DataFrame遍历【Python】DataFrame遍历 12for row in df.iteritems(): print(row[0], row[1], row[2]) # 输出各列","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"pandas","slug":"平台工具/程序语言/Python/pandas","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/pandas/"}]},{"title":"WSL2使用","date":"2020-11-16T17:13:34.000Z","path":"wk/平台工具/工作相关/WIN/001.WSL2/","text":"在Windows中动态获取WSL2中的IP地址.123ipaddr=$(ifconfig eth0 | grep &#x27;inet &#x27; | awk &#x27;&#123;print $2&#125;&#x27;)sed -i &#x27;/wslhost/d&#x27; /mnt/c/Windows/System32/drivers/etc/hostsecho &quot;$ipaddr wslhost&quot; &gt;&gt; /mnt/c/Windows/System32/drivers/etc/hosts 在 /etc/profile 中配置以上信息. 注意win中hosts文件权限问题. wsl 虚拟磁盘压缩清理WSL2的磁盘占用 123456diskpart.exe# 选择虚拟磁盘select vdisk file=&quot;C:\\Users\\Administrator\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx&quot;# 进行压缩compact vdisk wsl 磁盘迁移WSL2迁移虚拟磁盘文件ext4.vhdx 12# 设置默认用户ubuntu1804 config --default-user tensor","tags":[{"name":"node","slug":"node","permalink":"https://quano.gitee.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://quano.gitee.io/tags/npm/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"WIN","slug":"平台工具/工作相关/WIN","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/WIN/"}]},{"title":"wrk-http压测","date":"2020-11-16T17:13:34.000Z","path":"wk/平台工具/工作相关/压测/001.wrk-http压测/","text":"https://cloud.tencent.com/developer/article/1418087 123456# 压测： 12 个线程, 400连接数, 持续时间30s, wrk -t12 -c400 -d30s -R 40000 http://wslhost:2222/p2?content=zhangquanquan# 其他参数.# -s 选择 lua文件, 用于压测http请求.wrk -t12 -c400 -d30s -s post.lua -R 4000 http://wslhost:8888/graphql post.lua文件: 1234567wrk.method = &quot;POST&quot;wrk.body = &#x27;&#123;&quot;query&quot;: &quot;query&#123; greeting &#125;&quot;&#125;&#x27;wrk.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;function request() return wrk.format(&#x27;POST&#x27;, nil, nil, body)end 12# 先用curl测试接口是否正常.curl -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;query&quot;: &quot;query&#123; greeting &#125;&quot;&#125;&#x27; &quot;http://wslhost:8869/graphql&quot;","tags":[{"name":"wrk","slug":"wrk","permalink":"https://quano.gitee.io/tags/wrk/"},{"name":"压测","slug":"压测","permalink":"https://quano.gitee.io/tags/%E5%8E%8B%E6%B5%8B/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"压测","slug":"平台工具/工作相关/压测","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E5%8E%8B%E6%B5%8B/"}]},{"title":"Node环境搭建","date":"2020-11-16T17:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/001.node环境搭建/","text":"下载安装包从淘宝镜像站 下载所需安装包 这里选择版本: node - 12.3.0 linux 系统选择tag.gz 压缩包, 下载解压。 然后配置/usr/local/bin/node. mac 选择 node-v12.3.0.pkg . 下载后点击安装 mac node 升级 sudo npm install -g n //使用npm安装n模块npm view node versions // node所有版本 sudo n latest // 升级到最新版本 sudo n stable // 升级到稳定版本 sudo n xx.xx // 升级到具体版本号","tags":[{"name":"node","slug":"node","permalink":"https://quano.gitee.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"https://quano.gitee.io/tags/npm/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Sbt Reference Manual","date":"2020-11-16T17:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/005.sbt环境搭建/","text":"sbt是 scala的构建工具. 全称是 simple Build Tool. 类似Maven或者Gradle. sbt Reference Manual sbt Reference Manual-english 下载https://github.com/sbt/sbt/releases/download/v1.5.0/sbt-1.5.0.zip 下载后 在指定目录(/opt/tools/sbt)解压. 配置环境变量， 使可以直接使用sbt命令.123export SBT_HOME=/opt/tools/sbt/export PATH=$SBT_HOME/bin/:$PATHexport SBT_OPTS=&quot;-Dsbt.override.build.repos=true&quot; -Dsbt.override.build.repos=true 表示全局 配置国内镜像.创建 ~/.sbt 目录. 新建文件 repositories 文件内容如下 12345[repositories]localhuaweicloud-maven: https://repo.huaweicloud.com/repository/maven/maven-central: https://repo1.maven.org/maven2/sbt-plugin-repo: https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext] sbt 插件.","tags":[{"name":"sbt","slug":"sbt","permalink":"https://quano.gitee.io/tags/sbt/"},{"name":"ci","slug":"ci","permalink":"https://quano.gitee.io/tags/ci/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"下载并安装 Android Studio","date":"2020-11-16T17:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/006.Andriod开发环境/","text":"资料：Android studio安装入门教程 1.下载下载并安装 Android Studio 2.初始化下载之后，点击应用. 问题：Android SDK。 会弹出需要Android SDK。 可以忽略，在后面的步骤进行下载。 或者也可以自行单独下载. 3. 创建项目按照好Android Studio，并下载Android SDK后，进入 工具， 选择创建项目（或者导入已有项目）。 4. Android项目相关的概念.","tags":[{"name":"Android","slug":"Android","permalink":"https://quano.gitee.io/tags/Android/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"CSV文件读取","date":"2020-10-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/基础语法及操作/001.csv文件读取/","text":"CSV File Reading and Writing pandas 深度学习平台 数据集","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"基础语法及操作","slug":"平台工具/程序语言/Python/基础语法及操作","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%93%8D%E4%BD%9C/"}]},{"title":"中文http请求乱码解决","date":"2020-10-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/基础语法及操作/002.中文http请求乱码解决/","text":"HTTP content-type","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"基础语法及操作","slug":"平台工具/程序语言/Python/基础语法及操作","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%93%8D%E4%BD%9C/"}]},{"title":"工具包整理","date":"2020-10-14T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/002.文本抽取/","text":"funNLP:文本中抽取结构化信息(敏感词,实体识别等)","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"Word2vec","date":"2020-10-14T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/NLP系列/002.word2vec/","text":"知乎-深入浅出Word2Vec原理解析 借鉴其中思维导图. 语言模型 Word2Vec是语言模型中的一种， 它是从大量文本预料中以无监督方式学习语义知识的模型，被广泛地应用于自然语言处理中。 Word2Vec是用来生成词向量的工具，而词向量与语言模型有着密切的关系。因此，我们先来了解一些语言模型方面的知识。 1.背景知识.统计语言模型、n-gram模型、神经概率语言模型 2.词向量One-hot、Distributed Representation. 3.Word2Vec的网络结构CBOW、Skip-gram model 4. 基于分层softmax的模型.原理word2vec是一个简单的神经网络，有以下几个层组成： （1）１个输入层：输入使用的是one-hot编码。即：假设有n个词，则每一个词可以用一个n维的向量来表示，这个n维向量只有一个位置是1，其余位置都是0。 （2）1个隐藏层：隐藏层的神经单元数量，代表着每一个词用向量表示的维度大小。对于输入层和隐藏层之间的权值矩阵，它的形状应该是[vocab_size, hidden_size]的矩阵。 （3）1个输出层：输出层是一个 [vocab_size] 大小的向量，每一个值代表着输出一个词的概率。 word2vec的应用场景 (在工业界的应用)Word2Vec主要原理是根据上下文来预测单词，一个词的意义往往可以从其前后的句子中抽取出来。 而用户的行为也是一种相似的时间序列，可以通过上下文进行推断。当用户浏览并与内容进行交互时，我们可以从用户前后的交互过程中判断行为的抽象特征，这就使得我们可以把词向量模型应用到推荐、广告领域当中。 NLP领域Word2Vec学习到的词向量代表了词的语义，可以用来做分类、聚类、也可以做词的相似度计算。把Word2Vec生成的向量直接作为深度神经网络的输入，可以做sentiment analysis等工作。 图嵌入基于Word2Vec这一类的Graph Embedding方法有很多，具体可以参考论文：DeepWalk（是引入Word2Vec思想比较经典的图嵌入算法），node2vec，struc2vec 等等。 推荐领域Airbnb在论文《Real-time Personalization using Embeddings for Search Ranking at Airbnb》中提出将用户的浏览行为组成List，通过Word2Vec方法学习item的向量，其点击率提升了21%，且带动了99%的预定转化率。该论文主要是在Skip-gram 模型的基础上做了改进。Yahoo在论文《E-commerce in Your Inbox: Product Recommendations at Scale》中提出Yahoo邮箱从发送到用户的购物凭证中抽取商品并组成List，通过Word2Vec学习并为用户推荐潜在的商品； 广告领域Yahoo在论文《Scalable Semantic Matching of Queries to Ads in Sponsored Search Advertising》中提出将用户的搜索查询和广告组成List，并为其学习特征向量，以便对于给定的搜索查询可以匹配适合的广告。 关于Word2Vec若干问题的思考（1）Word2Vec两个算法模型的原理是什么，网络结构怎么画？ （2）网络输入输出是什么？隐藏层的激活函数是什么？输出层的激活函数是什么？ （3）目标函数/损失函数是什么？ （4）Word2Vec如何获取词向量？ （5）推导一下Word2Vec参数如何更新？ （6）Word2Vec的两个模型哪个效果好哪个速度快？为什么？ （7）Word2Vec加速训练的方法有哪些？ （8）介绍下Negative Sampling，对词频低的和词频高的单词有什么影响？为什么？ （9）Word2Vec和隐狄利克雷模型(LDA)有什么区别与联系？ 以上问题可以通过本文和参考文章找到答案，这里不再详细解答。 （10）介绍下Hierarchical Softmax的计算过程，怎么把 Huffman 放到网络中的？参数是如何更新的？对词频低的和词频高的单词有什么影响？为什么？ Hierarchical Softmax利用了Huffman树依据词频建树，词频大的节点离根节点较近，词频低的节点离根节点较远，距离远参数数量就多，在训练的过程中，低频词的路径上的参数能够得到更多的训练，所以效果会更好。 （11）Word2Vec有哪些参数，有没有什么调参的建议？ Skip-Gram 的速度比CBOW慢一点，小数据集中对低频次的效果更好；Sub-Sampling Frequent Words可以同时提高算法的速度和精度，Sample 建议取值为 [公式] ；Hierarchical Softmax对低词频的更友好；Negative Sampling对高词频更友好；向量维度一般越高越好，但也不绝对；Window Size，Skip-Gram一般10左右，CBOW一般为5左右。（12）Word2Vec有哪些局限性？ Word2Vec作为一个简单易用的算法，其也包含了很多局限性： Word2Vec只考虑到上下文信息，而忽略的全局信息；Word2Vec只考虑了上下文的共现性，而忽略的了彼此之间的顺序性；","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"},{"name":"NLP系列","slug":"算法/001-机器学习/NLP/NLP系列","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/NLP%E7%B3%BB%E5%88%97/"}]},{"title":"README.md","date":"2020-10-02T14:55:57.000Z","path":"wk/算法/001.机器学习/000.README/","text":"人工智能领域的百科全书:小白和新手入门 中文语音识别系统 jpmml 预测模型标记语言(Predictive Model Markup Language,PMML)是一种可以呈现预测分析模型的事实标准语言。标准东西的好处就是，各种开发语言都可以使用相应的包，把模型文件转成这种中间格式，而另外一种开发语言，可以使用相应的包导入该文件做线上预测。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"自然语言处理与人工智能的关系","date":"2020-10-02T14:55:57.000Z","path":"wk/算法/001.机器学习/001.自然语言处理与人工智能的关系/","text":"AI： 数据、算法、计算能力AI: 计算智能、感知智能、认知智能 最底层是所谓的运算智能，计算机在记忆存储和运算远远超过人类，以前我们还认为这是一种智能，但现在已经没有人在讨论人工智能的时候，把它也作为智能，但它是一切人工智能的基础。再往上就是感知智能，就包括听觉、视觉、触觉等等，在过去几年取得了突飞猛进的结果。再往上是认知智能，认知智能主要是语言知识和推理。今天讲座的主题就是在语言智能这个领域。这三者是密切相关的，语言的能力强了，对问题的理解就强，获取知识的能力强，那么推理的能力也强。所以语言智能是认知智能中最重要的一个。再往上就是创造智能，就是说从无到有产生一个想法，甚至一套理论，把它勾画出来，再通过实践验证出来，产生一个新的事物、物体或者意识。这方面的智能目前计算机还是比较薄弱。 基础层大数据、算法、大计算 感知层语音、图像、视频、 AR/VR 认知层自然语言处理、知识图谱、用户画像 平台层AI开放平台 应用层产品应用 自然语言处理自然语言处理（Natural Language Processing，简称NLP）就是用计算机来处理、理解以及运用人类语言(如中文、英文等)，它属于人工智能的一个分支，是计算机科学与语言学的交叉学科，又常被称为计算语言学 广义的自然语言处理包含了语音，狭义的自然语言处理仅指处理及理解文本 相关术语：自然语言理解、计算语言学、文本挖掘 自然语言处理，就是研究语言的理解和运用一、什么是自然语言处理自然语言处理是计算机科学领域与人工智能领域中的一个重要方向。它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。自然语言处理是一门融语言学、计算机科学、数学于一体的科学。因此，这一领域的研究将涉及自然语言，即人们日常使用的语言，所以它与语言学的研究有着密切的联系，但又有重要的区别。自然语言处理并不是一般地研究自然语言，而在于研制能有效地实现自然语言通信的计算机系统，特别是其中的软件系统。因而它是计算机科学的一部分。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"CheckStyle","date":"2020-08-27T17:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/004.checkstyle/","text":"对代码进行静态检查的工具. mavenmaven-checkstyle-plugin内置了4中规范. config/sun_checks.xmlconfig/maven_checks.xmlconfig/turbine_checks.xmlconfig/avalon_checks.xml idea checkstyle的配置idea安装Checkstyle(代码规范工具) CheckStyle, 强制你遵循编码规范","tags":[{"name":"idea","slug":"idea","permalink":"https://quano.gitee.io/tags/idea/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"CheckStyle","date":"2020-08-27T17:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/004_1.checkstype_google/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE module PUBLIC &quot;-//Puppy Crawl//DTD Check Configuration 1.3//EN&quot; &quot;http://www.puppycrawl.com/dtds/configuration_1_3.dtd&quot;&gt;&lt;!-- This is a checkstyle configuration file. For descriptions ofwhat the following rules do, please see the checkstyle configurationpage at http://checkstyle.sourceforge.net/config.html --&gt;&lt;module name=&quot;Checker&quot;&gt; &lt;module name=&quot;RegexpSingleline&quot;&gt; &lt;!-- Requires a Google copyright notice in each file. Code intended to be open-sourced may have a multi-line copyright notice, so that this required text appears on the second line: &lt;pre&gt; /* * Copyright 2008 Google Inc. * * (details of open-source license...) &lt;/pre&gt; --&gt; &lt;property name=&quot;format&quot; value=&quot;^(//| \\*) Copyright (\\([cC]\\) )?[\\d]&#123;4&#125;(\\-[\\d]&#123;4&#125;)? (Google Inc\\.).*$&quot; /&gt; &lt;property name=&quot;minimum&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maximum&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;message&quot; value=&quot;Google copyright is missing or malformed.&quot; /&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot; /&gt; &lt;/module&gt; &lt;module name=&quot;FileTabCharacter&quot;&gt; &lt;!-- Checks that there are no tab characters in the file. --&gt; &lt;/module&gt; &lt;module name=&quot;NewlineAtEndOfFile&quot;/&gt; &lt;module name=&quot;RegexpSingleline&quot;&gt; &lt;!-- Checks that FIXME is not used in comments. TODO is preferred. --&gt; &lt;property name=&quot;format&quot; value=&quot;((//.*)|(\\*.*))FIXME&quot; /&gt; &lt;property name=&quot;message&quot; value=&#x27;TODO is preferred to FIXME. e.g. &quot;TODO(johndoe): Refactor when v2 is released.&quot;&#x27; /&gt; &lt;/module&gt; &lt;module name=&quot;RegexpSingleline&quot;&gt; &lt;!-- Checks that TODOs are named. (Actually, just that they are followed by an open paren.) --&gt; &lt;property name=&quot;format&quot; value=&quot;((//.*)|(\\*.*))TODO[^(]&quot; /&gt; &lt;property name=&quot;message&quot; value=&#x27;All TODOs should be named. e.g. &quot;TODO(johndoe): Refactor when v2 is released.&quot;&#x27; /&gt; &lt;/module&gt; &lt;!-- All Java AST specific tests live under TreeWalker module. --&gt; &lt;module name=&quot;TreeWalker&quot;&gt; &lt;!-- IMPORT CHECKS --&gt; &lt;module name=&quot;RedundantImport&quot;&gt; &lt;!-- Checks for redundant import statements. --&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;ImportOrder&quot;&gt; &lt;!-- Checks for out of order import statements. --&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;property name=&quot;groups&quot; value=&quot;com.google,android,junit,net,org,java,javax&quot;/&gt; &lt;!-- This ensures that static imports go first. --&gt; &lt;property name=&quot;option&quot; value=&quot;top&quot;/&gt; &lt;property name=&quot;tokens&quot; value=&quot;STATIC_IMPORT, IMPORT&quot;/&gt; &lt;/module&gt; &lt;!-- JAVADOC CHECKS --&gt; &lt;!-- Checks for Javadoc comments. --&gt; &lt;!-- See http://checkstyle.sf.net/config_javadoc.html --&gt; &lt;module name=&quot;JavadocMethod&quot;&gt; &lt;property name=&quot;scope&quot; value=&quot;protected&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;property name=&quot;allowMissingJavadoc&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;allowMissingParamTags&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;allowMissingReturnTag&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;allowMissingThrowsTags&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;allowThrowsTagsForSubclasses&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;allowUndeclaredRTE&quot; value=&quot;true&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;JavadocType&quot;&gt; &lt;property name=&quot;scope&quot; value=&quot;protected&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;JavadocStyle&quot;&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;!-- NAMING CHECKS --&gt; &lt;!-- Item 38 - Adhere to generally accepted naming conventions --&gt; &lt;module name=&quot;PackageName&quot;&gt; &lt;!-- Validates identifiers for package names against the supplied expression. --&gt; &lt;!-- Here the default checkstyle rule restricts package name parts to seven characters, this is not in line with common practice at Google. --&gt; &lt;property name=&quot;format&quot; value=&quot;^[a-z]+(\\.[a-z][a-z0-9]&#123;1,&#125;)*$&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;TypeNameCheck&quot;&gt; &lt;!-- Validates static, final fields against the expression &quot;^[A-Z][a-zA-Z0-9]*$&quot;. --&gt; &lt;metadata name=&quot;altname&quot; value=&quot;TypeName&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;ConstantNameCheck&quot;&gt; &lt;!-- Validates non-private, static, final fields against the supplied public/package final fields &quot;^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$&quot;. --&gt; &lt;metadata name=&quot;altname&quot; value=&quot;ConstantName&quot;/&gt; &lt;property name=&quot;applyToPublic&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToProtected&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToPackage&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToPrivate&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;format&quot; value=&quot;^([A-Z][A-Z0-9]*(_[A-Z0-9]+)*|FLAG_.*)$&quot;/&gt; &lt;message key=&quot;name.invalidPattern&quot; value=&quot;Variable &#x27;&#x27;&#123;0&#125;&#x27;&#x27; should be in ALL_CAPS (if it is a constant) or be private (otherwise).&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;StaticVariableNameCheck&quot;&gt; &lt;!-- Validates static, non-final fields against the supplied expression &quot;^[a-z][a-zA-Z0-9]*_?$&quot;. --&gt; &lt;metadata name=&quot;altname&quot; value=&quot;StaticVariableName&quot;/&gt; &lt;property name=&quot;applyToPublic&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToProtected&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToPackage&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToPrivate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-zA-Z0-9]*_?$&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;MemberNameCheck&quot;&gt; &lt;!-- Validates non-static members against the supplied expression. --&gt; &lt;metadata name=&quot;altname&quot; value=&quot;MemberName&quot;/&gt; &lt;property name=&quot;applyToPublic&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToProtected&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToPackage&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;applyToPrivate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-zA-Z0-9]*$&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;MethodNameCheck&quot;&gt; &lt;!-- Validates identifiers for method names. --&gt; &lt;metadata name=&quot;altname&quot; value=&quot;MethodName&quot;/&gt; &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-zA-Z0-9]*(_[a-zA-Z0-9]+)*$&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;ParameterName&quot;&gt; &lt;!-- Validates identifiers for method parameters against the expression &quot;^[a-z][a-zA-Z0-9]*$&quot;. --&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;LocalFinalVariableName&quot;&gt; &lt;!-- Validates identifiers for local final variables against the expression &quot;^[a-z][a-zA-Z0-9]*$&quot;. --&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;LocalVariableName&quot;&gt; &lt;!-- Validates identifiers for local variables against the expression &quot;^[a-z][a-zA-Z0-9]*$&quot;. --&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;!-- LENGTH and CODING CHECKS --&gt; &lt;module name=&quot;LineLength&quot;&gt; &lt;!-- Checks if a line is too long. --&gt; &lt;property name=&quot;max&quot; value=&quot;$&#123;com.puppycrawl.tools.checkstyle.checks.sizes.LineLength.max&#125;&quot; default=&quot;100&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;!-- The default ignore pattern exempts the following elements: - import statements - long URLs inside comments --&gt; &lt;property name=&quot;ignorePattern&quot; value=&quot;$&#123;com.puppycrawl.tools.checkstyle.checks.sizes.LineLength.ignorePattern&#125;&quot; default=&quot;^(package .*;\\s*)|(import .*;\\s*)|( *\\* *https?://.*)$&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;LeftCurly&quot;&gt; &lt;!-- Checks for placement of the left curly brace (&#x27;&#123;&#x27;). --&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;RightCurly&quot;&gt; &lt;!-- Checks right curlies on CATCH, ELSE, and TRY blocks are on the same line. e.g., the following example is fine: &lt;pre&gt; if &#123; ... &#125; else &lt;/pre&gt; --&gt; &lt;!-- This next example is not fine: &lt;pre&gt; if &#123; ... &#125; else &lt;/pre&gt; --&gt; &lt;property name=&quot;option&quot; value=&quot;same&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;!-- Checks for braces around if and else blocks --&gt; &lt;module name=&quot;NeedBraces&quot;&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_IF, LITERAL_ELSE, LITERAL_FOR, LITERAL_WHILE, LITERAL_DO&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;UpperEll&quot;&gt; &lt;!-- Checks that long constants are defined with an upper ell.--&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;FallThrough&quot;&gt; &lt;!-- Warn about falling through to the next case statement. Similar to javac -Xlint:fallthrough, but the check is suppressed if a single-line comment on the last non-blank line preceding the fallen-into case contains &#x27;fall through&#x27; (or some other variants which we don&#x27;t publicized to promote consistency). --&gt; &lt;property name=&quot;reliefPattern&quot; value=&quot;fall through|Fall through|fallthru|Fallthru|falls through|Falls through|fallthrough|Fallthrough|No break|NO break|no break|continue on&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;!-- MODIFIERS CHECKS --&gt; &lt;module name=&quot;ModifierOrder&quot;&gt; &lt;!-- Warn if modifier order is inconsistent with JLS3 8.1.1, 8.3.1, and 8.4.3. The prescribed order is: public, protected, private, abstract, static, final, transient, volatile, synchronized, native, strictfp --&gt; &lt;/module&gt; &lt;!-- WHITESPACE CHECKS --&gt; &lt;module name=&quot;WhitespaceAround&quot;&gt; &lt;!-- Checks that various tokens are surrounded by whitespace. This includes most binary operators and keywords followed by regular or curly braces. --&gt; &lt;property name=&quot;tokens&quot; value=&quot;ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN, COLON, DIV, DIV_ASSIGN, EQUAL, GE, GT, LAND, LE, LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS, MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SL_ASSIGN, SR_ASSIGN, STAR, STAR_ASSIGN&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;WhitespaceAfter&quot;&gt; &lt;!-- Checks that commas, semicolons and typecasts are followed by whitespace. --&gt; &lt;property name=&quot;tokens&quot; value=&quot;COMMA, SEMI, TYPECAST&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;NoWhitespaceAfter&quot;&gt; &lt;!-- Checks that there is no whitespace after various unary operators. Linebreaks are allowed. --&gt; &lt;property name=&quot;tokens&quot; value=&quot;BNOT, DEC, DOT, INC, LNOT, UNARY_MINUS, UNARY_PLUS&quot;/&gt; &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;NoWhitespaceBefore&quot;&gt; &lt;!-- Checks that there is no whitespace before various unary operators. Linebreaks are allowed. --&gt; &lt;property name=&quot;tokens&quot; value=&quot;SEMI, DOT, POST_DEC, POST_INC&quot;/&gt; &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;severity&quot; value=&quot;error&quot;/&gt; &lt;/module&gt; &lt;module name=&quot;ParenPad&quot;&gt; &lt;!-- Checks that there is no whitespace before close parens or after open parens. --&gt; &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt; &lt;/module&gt; &lt;/module&gt;&lt;/module&gt;","tags":[{"name":"idea","slug":"idea","permalink":"https://quano.gitee.io/tags/idea/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Mongo常用命令","date":"2020-08-23T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mongo/Mongo常用命令/","text":"创建索引1db.persons.createIndex(&#123;name:1,email:1&#125;,&#123;unique:true&#125;) 索引相关","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mongo","slug":"数据/数据处理/DataStore/Mongo","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mongo/"}]},{"title":"还记得儿时的梦吗","date":"2020-07-23T01:56:24.000Z","path":"wk/项目管理/生活学习/还记得儿时的梦吗/","text":"还记得儿时的梦吗. “像朵永不凋谢的花！” 听着很容易让人反思和感慨. 像是被提醒 不要忘记初心. (但我也没有完全理解) 还记得儿时的梦吗? 2“我要飞的很高” 其实小时候看的电视剧比较多， 映像深刻的是 在环境很好的写字楼里上班, 聊天, 生活. 但后来发现, 这没什么意义和价值. 再后来 面临选专业, 我也不知道选什么, 因为不知道有哪些专业. 记得对计算机比较感兴趣, 所以高中的时候 告诉同学 我可能回报计算机专业. (然后没有告诉同学的是, 甚至连我都没有意识到 我期望的是只有一条, 走的更远. ) 3还记得儿时的梦吗， 想朵永不凋零的花。 其实我们很多人没有明确的梦想, 可能。 因为 老师教给我们的只有灌输的 知识, 没有给我们一点自主意识. 让我们可以考虑梦想. 「教育」 4小时候，我们想读研究生, 相当科学家, 又或者我们一直会是名列前茅的佼佼者. 到后来，慢慢发现，其实我们之前在意的并不是那么重要, 我们也只是在几种平凡的角色上折腾一生.","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}]},{"title":"RCNN","date":"2020-06-02T14:55:57.000Z","path":"wk/算法/003.图像识别/OCR/001.RCNN目标检测/","text":"RCNN (Region CNN)region 区域, 行政区, 范围 一. 速度经典的目标检测算法 使用滑动窗法依次判断所有可能的区域。(大概判断多少个?) RCNN 则预先提取一系列较可能是物体的候选区域，之后仅在这些候选区域上提取特征，进行判断。 二. RCNN 训练集经典的目标检测算法 在区域中提取人工设定的特征（Haar，HOG）. RCNN 则需要训练深度网络进行特征提取.可供使用的有两个数据库： 一个较大的识别库（ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。 一个较小的检测库（PASCAL VOC 2007）：标定每张图片中，物体的类别和位置。一万图像，20类。 使用识别库进行预训练，而后用检测库调优参数。最后在检测库上评测。 三. 流程RCNN算法分为4个步骤 一张图像生成1K~2K个候选区域 对每个候选区域，使用深度网络提取特征 特征送入每一类的SVM 分类器，判别是否属于该类 使用回归器精细修正候选框位置 1. 候选区域生成Selective Search方法.从一张图像生成约2000-3000个候选区域。 思路如下： 123- 使用一种过分割手段，将图像分割成小区域- 查看现有小区域，合并可能性最高的两个区域。重复直到整张图像合并成一个区域位置- 输出所有曾经存在过的区域，所谓候选区域 2. 特征提取 预处理 归一化： 使用深度网络提取特征之前, 首先把候选区域归一化成同一尺寸227×227. 预训练 基本借鉴Hinton 2012年在Image Net上的分类网络2，略作简化3。 此网络提取的特征为4096维，之后送入一个4096-&gt;1000的全连接(fc)层进行分类。学习率0.01。 训练数据 使用ILVCR 2012的全部数据进行训练，输入一张图片，输出1000维的类别标号。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"OCR","slug":"算法/003-图像识别/OCR","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/OCR/"}]},{"title":"PSENet","date":"2020-06-02T14:55:57.000Z","path":"wk/算法/003.图像识别/OCR/002.PSENet目标检测/","text":"psenet作为一种基于分割的方法，能够对任意形状的文本进行定位.其次，该模型提出了一种渐进的尺度扩展算法，该算法可以成功地识别相邻文本实例（该算法在下文会详细介绍）。 YOLO、CTPN、PSENet比较YOLO和CTPN的检测速度较快，PSENet的检测速度稍慢，YOLO对于长文本或短文本的很容易出现缺损或丢失的情况，CPTN在长短文本方面效果好一些，但是文本对齐效果不理想，PSENet在检测效果方面是碾压了前两者的。PSENet不仅适应任意角度的文本检测，而且对近距离文本分割效果更好。 PSENetProgression Scale Expansion Network. (渐进式规模扩展网络) Overall Pipeline","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"OCR","slug":"算法/003-图像识别/OCR","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/OCR/"}]},{"title":"002.重新开启wsl后 k8s集群恢复.","date":"2020-05-19T05:13:34.000Z","path":"wk/MicroService/容器云平台/002.重启wsl后的k8s集群恢复/","text":"ps -ef | grep docker. 删除 docker 相关进程. 不然docker没法启动. 如果还不行，则： rm -rf /var/run/docker* 重启集群 wslk8s. 打开dashboard. 12345678kind delete cluster --name wslk8skind create cluster --name wslk8s# dashboardkubectl apply -f recommended.yaml# 获取 dashboard 的资源对象(验证)kubectl get all -n kubernetes-dashboard 确保docker启动正常. 重启 12kind delete cluster --name wslk8skind create cluster --name wslk8s 查看集群 1kubectl cluster-info --context kind-wslk8s 使用 kubectl proxy —port=8015 &amp; 后台开启dashboard. http://127.0.0.1:8015/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/workloads?namespace=default 4.部署容器化应用","tags":[{"name":"k8s","slug":"k8s","permalink":"https://quano.gitee.io/tags/k8s/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"容器云平台","slug":"MicroService/容器云平台","permalink":"https://quano.gitee.io/categories/MicroService/%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0/"}]},{"title":"minikube使用","date":"2020-05-19T05:13:34.000Z","path":"wk/MicroService/容器云平台/003.minikube使用/","text":"1. 安装curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube 2. 启动minikube start —force —driver=docker 3. dashboardminikube dashboardeval $(minikube docker-env) 或者 后端启动. kubectl proxy —port=8017 &amp;","tags":[{"name":"k8s","slug":"k8s","permalink":"https://quano.gitee.io/tags/k8s/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"容器云平台","slug":"MicroService/容器云平台","permalink":"https://quano.gitee.io/categories/MicroService/%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0/"}]},{"title":"nfs-server部署","date":"2020-05-19T05:13:34.000Z","path":"wk/MicroService/容器云平台/004.nfs-server部署/","text":"使用docker镜像搭建 nfs-server服务.docker run -d —restart=always —privileged -v /mnt/d/DockerData/nfs01:/nfs -e NFS_EXPORT_DIR_1=/nfs -e NFS_EXPORT_DOMAIN_1=* -e NFS_EXPORT_OPTIONS_1=rw,insecure,no_subtree_check,no_root_squash,fsid=1 -p 111:111 -p 111:111/udp -p 2049:2049 -p 2049:2049/udp -p 32765:32765 -p 32765:32765/udp -p 32766:32766 -p 32766:32766/udp -p 32767:32767 -p 32767:32767/udp fuzzle/docker-nfs-server:latest 验证","tags":[{"name":"k8s","slug":"k8s","permalink":"https://quano.gitee.io/tags/k8s/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"容器云平台","slug":"MicroService/容器云平台","permalink":"https://quano.gitee.io/categories/MicroService/%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0/"}]},{"title":"K8S的StorageClass实战(NFS)","date":"2020-05-19T05:13:34.000Z","path":"wk/MicroService/容器云平台/005.K8S的StorageClass实战/","text":"K8S的StorageClass实战(NFS) 在K8S环境，当pod需要存储空间时，StorageClass比PV更灵活和方便，官方文档地址 依赖nfs. 先暂停. hbase 还是使用pv吧.","tags":[{"name":"k8s","slug":"k8s","permalink":"https://quano.gitee.io/tags/k8s/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"容器云平台","slug":"MicroService/容器云平台","permalink":"https://quano.gitee.io/categories/MicroService/%E5%AE%B9%E5%99%A8%E4%BA%91%E5%B9%B3%E5%8F%B0/"}]},{"title":"Python环境Anaconda","date":"2020-05-19T05:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/002.python环境Anaconda/","text":"AnacondaAnaconda是一个可用于科学计算的Python发行版. [Python]Anaconda安装和使用指南 清华大学开源软件镜像站 Miniconda一个 Anaconda 的轻量级替代.默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。 下载地址:清华镜像站 选择了 Miniconda3-py37_4.8.2-MacOSX-x86_64.pkg 安装的程序路径在 /opt/miniconda3/lib/python3.7. 相关python的依赖也是在此路径下。 使用安装完成默认 配置了bash_profile。 所以重新打开下终端即刻引入环境。 可以使用 conda 命令。 activate. pip 模式是 p3. conda的安装与使用 1. 添加频道conda config —add channels conda config —set show_channel_urls yes 2. 删除频道conda config —remove channels 2. 创建conda环境conda create -n python2 python=2 -n: 设置新的环境的名字python=2 指定新环境的python的版本conda create -n ocr python=3.6 3. 进入环境查看环境conda info —envs 进入环境conda activate ocr或者 source activate ocr 删除环境conda remove -n py36 —all 4. 退出环境conda deactivate","tags":[{"name":"python","slug":"python","permalink":"https://quano.gitee.io/tags/python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://quano.gitee.io/tags/Anaconda/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Python环境Anaconda","date":"2020-05-19T05:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/005.react项目搭建/","text":"node 版本选择 15.0.1 sudo n 15.0.1 React—-使用react脚手架搭建项目","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://quano.gitee.io/tags/nodejs/"},{"name":"react","slug":"react","permalink":"https://quano.gitee.io/tags/react/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Win10系统WSL2的ubuntu子系统安装docker、nvidia-docker","date":"2020-05-19T05:13:34.000Z","path":"wk/算法/001.机器学习/001.工作环境/win环境/001.win10子系统nvidia-docker/","text":"wslwin10的子系统安装条件： 登录windows账户并升级windows至预览版本。 大概1-2小时. 安装nvida驱动https://developer.nvidia.com/cuda/wsl 选择了 Miniconda3-py37_4.8.2-MacOSX-x86_64.pkg 确认需要开启的系统功能开启子系统功能 安装WSL2安装cuda. 重点1apt-get install -y cuda-toolkit-11-0 或者12wget http://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda_11.0.2_450.51.05_linux.runsudo sh cuda_11.0.2_450.51.05_linux.runCUDA Toolkit 11.0 Download NVIDIA CUDA Toolkit 11.0 安装与卸载(Linux/Ubuntu) 验证1nvcc -V 12345nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2020 NVIDIA CorporationBuilt on Thu_Jun_11_22:26:38_PDT_2020Cuda compilation tools, release 11.0, V11.0.194Build cuda_11.0_bu.TC445_37.28540450_0 apt-get install nvidia-docker2:amd64=2.5.0-1 \\ libnvidia-container-tools:amd64=1.3.3-1 \\ nvidia-container-runtime:amd64=3.4.2-1 \\ libnvidia-container1:amd64=1.3.3-1 \\ nvidia-container-toolkit:amd64=1.4.2-1 Windows系统WSL2 的ubuntu子系统安装 docker、nvidia-docker调用GPU 需要注册nvidia 账号 下载最新版 cuda Toolkit. 11.4for WSL-Ubuntu. CUDA Toolkit 11.4 Update 1 Downloads 卸载cuda toolkitcd /usr/local/cuda-11.0/bin/sudo ./cuda-uninstallersudo rm -rf /usr/local/cuda-11.0 测试 nvidia-container1sudo nvidia-container-cli -k -d /dev/tty info 安装 合适系统的 nvidia驱动.nvidia 1NVIDIA-SMI 471.96 Driver Version: 471.96 CUDA Version: 11.4 CUDA与Driver的对应版本 总结win预览版本有bug. 还是用双系统 或者等wsl稳定后再使用. 升级Win10 安装ubuntu子系统、docker、nvidia-docker 多cuda版本切换. （tensorflow 不同版本对cuda版本的要求不同）10.2 https://developer.nvidia.com/cuda-10.2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1804&amp;target_type=runfilelocal 以上链接包含了详细步骤 环境设置 123456重要： nvcc -V. 是通过这个路径找cuda版本. 所以以下这个必须设置export PATH=/usr/local/cuda/bin:$PATHexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-10.2/lib64export PATH=$PATH:/usr/local/cuda-10.2/binexport CUDA_HOME=$CUDA_HOME:/usr/local/cuda-10.2 【CUDA】nvcc和nvidia-smi显示的版本不一致？ 1234sudo apt-get install -y --no-install-recommends libnvinfer6=6.0.1-1+cuda10.2 \\ libnvinfer-dev=6.0.1-1+cuda10.2 \\ libnvinfer-plugin6=6.0.1-1+cuda10.2 123# 验证 gpu tensorflowimport tensorflow as tfprint(tf.test.is_gpu_available())","tags":[{"name":"python","slug":"python","permalink":"https://quano.gitee.io/tags/python/"},{"name":"Docker","slug":"Docker","permalink":"https://quano.gitee.io/tags/Docker/"},{"name":"GPU","slug":"GPU","permalink":"https://quano.gitee.io/tags/GPU/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"001.工作环境","slug":"算法/001-机器学习/001-工作环境","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001-%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"},{"name":"win环境","slug":"算法/001-机器学习/001-工作环境/win环境","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/001-%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/win%E7%8E%AF%E5%A2%83/"}]},{"title":"LockSupport","date":"2020-05-10T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/多线程/002.LockSupport/","text":"浅谈Java并发编程系列（八）—— LockSupport原理剖析 LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞。 LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。 需要特别注意的一点：park 方法还可以在其他任何时间“毫无理由”地返回，因此通常必须在重新检查返回条件的循环里调用此方法。从这个意义上说，park 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 unpark 配对使用才更高效。 自旋 permit 许可 TODO Java 中的 Monitor 机制","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"多线程","slug":"平台工具/程序语言/Java/多线程","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"理解神经网络","date":"2020-04-02T14:55:57.000Z","path":"wk/算法/001.机器学习/神经网络/002.理解神经网络/","text":"神经网络浅讲：从神经元到深度学习 从神经元到RNN\\CNN\\深度学习 反向传播算法的启示是数学中的链式法则。在此需要说明的是，尽管早期神经网络的研究人员努力从生物学中得到启发，但从BP算法开始，研究者们更多地从数学上寻求问题的最优解。不再盲目模拟人脑网络是神经网络研究走向成熟的标志。正如科学家们可以从鸟类的飞行中得到启发，但没有必要一定要完全模拟鸟类的飞行方式，也能制造可以飞天的飞机。 优化问题只是训练中的一个部分。机器学习问题之所以称为学习问题，而不是优化问题，就是因为它不仅要求数据在训练集上求得一个较小的误差，在测试集上也要表现好。因为模型最终是要部署到没有见过训练数据的真实场景。提升模型在测试集上的预测效果的主题叫做泛化（generalization），相关方法被称作正则化（regularization）。神经网络中常用的泛化技术有权重衰减等。 多层感知机(两层神经网络)存在的问题 一次神经网络的训练耗时太久 困扰训练优化的一个问题就是局部最优解问题 隐藏层的节点数需要调参，这使得使用不太方便，工程和研究人员对此多有抱怨 90年代中期，由Vapnik等人发明的SVM（Support Vector Machines，支持向量机）算法诞生，很快就在若干个方面体现出了对比神经网络的优势：无需调参；高效；全局最优解。基于以上种种理由，SVM迅速打败了神经网络算法成为主流。 多层神经网络（深度学习）2006年，Hinton在《Science》和相关期刊上发表了论文，首次提出了“深度信念网络”的概念 与传统的训练方式不同，“深度信念网络”有一个“预训练”（pre-training）的过程，这可以方便的让神经网络中的权值找到一个接近最优解的值.之后再使用“微调”(fine-tuning)技术来对整个网络进行优化训练。这两个技术的运用大幅度减少了训练多层神经网络的时间。他给多层神经网络相关的学习方法赋予了一个新名词—“深度学习”。 训练 在单层神经网络时，我们使用的激活函数是sgn函数。到了两层神经网络时，我们使用的最多的是sigmoid函数。而到了多层神经网络时，通过一系列的研究发现，ReLU函数在训练多层神经网络时，更容易收敛，并且预测性能更好。因此，目前在深度学习中，最流行的非线性函数是ReLU函数。ReLU函数不是传统的非线性函数，而是分段线性函数。其表达式非常简单，就是y=max(x,0)。简而言之，在x大于0，输出就是输入，而在x小于0时，输出就保持为0。这种函数的设计启发来自于生物神经元对于激励的线性响应，以及当低于某个阈值后就不再响应的模拟。 下面来讨论一下隐藏层的节点数设计。在设计一个神经网络时，输入层的节点数需要与特征的维度匹配，输出层的节点数要与目标的维度匹配。而中间层的节点数，却是由设计者指定的。因此，“自由”把握在设计者的手中。但是，节点数设置的多少，却会影响到整个模型的效果。如何决定这个自由层的节点数呢？目前业界没有完善的理论来指导这个决策。一般是根据经验来设置。较好的方法就是预先设定几个可选值，通过切换这几个值来看整个模型的预测效果，选择效果最好的值作为最终选择。这种方法又叫做Grid Search（网格搜索）。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"神经网络","slug":"算法/001-机器学习/神经网络","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"卷积神经网络","date":"2020-04-02T14:55:57.000Z","path":"wk/算法/001.机器学习/神经网络/003.卷积神经网络/","text":"推荐的学习blog视频ng的 B站:卷积神经网络 CNN 数学中的卷积:考研数学 blog重点推荐文章: 卷积神经网络(CNN)模型结构","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"神经网络","slug":"算法/001-机器学习/神经网络","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"OCR项目学习","date":"2020-04-02T14:55:57.000Z","path":"wk/算法/003.图像识别/OCR/003.OCR项目学习/","text":"文本检测综述：基于深度学习文本检测的十全大补丸 以上是文本检测的一个综述. 下边是基于psenet实现的一个项目 chineseocr_litehttps://github.com/ouyanghuiyu/chineseocr_lite https://github.com/whai362/psenet PSENet论文翻译 CRNN理解文本识别网络CRNN CRNN网络结构详解 1231. CNN（卷积层），使用深度CNN，对输入图像提取特征，得到特征图；2. RNN（循环层），使用双向RNN（BLSTM）对特征序列进行预测，对序列中的每个特征向量进行学习，并输出预测标签（真实值）分布；3. CTC loss（转录层），使用 CTC 损失，把从循环层获取的一系列标签分布转换成最终的标签序列。 1. CNN一共有四个最大池化层.但是最后两个池化层的窗口尺寸由 2x2 改为 1x2，也就是图片的高度减半了四次（除以 [公式] ），而宽度则只减半了两次（除以 [公式] ），这是因为文本图像多数都是高较小而宽较长.所以其feature map也是这种高小宽长的矩形形状，如果使用1×2的池化窗口可以尽量保证不丢失在宽度方向的信息，更适合英文字母识别（比如区分i和l）. CRNN 还引入了BatchNormalization模块，加速模型收敛，缩短训练过程。 输入图像为灰度图像（单通道）；高度为32，这是固定的，图片通过 CNN 后，高度就变为1，这点很重要；宽度为160，宽度也可以为其他的值，但需要统一，所以输入CNN的数据尺寸为 (channel, height, width)=(1, 32, 160) 2. Map-to-Sequence我们是不能直接把 CNN 得到的特征图送入 RNN 进行训练的，需要进行一些调整，根据特征图提取 RNN 需要的特征向量序列。 3. RNN完全解析RNN, Seq2Seq, Attention注意力机制 循环神经网络RNN结构.被广泛应用于自然语言处理、机器翻译、语音识别、文字识别等方向. 在此项目中,Recurrent Layers 是一个深层双向LSTM网络.在卷积特征的基础上继续提取文字序列特征. 所谓深层RNN网络，是指超过两层的RNN网络 长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN.主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。 anglenet","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"OCR","slug":"算法/003-图像识别/OCR","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/OCR/"}]},{"title":"1.窗口篇(一)","date":"2020-03-20T03:55:57.000Z","path":"wk/数据/数据处理/Flink/flink技术点/1.窗口篇-1/","text":"数据分析实践 | flink | window窗口篇 滚动窗口: FlinkSql资料 01 数据处理前的分流窗口在处理数据前，会对数据做分流，有两种控制流的方式。 也就是按照原始数据流中的某个key进行分类，拥有同一个key值的数据流将为进入同一个window，多个窗口并行的逻辑流 02 窗口函数的准备对于每个window必备的是触发器Trigger和一个附加在window上的函数 ProcessWindowFunction ReduceFunction AggregateFunction FoldFunction 用于实现window中对数据流的操作. 在对数据流做处理前，需要先预设一些窗口的配置，先看一下窗口的一些类型: 1. 划分 time 根据时间划分时间类型： EventTime 数据本身携带的时间 ProcessingTime 处理时间 count 根据数据量划分窗口 2. 属性 size=interval 无重叠数据,可理解为翻滚窗口， size&gt;interval 有重叠数据，可理解为滑动窗口 于是一共有这几个窗口类型 无重叠时间窗口 有重叠时间窗口 有重叠数据窗口 无重叠数据窗口 实际场景中用的较多的还是时间窗口，以时间窗口为例。 3. 时间窗口声明使用的窗口时间类型. 选择完时间类型之后，我们优先挑选最复杂的一种情况来说明时间戳和水位线的工作机制，如果选择了EventTime，需要指定数据流中的时间戳。 时间戳分配与生成水印密切相关，水印告诉系统事件时间的进展。决定水位线的高度。 4. 水位线Watermark通常在处理EventTime事件时间的时候使用，流式传输程序需要相应地设置时间特性。数据流的到达顺序我们无法保证的情况下，需要对迟到的数据进行处理，Periodic水位线便是配置这个特性。AssignerWithPeriodicWatermarks分配时间戳并定期生成水印 03 窗口函数窗口函数是触发器在确认窗口数据到达完毕后，执行的函数。 AggerateFunction/ReduceFunction/FoldFunction/… 此类为数据计算函数，适用于仅计算，无需做时间窗口的情况。AggerateFunction为用户自定义函数，可以按照个人需求做各类统计。 WindowFunction/ProcessWindowFunction/…此类为做窗口函数，适用于无需计算只做时间窗口统计的情况。（ps.貌似很少有这样的情况猴）","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink技术点","slug":"数据/数据处理/Flink/flink技术点","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"1.窗口篇(二)","date":"2020-03-20T03:55:57.000Z","path":"wk/数据/数据处理/Flink/flink技术点/2.窗口篇-2/","text":"123456789101112131415161718192021222324/** * Base interface for functions that are evaluated over keyed (grouped) windows. * * @param &lt;IN&gt; The type of the input value. * @param &lt;OUT&gt; The type of the output value. * @param &lt;KEY&gt; The type of the key. * @param &lt;W&gt; The type of &#123;@code Window&#125; that this window function can be applied on. */@Publicpublic interface WindowFunction&lt;IN, OUT, KEY, W extends Window&gt; extends Function, Serializable &#123; /** * Evaluates the window and outputs none or several elements. * * @param key The key for which this window is evaluated. * @param window The window that is being evaluated. * @param input The elements in the window being evaluated. * @param out A collector for emitting elements. * * @throws Exception The function may throw exceptions to fail the program and trigger recovery. */ void apply(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out) throws Exception;&#125; 通过窗口触发器产生一个窗口后，使用 WindowFunction 对窗口进行处理 1234.keyBy(ActionEntity::getIp) // 设置处理时间滑动窗口：窗口长度为30s，步长5s .timeWindow(Time.seconds(60),Time.seconds(10))","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink技术点","slug":"数据/数据处理/Flink/flink技术点","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"2.水位线(watermark)","date":"2020-03-20T03:55:57.000Z","path":"wk/数据/数据处理/Flink/flink技术点/3.水位线/","text":"watermark（水位线）简介 问题：基于processTime 做一些处理的时候，比如统计，1分钟内 如果处理过快，那统计就不准确。 01 什么是水位线watermark是一种衡量EventTime进展的机制，它是数据本身的一个隐藏属性. 什么含义呢，表示水位线时间的数据都已经到达了. 02 watermark有什么用？watermark是用于处理乱序事件的，而正确的处理乱序事件，通常用watermark机制结合window来实现。 03 watermark如何分配？第一种可以定义一个最大允许乱序的时间，这种情况应用较多。 速度收藏！看完这份知识图谱，才算搞懂 Flink！ Flink-Table-&amp;-SQL 基于 Flink 构建 CEP 引擎的挑战和实践 Flink-cep 动态改变规则案例","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"},{"name":"flink技术点","slug":"数据/数据处理/Flink/flink技术点","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/flink%E6%8A%80%E6%9C%AF%E7%82%B9/"}]},{"title":"Influxdb环境搭建","date":"2020-03-18T09:10:49.000Z","path":"wk/平台工具/工具组件/Influxdb/Influxdb环境搭建/","text":"1234docker run -d -p 8083:8083 -p8086:8086 --expose 8090 --expose 8099 --name influxsrv tutum/influxdb## docker run -d -p 8083:8083 -p8086:8086 --expose 8090 --expose 8099 --name influxsrv influxdb influxdb操作 influxdb 操作.CREATE RETENTION POLICY “hummer-metric” ON “app-metric” DURATION 60d REPLICATION 1 DEFAULT","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Influxdb","slug":"平台工具/工具组件/Influxdb","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Influxdb/"}]},{"title":"正则表达式","date":"2020-03-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/正则表达式/001.常用正则/","text":"正则表达式之数字 一张思维导图，让正则表达式不再难懂","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"正则表达式","slug":"平台工具/程序语言/Java/正则表达式","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"KafkaConsumer为何使用pull模式","date":"2020-03-01T05:55:57.000Z","path":"wk/数据/数据处理/DataStore/Kafka/kafka设计解析/1.KafkaConsumer为何使用pull模式/","text":"kafka的作用：数据管道和消息系统 130681 | 涿州市130684 | 高碑店市130208 | 丰润区120119 | 蓟州区120225 | 蓟县450100 | 南宁市120118 | 静海区120114 | 武清区451300 | 来宾市450500 | 北海市130900 | 沧州市131000 | 廊坊市420600 | 襄阳市","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"},{"name":"kafka设计解析","slug":"数据/数据处理/DataStore/Kafka/kafka设计解析","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/kafka%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90/"}]},{"title":"rocksdb源码环境配置","date":"2020-02-27T17:13:34.000Z","path":"wk/平台工具/程序语言/C++/[重点]开发环境/VScode开发环境搭建/","text":"使用VSCode+CMake开发C++ 优点 多平台几乎相同的使用体验，除了部分快捷键不一样。 非常轻量，启动速度很快。 强大的扩展功能，C++与CMake Tools都是扩展。 内置终端，来回切换很方便。 缺点 IntelliSense不如VS的好用，经常找不到符号，需要重新解析文件。相比于VS2019原生支持CMake，体验差很多。 Mac下不支持”Jump to Cursor”，而Xcode支持这个功能。对于调试还是有些不方便。 配合CMake ToolsCMake主要使用settings.json配置文件，以往需要手动输入的命令、传递的参数都可以写在这个文件里。在配置文件中传递参数在cmake.configureSettings中设置参数，相当于传入了-D+参数给CMake。也可以使用cmake.configureArgs，但是官方不推荐。 在配置文件中设置环境变量有3个字段可以设置：cmake.configureEnvironment: 仅用于CMake配置阶段cmake.buildEnvironment: 仅用于编译阶段cmake.environment: 同时用于CMake配置与编译阶段为Debug/Release设置不同环境变量可以通过CMake Variants实现，在buildType这个variant中分别在Debug/Release的env字段中设置。构建不同配置的目标文件还是用CMake Variants，创建一个新的variant设置不同的配置。这个variant会与其它variant排列组合生成很多kit。","tags":[{"name":"rocksdb源码","slug":"rocksdb源码","permalink":"https://quano.gitee.io/tags/rocksdb%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"[重点]开发环境","slug":"平台工具/程序语言/C/重点-开发环境","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/%E9%87%8D%E7%82%B9-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]},{"title":"C++环境常见问题","date":"2020-02-27T17:13:34.000Z","path":"wk/平台工具/程序语言/C++/开发环境问题/1.常见问题/","text":"包含路径问题比如 找不到jni.h 头文件. 点击右下角的 c/c++ Configurations. 配置包含路径参数。 cmake安装(mac)https://cmake.org/download/ 安装完成后，使用以下指令创建/usr/local/bin下 CMake 的软链接。 1sudo &quot;/Applications/CMake.app/Contents/bin/cmake-gui&quot; --install 参考： https://www.jianshu.com/p/7466c85d5d6b cmake安装(linux)直接下载可执行文件， 配置环境变量即可。","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"开发环境问题","slug":"平台工具/程序语言/C/开发环境问题","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"}]},{"title":"vagrant","date":"2020-02-27T17:13:34.000Z","path":"wk/平台工具/程序语言/C++/开发环境问题/2.vagrant/","text":"https://www.jianshu.com/p/3087304fa3a5 虚拟机管理 12345678910111213141516171819202122232425262728// 启动vagrant up// 停止vagrant halt// 使用ssh连接vagrant ssh// 安装Apach服务器sudo yum install httpd// 启动服务器[vagrant@localhost ~]$ sudo service httpd startexit// 暂停虚拟机vagrant suspend// 恢复虚拟机vagrant resume// 重启vagrant reload// 销毁vagrant destroy 列一下改造计划。","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"开发环境问题","slug":"平台工具/程序语言/C/开发环境问题","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"}]},{"title":"rocksdb源码环境配置","date":"2020-02-27T17:13:34.000Z","path":"wk/平台工具/程序语言/C++/rocksdb源码学习/001.环境配置问题/","text":"jni.h 增加jdk的 jni路径到项目汇总。 问题. rocksdbjni 目录下的 .cc 文件找不到 .h 头文件. 比如：#include “include/org_rocksdb_CompactionJobStats.h” include “include/org_rocksdb_StringAppendOperator.h” 等. 找不到这些头文件？did not match “(GNU assembler)|(GCC)|(Free Software Foundation)”:无论是打开环境 还是编译 snappy 的时候， 都出现这个问题。 应该是 clang环境配置(mac)的问题。 在 snappy-1.1.7/build 目录下执行 cmake ../ 的时候出现的. 可能需要通过修改 cmakeFile 解决这个问题 clang 编译发布可用jarmake rocksdbjavastaticrelease 其中使用了 vagrant. (建议使用linux编译. 然后apt直接安装)","tags":[{"name":"rocksdb源码","slug":"rocksdb源码","permalink":"https://quano.gitee.io/tags/rocksdb%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"rocksdb源码学习","slug":"平台工具/程序语言/C/rocksdb源码学习","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/rocksdb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}]},{"title":"Merge源码解析","date":"2020-02-27T17:13:34.000Z","path":"wk/平台工具/程序语言/C++/rocksdb源码学习/merge操作/","text":"12345678910111213141516171819202122232425262728293031323334struct MergeOperationInput &#123;explicit MergeOperationInput(const Slice&amp; _key, const Slice* _existing_value, const std::vector&lt;Slice&gt;&amp; _operand_list, Logger* _logger) : key(_key), existing_value(_existing_value), operand_list(_operand_list), logger(_logger) &#123;&#125;// The key associated with the merge operation.const Slice&amp; key;// The existing value of the current key, nullptr means that the// value doesn&#x27;t exist.const Slice* existing_value;// A list of operands to apply.const std::vector&lt;Slice&gt;&amp; operand_list;// Logger could be used by client to log any errors that happen during// the merge operation.Logger* logger;&#125;;struct MergeOperationOutput &#123;explicit MergeOperationOutput(std::string&amp; _new_value, Slice&amp; _existing_operand) : new_value(_new_value), existing_operand(_existing_operand) &#123;&#125;// Client is responsible for filling the merge result here.std::string&amp; new_value;// If the merge result is one of the existing operands (or existing_value),// client can set this field to the operand (or existing_value) instead of// using new_value.Slice&amp; existing_operand;&#125;; 问题: 首先要明白这两个参数类是干嘛的. 其中的参数是在哪一步定义和初始化的. sortlist.ccsortlist 中 merge的实现. 1234567891011121314bool SortList::FullMergeV2(const MergeOperationInput&amp; merge_in, MergeOperationOutput* merge_out) const &#123; std::vector&lt;int&gt; left; for (Slice slice : merge_in.operand_list) &#123; std::vector&lt;int&gt; right; MakeVector(right, slice); left = Merge(left, right); &#125; for (int i = 0; i &lt; static_cast&lt;int&gt;(left.size()) - 1; i++) &#123; merge_out-&gt;new_value.append(std::to_string(left[i])).append(&quot;,&quot;); &#125; merge_out-&gt;new_value.append(std::to_string(left.back())); return true;&#125; db_range_del_test.ccMockMergeOperator 模拟测试merge. 12345678910111213class MockMergeOperator : public MergeOperator &#123; // Mock non-associative operator. Non-associativity is expressed by lack of // implementation for any `PartialMerge*` functions. public: bool FullMergeV2(const MergeOperationInput&amp; merge_in, MergeOperationOutput* merge_out) const override &#123; assert(merge_out != nullptr); merge_out-&gt;new_value = merge_in.operand_list.back().ToString(); return true; &#125; const char* Name() const override &#123; return &quot;MockMergeOperator&quot;; &#125;&#125;; new_value 指向operand_list的尾元素. c.cc这个也可以借鉴下. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687struct rocksdb_mergeoperator_t : public MergeOperator &#123; void* state_; void (*destructor_)(void*); const char* (*name_)(void*); char* (*full_merge_)( void*, const char* key, size_t key_length, const char* existing_value, size_t existing_value_length, const char* const* operands_list, const size_t* operands_list_length, int num_operands, unsigned char* success, size_t* new_value_length); char* (*partial_merge_)(void*, const char* key, size_t key_length, const char* const* operands_list, const size_t* operands_list_length, int num_operands, unsigned char* success, size_t* new_value_length); void (*delete_value_)( void*, const char* value, size_t value_length); ~rocksdb_mergeoperator_t() override &#123; (*destructor_)(state_); &#125; const char* Name() const override &#123; return (*name_)(state_); &#125; bool FullMergeV2(const MergeOperationInput&amp; merge_in, MergeOperationOutput* merge_out) const override &#123; size_t n = merge_in.operand_list.size(); std::vector&lt;const char*&gt; operand_pointers(n); std::vector&lt;size_t&gt; operand_sizes(n); for (size_t i = 0; i &lt; n; i++) &#123; Slice operand(merge_in.operand_list[i]); operand_pointers[i] = operand.data(); operand_sizes[i] = operand.size(); &#125; const char* existing_value_data = nullptr; size_t existing_value_len = 0; if (merge_in.existing_value != nullptr) &#123; existing_value_data = merge_in.existing_value-&gt;data(); existing_value_len = merge_in.existing_value-&gt;size(); &#125; unsigned char success; size_t new_value_len; char* tmp_new_value = (*full_merge_)( state_, merge_in.key.data(), merge_in.key.size(), existing_value_data, existing_value_len, &amp;operand_pointers[0], &amp;operand_sizes[0], static_cast&lt;int&gt;(n), &amp;success, &amp;new_value_len); merge_out-&gt;new_value.assign(tmp_new_value, new_value_len); if (delete_value_ != nullptr) &#123; (*delete_value_)(state_, tmp_new_value, new_value_len); &#125; else &#123; free(tmp_new_value); &#125; return success; &#125; bool PartialMergeMulti(const Slice&amp; key, const std::deque&lt;Slice&gt;&amp; operand_list, std::string* new_value, Logger* /*logger*/) const override &#123; size_t operand_count = operand_list.size(); std::vector&lt;const char*&gt; operand_pointers(operand_count); std::vector&lt;size_t&gt; operand_sizes(operand_count); for (size_t i = 0; i &lt; operand_count; ++i) &#123; Slice operand(operand_list[i]); operand_pointers[i] = operand.data(); operand_sizes[i] = operand.size(); &#125; unsigned char success; size_t new_value_len; char* tmp_new_value = (*partial_merge_)( state_, key.data(), key.size(), &amp;operand_pointers[0], &amp;operand_sizes[0], static_cast&lt;int&gt;(operand_count), &amp;success, &amp;new_value_len); new_value-&gt;assign(tmp_new_value, new_value_len); if (delete_value_ != nullptr) &#123; (*delete_value_)(state_, tmp_new_value, new_value_len); &#125; else &#123; free(tmp_new_value); &#125; return success; &#125;&#125;; 最后list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class ListMergeOperator : public rocksdb::MergeOperator &#123;private: size_t max_val;public: ListMergeOperator(size_t max_val): max_val(max_val) &#123; &#125; virtual ~ListMergeOperator() &#123;&#125; bool FullMergeV2(const MergeOperationInput &amp;merge_in, MergeOperationOutput *merge_out) const &#123; merge_out-&gt;new_value.clear(); // Compute the space needed for the final result. size_t numBytes = 0; for (auto &amp;s : merge_in.operand_list) &#123; numBytes += s.size() + rocksdb::VarintLength(s.size());#ifndef NDEBUG if (merge_in.existing_value) &#123; listdb::log_debug(&quot;FullMergeV2, exits %s, %s, total bytes %d&quot;, merge_in.existing_value-&gt;data(), s.data(), numBytes); &#125; else &#123; listdb::log_debug(&quot;FullMergeV2, no exits, %s, total bytes %d&quot;, s.data(), numBytes); &#125;#endif &#125; if (merge_in.existing_value) &#123; merge_out-&gt;new_value.reserve(numBytes + merge_in.existing_value-&gt;size()); merge_out-&gt;new_value.append(merge_in.existing_value-&gt;data(), merge_in.existing_value-&gt;size()); &#125; else &#123; merge_out-&gt;new_value.reserve(numBytes); &#125; for (auto &amp;s: merge_in.operand_list) &#123; // encode list item as: size + data rocksdb::PutVarint32(&amp;merge_out-&gt;new_value, (uint32_t) s.size()); // put size merge_out-&gt;new_value.append(s.data_, s.size()); &#125; if (max_val &gt; 0 &amp;&amp; merge_out-&gt;new_value.size() &gt; max_val) &#123; // 超过了大小限制， 去掉前面的 size_t to_ignore = merge_out-&gt;new_value.size() - max_val; auto p = merge_out-&gt;new_value.data(), start = merge_out-&gt;new_value.data(), end = merge_out-&gt;new_value.data() + merge_out-&gt;new_value.size(); while (p &lt; end) &#123; uint32_t size = 0; auto t = rocksdb::GetVarint32Ptr(p, p + 5, &amp;size); t += size; if (t - start &gt; to_ignore) break; p = t; &#125; listdb::log_debug(&quot;FullMergeV2, trim %d -&gt; %d/%d&quot;, merge_out-&gt;new_value.size(), to_ignore, merge_out-&gt;new_value.size() - (p - start)); if(p != start) merge_out-&gt;new_value = merge_out-&gt;new_value.substr(p - start); &#125;#ifndef NDEBUG if (merge_in.existing_value) &#123; listdb::log_debug(&quot;FullMergeV2, exits %s, get %s %d/%d&quot;, merge_in.existing_value-&gt;data(), merge_out-&gt;new_value.data(), numBytes, merge_out-&gt;new_value.size()); &#125; else &#123; listdb::log_debug(&quot;FullMergeV2, no exits, get %s %d/%d&quot;, merge_out-&gt;new_value.data(), numBytes, merge_out-&gt;new_value.size()); &#125;#endif return true; &#125; bool PartialMerge(const rocksdb::Slice &amp;key, const rocksdb::Slice &amp;left_operand, const rocksdb::Slice &amp;right_operand, std::string *new_value, rocksdb::Logger *logger) const &#123; return false; &#125; const char *Name() const &#123; return &quot;list-merge&quot;; &#125;&#125;;","tags":[{"name":"rocksdb源码","slug":"rocksdb源码","permalink":"https://quano.gitee.io/tags/rocksdb%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"rocksdb源码学习","slug":"平台工具/程序语言/C/rocksdb源码学习","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/rocksdb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ubuntu下nginx安装使用","date":"2020-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/nginx/001.Ubuntu下nginx安装使用/","text":"1234# 默认的nginx配置cat /etc/nginx/sites-available/default # 其中可以找到. 静态资源路径.root /var/www/html; Nginx 配置多站点vhost1.首先保证 /etc/nginx/nginx.conf 中存在以下配置，确保可以多配置. 123456789101112131415http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwa rded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; ＃主要是加入此行，如有则忽略&#125; 2.在 /etc/nginx/conf.d/ 文件夹下添加不同的配置. 12345678910111213141516171819server &#123; listen 80; server_name wiki.quartz.ren; access_log /var/log/wiki.access.log; location / &#123; proxy_pass http://localhost:4000; index index.html index.htm; &#125; error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;# 注: 这里的转发可以是转发到端口,也可以转发到静态资源. 相应的添加其他配置文件. 3.在/etc/hosts添加域名映射. !!! 重要 123127.0.0.1 wiki.quartz.ren127.0.0.1 www.quartz.ren127.0.0.1 santa.quartz.ren 大功告成~ Nginx 映射规则配置Nginx 负载均衡配置Nginx 配置文件详解","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"nginx","slug":"平台工具/工具组件/nginx","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/nginx/"}]},{"title":"网站https支持-Nginx","date":"2020-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/nginx/002.网站https支持-nginx/","text":"证书申请申请免费证书(阿里云吧). 然后下载。 在nginx目录下创建文件夹： /etc/nginx/conf.d/cert 将证书复制到此文件夹. 然后修改conf.d下的wiki.conf 配置文件. 12345678910111213141516171819202122232425262728293031# 以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。server &#123; listen 80; server_name wiki.quartz.ren; access_log /var/log/wiki.access.log; rewrite ^(.*)$ https://$host$1 permanent; error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;server &#123; listen 443 ssl; #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。 server_name wiki.quartz.ren; #将localhost修改为您证书绑定的域名，例如：www.example.com。 root html; index index.html index.htm; ssl_certificate conf.d/cert/3714771_wiki.quartz.ren.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key conf.d/cert/3714771_wiki.quartz.ren.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; root /data/blog/wiki/public_deploy/; index index.html index.htm; &#125;&#125; nginx证书配置","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"nginx","slug":"平台工具/工具组件/nginx","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/nginx/"}]},{"title":"Nginx转发配置","date":"2020-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/nginx/003.Nginx转发配置/","text":"1234567891011121314151617181920212223242526server &#123; listen 443 ssl; #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。 server_name santa.quartz.ren; #将localhost修改为您证书绑定的域名，例如：www.example.com。 root html; index index.html index.htm; ssl_certificate conf.d/cert/3714771_wiki.quartz.ren.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key conf.d/cert/3714771_wiki.quartz.ren.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; # 转发配置内容. location /xboot/ &#123; proxy_pass http://127.0.0.1:8888/xboot/; &#125; location /home/ &#123; proxy_pass http://127.0.0.1:8888/home/; &#125; location / &#123; root /home/zhangquanquan/app/santa-admin-front/dist/; index index.html index.htm; &#125;&#125;","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"nginx","slug":"平台工具/工具组件/nginx","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/nginx/"}]},{"title":"1.指针和引用","date":"2020-02-21T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/1.指针和引用/","text":"指针可以简化一些C++编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。 每一个变量都有一个内存地址，每个内存位置都定义了可使用连字号(&amp;)运算符访问的地址，它表示了在内存中的一个地址。 1234567891011int main()&#123; int var1; chat var2[10]; cout &lt;&lt; &quot;var1 变量的地址：&quot;; cout &lt;&lt; &amp;var1 &lt;&lt; endl; cout &lt;&lt; &quot;var2 变量的地址：&quot;; cout &lt;&lt; &amp;var2 &lt;&lt; endl; return 0;&#125; 通过以上，了解了审核是内存地址以及如何访问它。接下来我们看看什么是指针。 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整形，浮点型，字符型，还是其他数据类型。都是一样的，都是一个代表内存地址的长的十六进制数。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 123456789101112131415161718192021222324#include &lt;iostream&gt; using namespace std; int main ()&#123; int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; &quot;Value of var variable: &quot;; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; &quot;Address stored in ip variable: &quot;; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; &quot;Value of *ip variable: &quot;; cout &lt;&lt; *ip &lt;&lt; endl; return 0;&#125; 1ip = &amp;var 即： &#x27;*ip&#x27; 和 var 的值相等 一. 指针的算数运算指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。 可以对指针进行四种算术运算：++、—、+、-。 C++ 指针的算术运算 int 是4个字节. char是一个字节","tags":[{"name":"C++","slug":"C","permalink":"https://quano.gitee.io/tags/C/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"2.Make命令教程","date":"2020-02-21T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/2.Make命令教程/","text":"Make 命令教程 代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。 Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。 123sudo apt install gcc g++make 安装gcc, g++ 构建工具才能make 构建. Makefile文件的格式构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。 一.概述Makefile文件由一系列规则（rules）构成。每条规则的形式如下。 12&lt;target&gt; : &lt;prerequisites&gt; [tab] &lt;commands&gt; 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。","tags":[{"name":"C++","slug":"C","permalink":"https://quano.gitee.io/tags/C/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"3.虚函数","date":"2020-02-21T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/3.virtual关键字/","text":"C++中virtual关键字的用法 基类的函数调用如果有virtual则根据多态性调用派生类的，如果没有virtual则是正常的静态函数调用，还是调用基类的。 slicen.片；〈非正式〉部分；份额；【体】削球v.切成片；削球；被切成片；(很容易地)切开网络切片；薄片；剖切 rocksdb 的 secondary mode. 不支持merge.","tags":[{"name":"C++","slug":"C","permalink":"https://quano.gitee.io/tags/C/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"4.explict函数","date":"2020-02-21T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/4.explicit关键字/","text":"implicit: 含蓄的,内含的,隐式,隐性explicit: 清楚明白的,显式,直言的 explicit关键字只能用于修饰只有一个参数的类构造函数 它的作用是表明该构造函数是显示的, 而非隐式的 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). 显示声明的构造函数和隐式声明的有什么区别呢??? implicit 默认的构造方法是存在 一个隐式转换的. 例如 CxString string2 = 10; 编译器自动将整型转换为CxString类对象，实际上等同于下面的操作: 1234CxString string2(10); 或 CxString temp(10); CxString string2 = temp; explicit关键字的作用就是防止类构造函数的隐式自动转换.","tags":[{"name":"C++","slug":"C","permalink":"https://quano.gitee.io/tags/C/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"6.C++ vector 容器浅析","date":"2020-02-21T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/6.c++容器浅析/","text":"C++ vector 容器浅析 一个封装了动态大小数组的顺序容器(Sequence Container). 跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 容器特性 顺序序列 动态数组 能够感知内存分配器的（Allocator-aware） 这一点和java的arrayList功能类似. 但感觉比arrayList高效. 虽然还不知道原因. 功能函数比arrayList强大多了.","tags":[{"name":"C++","slug":"C","permalink":"https://quano.gitee.io/tags/C/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"Kafak常用命令","date":"2020-02-14T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Kafka/Kafka常用命令/","text":"命令行消费1bin/kafka-console-consumer.sh --bootstrap-server ip:port --topic $topic 查看group对集群消费情况1bin/kafka-consumer-groups.sh --bootstrap-server ip:port --describe --group $group 重置offset123bin/kafka-consumer-groups.sh --bootstrap-server ip:port --group $group --reset-offsets --all-topics --to-datetime 2019-11-03T00:00:00.000 --execute## --execute 参数会执行生效，不加则只显示结果 topic 创建1bin/kafka-topics.sh --create --zookeeper 192.168.21.179:2181 --topic $topic --partitions 3 --replication-factor 1 查看所有topic1bin/kafka-topics.sh --zookeeper 192.168.21.179:2181 --list 生产消息数据查询分析组件。 走引擎， 不走引擎. 消息路由。 一部分消息 都走。 变量的管理等存在很大的灵活，及不可控。","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"}]},{"title":"Docker镜像站","date":"2020-02-12T03:55:57.000Z","path":"wk/平台工具/工具组件/Docker/10.Docker镜像站/","text":"","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"浏览器插件","date":"2020-02-04T17:13:34.000Z","path":"wk/平台工具/工具组件/IDE/浏览器插件/","text":"json viewhttps://github.com/gildas-lormeau/JSONView-for-Chrome 谷歌浏览器安装json格式化插件","tags":[{"name":"Tools","slug":"Tools","permalink":"https://quano.gitee.io/tags/Tools/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"IDE","slug":"平台工具/工具组件/IDE","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/IDE/"}]},{"title":"启用验证","date":"2020-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mongo/Mongo启动验证/","text":"启用验证 2.1 创建用户管理员账户. 只能对单个数据库授权， 怎么对整体用户授权。 123456789use admin db.createUser( &#123; user: &quot;adminUser&quot;, pwd: &quot;adminPass&quot;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;) 断开 mongodb 连接， 关闭数据库 2.2 Mongodb 用户验证登陆 现在有两种方式进行用户身份的验证 类似 MySql）客户端连接时，指定用户名，密码，db名称 1mongo --port 27017 -u &quot;lyl&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot; 客户端连接后，再进行验证 1234mongo --port 27017 use admindb.auth(&quot;adminUser&quot;, &quot;adminPass&quot;) 创建普通用户创建普通用户过程类似创建管理员账户，只是 role 有所不同 12345678910use foo db.createUser( &#123; user: &quot;simpleUser&quot;, pwd: &quot;simplePass&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;foo&quot; &#125;, &#123; role: &quot;read&quot;, db: &quot;bar&quot; &#125; ] &#125;)","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mongo","slug":"数据/数据处理/DataStore/Mongo","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mongo/"}]},{"title":"01.Mybatis原理","date":"2020-01-20T11:56:24.000Z","path":"wk/MicroService/技术框架/Mybatis/Mybatis原理探索/","text":"查询流程其中的一个UserMapper的实例为： 1com.baomidou.mybatisplus.core.override.MybatisMapperProxy@13250132 动态代理 12345678910111213141516171819202122MybatisMapperProxy implements InvocationHandler&#123; // invoke 方法. @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else if (method.isDefault()) &#123; if (privateLookupInMethod == null) &#123; return invokeDefaultMethodJava8(proxy, method, args); &#125; else &#123; return invokeDefaultMethodJava9(proxy, method, args); &#125; &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; final MybatisMapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125;&#125; 不需要所有的map都写到一个项目中。 kits只是集成了数据访问，方便的数据访问开发。 然后各自的map集成到各自的项目中去。 SqlSession主要是sqlSession操作数据库，增删改查。 实现有SqlSessionTemplate，SqlSessionManager，DefaultSqlSession.","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://quano.gitee.io/tags/Mybatis/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"MicroService/技术框架/Mybatis","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Mybatis/"}]},{"title":"02.动态代理","date":"2020-01-20T11:56:24.000Z","path":"wk/MicroService/技术框架/Mybatis/动态代理/","text":"1.举例工厂，商店和客户。买玩具都是从商店买，工厂怎么生产我们不用关心。 这个工厂可以叫做委托类，商店就是代理类，我们就是客户类。 这样的好处是： 隐藏了委托类的实现。 实现客户与委托类之间的解耦,在不修改委托类代码的情况下能够做一些额外的处理(important) 2.应用场景远程 RPC 调用.通过代理类去实现的. Spring 的 AOP 切面中我们也是为切面生成了一个代理类. 3.静态代理定义接口和接口的实现类，然后定义接口的代理对象。将接口的实例注入到代理对象中, 然后通过代理对象去调用真正的实现类，实现过程非常简单也比较容易理解。 静态代理的代理关系在编译期间就已经确定了的。 4.动态代理技术代理类在程序运行时创建的代理方式被成为 动态代理。 先简回顾一下 JVM 的类加载机制中的加载阶段要做的三件事情： 通过一个类的全名或其它途径来获取这个类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口 我们要说的动态代理，主要就发生在第一个阶段。这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、运行时计算生成、其它文件生成 (JSP)、数据库获取。 其中运行时计算生成就是我们所说的动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 —-$Proxy 的代理类的二进制字节流。 所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进 JVM 中。 实际计算的情况会很复杂，我们借助一些诸如 JDK 动态代理实现、CGLIB 第三方库来完成的. 另一方面为了让生成的代理类与目标对象 (就是委托类) 保持一致, 我们有 2 种做法：通过接口的 JDK 动态代理 和通过继承类的 CGLIB 动态代理 JDK 动态代理在 Java 的动态代理中, 主要涉及 2 个类,java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler. 12345678910public interface InvocationHandler &#123; /** * 调用处理 * @param proxy 代理类对象 * @param methon 标识具体调用的是代理类的哪个方法 * @param args 代理类方法的参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 我们对处理类中的所有方法的调用都会变成对 invoke 方法的调用.这样我们可以在 invoke 方法中添加统一的处理逻辑（也可以根据 method 参数判断是哪个方法） 中间类 (实现了 InvocationHandler 的类) 有一个委托类对象引用, 在 Invoke 方法中调用了委托类对象的相应方法，通过这种聚合的方式持有委托类对象引用，把外部对 invoke 的调用最终都转为对委托类对象的调用。 实际上，中间类与委托类构成了静态代理关系.在这个关系中，中间类是代理类，委托类是委托类。","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://quano.gitee.io/tags/Mybatis/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"MicroService/技术框架/Mybatis","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Mybatis/"}]},{"title":"01.自定义数据源提供者","date":"2020-01-20T11:56:24.000Z","path":"wk/MicroService/技术框架/Mybatis/自定义数据源提供者/","text":"dynamic-datasource-spring-boot-starter Mybatis架构与原理","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://quano.gitee.io/tags/Mybatis/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"MicroService/技术框架/Mybatis","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Mybatis/"}]},{"title":"1.Java基础","date":"2020-01-20T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/Java基础/","text":"Java基础 ：反射、注解、代理、线程池、依赖的学习和理解 结构化思维-如何进行高效表达 世界五大学习方法之西蒙学习法 10个令你变强的网站 廖雪峰的官方网站-Java","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"1.注解的分类","date":"2020-01-20T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/注解/1.注解的分类/","text":"1. 按照运行机制划分 源码注解 编译时注解 运行时注解 源码注解：只在源码中存在，编译成.class文件就不存在了。 编译时注解：在源码和.class文件中都存在。像前面的@Override、@Deprecated、@SuppressWarnings，他们都属于编译时注解。 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。像@Autowired自动注入的这样一种注解就属于运行时注解，它会在程序运行的时候把你的成员变量自动的注入进来。 2. 按照来源划分 来自JDK的注解 来自第三方的注解 自定义注解 3. 元注解元注解是给注解进行注解，可以理解为注解的注解就是元注解。","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"注解","slug":"平台工具/程序语言/Java/注解","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/%E6%B3%A8%E8%A7%A3/"}]},{"title":"2.自定义注解","date":"2020-01-20T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/注解/2.自定义注解/","text":"我们分四步来解析自定义注解 1. 自定义注解的语法要求123456789@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String desc(); String author(); int age() default 18;&#125; String desc();虽然它很类似于接口里面的方法，其实它在注解里面只是一个成员变量（成员以无参无异常的方式声明），int age() default 18;（成员变量可以用default指定一个默认值的） 成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。 如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=） 注解类可以没有成员，没有成员的注解称为标识注解。 2. 元注解1234@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented 我们先看第一行：@Target是这个注解的作用域，ElementType.METHOD是这个注解的作用域的列表，METHOD是方法声明，除此之外，还有：CONSTRUCTOR（构造方法声明）,FIELD（字段声明）,LOCAL VARIABLE（局部变量声明）,METHOD（方法声明）,PACKAGE（包声明）,PARAMETER（参数声明）,TYPE（类接口） 第二行：@Retention是它的生命周期，前面不是说注解按照运行机制有一个分类嘛，RUNTIME就是在运行时存在，可以通过反射读取。除此之外，还有:SOURCE（只在源码显示，编译时丢弃）,CLASS（编译时记录到class中，运行时忽略）,RUNTIME（运行时存在，可以通过反射读取） 第三行：@Inherited是一个标识性的元注解，它允许子注解继承它。 第四行：@Documented，生成javadoc时会包含注解。 3. 注解解析通过反射获取类 、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"注解","slug":"平台工具/程序语言/Java/注解","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/%E6%B3%A8%E8%A7%A3/"}]},{"title":"Zookeeper安装使用指南","date":"2020-01-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Zookeeper/zk安装使用指南/","text":"下载https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/ bin 是可执行的程序。 另外一个是源码文件。 1bin/zkCli.sh -server localhost:2181 查看zk节点数据12","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://quano.gitee.io/tags/zookeeper/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Zookeeper","slug":"平台工具/工具组件/Zookeeper","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Zookeeper/"}]},{"title":"redis性能测试","date":"2020-01-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Redis/性能测试/001.incr性能测试/","text":"redishash increment. single=1000, pipeline=1000001234567StopWatch &#x27;stats&#x27;: running time (millis) = 5730-----------------------------------------ms % Task name-----------------------------------------03732 065% single01998 035% pipeline value increment. single=1000, pipeline=100000123456StopWatch &#x27;stats&#x27;: running time (millis) = 5944-----------------------------------------ms % Task name-----------------------------------------03752 063% single02192 037% pipeline hash 和 value性能差不多.","tags":[{"name":"redis","slug":"redis","permalink":"https://quano.gitee.io/tags/redis/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Redis","slug":"平台工具/工具组件/Redis","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Redis/"},{"name":"性能测试","slug":"平台工具/工具组件/Redis/性能测试","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Redis/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}]},{"title":"Ubuntu安装邮件服务器","date":"2020-01-16T01:56:24.000Z","path":"wk/项目管理/软件工程/Linux/Ubuntu安装邮件服务器/","text":"Ubuntu安装邮件服务器 Ubuntu搭建简易Postfix邮箱服务器—配置域名映射 查看机器开放的端口1sudo nmap your-server-ip 测试发送邮件12345echo &quot;test email&quot; | sendmail your-eamil# 也可以使用mail命令来发送邮件，使用mail发送邮件的时候，main.cf配置文件对其不生效，应该有自己的配置文件，还没找到# mail -s title your-eamil &lt;&lt;&lt; &quot;mail content&quot; AWS Ubuntu 16.04搭建邮件服务器（Postfix+Dovecot+Mysql）","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"邮箱检测","date":"2020-01-13T01:56:24.000Z","path":"wk/项目管理/软件工程/Linux/邮箱检测/","text":"退信查看及分析方法大全 邮箱检测方式和流程 如何验证 Email 地址：SMTP 协议入门教程 MX记录：dns解析中，可以添加一条mx记录. 执行邮箱服务器，然后邮件会投递到这个邮箱服务器. 域名系统（DNS）中的一种资源记录类型,用于指定负责处理发往收件人域名的邮件服务器。 MX记录允许设置一个优先级, SMTP 会根据MX记录的值 https://www.cnblogs.com/kaiblog/p/5372728.html netty案例，netty4.1中级拓展篇七《Netty请求响应同步通信》-收费 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 如何验证 Email 地址：SMTP 协议入门教程 现象1 当对同一个 域名下的邮箱检测（比如：lianjia.com）。 不使用代理， 开始都可以检测正常， 中间大量出现【451, ‘msg’: ‘SMTP:RCPT命令失败’】 451 放弃要求的操作；处理过程中出错. [分析原因： 被零时封掉] 550 550 基本可以判断为邮箱不可用。 Mailbox not found 。 您要发送的收件人不存在。 550 #5.1.0 Address rejected. 221 mx5.pingan.com换地址, 用代理，换send都不行。 550, details=[User not found: zhangquanquan@umpay.com]} 12345678hejiazhen@woneast.com ### mx mxbiz1.qq.com.mxbiz2.qq.com.大多是 550 【Mailbox not found. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000728]】. 有些情况是正常。 501Bad address syntax501 Bad address syntax. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000730您所填写的收件人地址格式不正确。 530error rcpt error. 目前只有 chinac.com 域名的邮箱. 551551 5.1.1 recipient is not exist 可以判定为不可用 552552 mailbox is full 553[“RCPT TO” mailbox unavailable]}可以判定为不可用.存在 SMTP:MAIL_FROM命令失败的情况 （这种情况为不确定） 554 554, details=[5.7.1 &#x6d;&#x6f;&#x62;&#x65;&#x69;&#x73;&#x69;&#x40;&#104;&#117;&#97;&#x77;&#x65;&#105;&#x2e;&#x63;&#x6f;&#x6d;: Recipient address rejected: User unknown]} 553“RCPT TO” mailbox unavailable 560[6.0.2 &#x6c;&#x69;&#x75;&#x78;&#105;&#x6e;&#x79;&#x69;&#110;&#x67;&#64;&#x68;&#97;&#105;&#x73;&#116;&#x70;&#x61;&#121;&#x2e;&#x63;&#111;&#x6d; not exist.] Mailbox not found. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000728]zhangwl03@missfresh.cnhejiazhen@woneast.com（应该是通过qq邮箱实现.） 454重新检测为正常. 451pengqian@wanxue.cn 451, details=[please try again after 120 seconds 554fanlipin@playnovate.com FROM:&#x31;&#50;&#51;&#x31;&#x32;&#x33;&#x40;&#x63;&#104;&#x61;&#99;&#x75;&#111;&#46;&#110;&#x65;&#x74; 时 返回结果：[RCPT (fanlipin@playnovate.com) dosn’t exist] FROM:damonzh@126.com 时， 最后to. 不返回. 【 from 邮箱可用是，】 [总结： 以@chacuo.net 为后缀的from. 返回[RCPT (fanlipin@playnovate.com) dosn’t exist]] 有可能是对方 的一种策略。 如果是零时邮箱，他假装不存在. rcpt is rejected: 23. 发现也有成功的（jianshuxin@bluemoon.com.cn） 。 所以可能是用户的一种拒绝策略。 各种情况都有dankegongyu.com 501,550,551,552,553,554 grep -E ‘: 501,|: 560,|: 550,|: 551,|: 552,|: 553,|: 554,’ not_big_nohup.out | grep code | grep -v 邮箱可用 | grep -v ‘MAIL_FROM命令失败’ &gt; 机器确认邮箱不可用.txt grep -v -E ‘: 501,|: 560,|: 550,|: 551,|: 552,|: 553,|: 554,’ not_big_nohup.out | grep code | grep -v 邮箱可用 | grep -v ‘SMTP:MAIL_FROM命令失败’ &gt; 未知.txt grep SMTP:MAIL_FROM命令失败 not_big_nohup.out &gt;&gt; 未知.txt 2116 grep -v -E ‘: 501,|: 560,|: 550,|: 551,|: 552,|: 553,|: 554,’ not_big_nohup.out | grep code | grep -v 邮箱可用 |awk -F “‘data’: {‘code’: “ ‘{print $2}’ | awk -F “, ‘email’:” ‘{print $1}’ | sort | uniq -c | more 数量 code, msg 268 41, ‘msg’: ‘连接超时’ 25 422, ‘msg’: ‘SMTP:RCPT命令失败’ 382 450, ‘msg’: ‘SMTP:RCPT命令失败’ 1 451, ‘msg’: ‘SMTP:MAIL_FROM命令失败’ 2307 451, ‘msg’: ‘SMTP:RCPT命令失败’ 8 452, ‘msg’: ‘SMTP:MAIL_FROM命令失败’ 1638 454, ‘msg’: ‘SMTP:RCPT命令失败’ 1 500, ‘msg’: ‘SMTP:MAIL_FROM命令失败’ 1161 50, ‘msg’: ‘响应超时’ 811 51, ‘msg’: ‘处理异常’ 3 530, ‘msg’: ‘SMTP:RCPT命令失败’ 1 560, ‘msg’: ‘SMTP:RCPT命令失败’ 71 SMTP:MAIL_FROM命令失 6607 63250 可用. 72034 检测总量 SMTP的响应码列表 SMTP错误码/建议解决方法 确定下邮箱服务器有哪些拦截 策略。 可以绕过来检测。 需求的生命周期管理. grep -v -code not_big_nohup.out16 | grep -v 邮箱可用 &gt; 未知和不可用.txt grep -v -E ‘: 501,|: 560,|: 550,|: 551,|: 552,|: 553,|: 554,’ 未知和不可用.txt | grep -v 未找到对应的MX &gt; 未知.txt 06cdc3b4a9d442f485d0dbc7e5bf3fe0ad5d3f1c","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"Netty实现代理","date":"2020-01-11T11:56:24.000Z","path":"wk/项目管理/软件工程/Linux/Netty实现代理/","text":"HttpProxy 基于netty的代理——高性能、轻量、稳定 基于netty实现的动态代理服务器 TCP/IP的底层队列实现原理","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"Python客户端http请求","date":"2020-01-11T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/Python客户端Http请求/","text":"123456789101112131415161718192021222324252627&quot;&quot;&quot;告警通知脚本异常任务，邮件通知@author zhangquanquan 20-01-10 下午3:49&quot;&quot;&quot;import requestsimport jsonheaders = &#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;&#125;def notify(receivers, subject, content): notify_url = &#x27;http://192.168.0.23:8060/heimdallr/upload/api/notifyByEmail&#x27; data = &#123;&#x27;receivers&#x27;: receivers, &#x27;subject&#x27;: subject, &#x27;content&#x27;: content&#125; r = requests.post(notify_url,data=json.dumps(data),headers=headers) try: rd = json.loads(r.content.decode(&#x27;utf-8&#x27;)) print (rd) except Exception: print (r.content) print (strategyName, dataDate, message, &quot;处理异常&quot;, sep=&#x27;,&#x27;) return rd","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"}]},{"title":"Shell加解密及expect实现自动交互","date":"2020-01-11T01:56:24.000Z","path":"wk/项目管理/软件工程/Linux/Shell加解密及expect实现自动交互/","text":"1234shc -r -T -f 123.sh# shc -h 可以查看帮助# -T 显示编译说明 Shell脚本加密解密 mac 安装brew mac安装expect mac一键登录服务器脚本 1","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"Flink环境搭建","date":"2019-12-30T03:55:57.000Z","path":"wk/数据/数据处理/Flink/1.Flink环境搭建/","text":"Flink 是一个以 Java 及 Scala 作为开发语言的开源大数据项目，代码开源在 GitHub 上，并使用 Maven 来编译和构建项目。 运行 Flink有三种环境模式。包括：单机 Standalone 模式、多机 Standalone 模式和 Yarn 集群模式 安装单机 Standalone 模式1234567# 到解压包目录cd /data/tools/flink-1.8.2# 运行./bin/start-cluster.sh 查看Flink 的 Web 界面。 1. 提交任务1234# First of all, we use netcat to start local server vianc -l 9000# Submit the Flink program:./bin/flink run examples/streaming/SocketWindowWordCount.jar --port 9000 以上简单的例子实现了 单机Standalone模式的安装个demo运行。 后面学习更深入的一些课题。 Flink的例子 Batch Examples(包括WordCount，PageRank)","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"}]},{"title":"FlinkCEP","date":"2019-12-30T03:55:57.000Z","path":"wk/数据/数据处理/Flink/FinkCEP/","text":"针对什么，解决什么问题，空缺的地方。 目前，基于团伙发现和聊天的策略基本已经实现。后续可能需要优化和策略的调度上再优化。 但是对于用户行为序列的策略这块应用很少，目前有念姐的基于用户行为序列的xgboost模型,但解决的是特定的问题，泛化能力较弱，针对新的异常行为场景不能覆盖。 那怎么有一个通用的，可以配置基于规则的这么一个异常行为序列检测的策略。这个时候就考虑了flink. 优点 跨事件的匹配，这个是重点。 同时eventTime.processingTIme语义的支持。 延迟数据的良好处理 友好的API. 解决的另一个痛点是。运营老是频繁提需求，改动。这边李华，华哥那边也深受同感吧。 当然，最好规则是sql 的形式，运营人员直接参与规则编写而不是频繁提需求。 这个和龙哥那边给何博士和念姐那边支持的数据工具类似。 flink CEP官网给出的API也还是很丰富的 Flink是什么，我想大家都比较熟悉了。定义一些通用的流程针对之前已经发生的一些case. 找到一些可以使用flink-cep解决的。 比如： 难点和需要做的就是定义这些流程场景，分析一些通用的异常场景和特征。 频繁交换微信，5分钟内交换5次微信。 聊天内容命中一个词之后，统计个数。这个词可以配置。 （比如合作，微信，威信等 多次统计的（可以基于规则实时统计- 重点在于实时修改。）） 对类似群发的消息进行检测。 利用cep构建一些实时特征并利用起来。 传销这种，就是约异地面试的意图。特征。 首先目标是这个 解决大量的异常场景， 提高准确率（每天运营催说数据太多，标不完，那就是准确率不高，利用简单快速的东西，实现复杂的需求流程。）「团伙发现也要利用好」","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"}]},{"title":"Alink介绍","date":"2019-12-30T03:55:57.000Z","path":"wk/数据/数据处理/Flink/Alink/","text":"Alink 是阿里巴巴机器学习算法团队从 2017 年开始基于实时计算引擎 Flink 研发的新一代机器学习算法平台，提供丰富的算法组件库和便捷的操作框架，开发者可以一键搭建覆盖数据处理、特征工程、模型训练、模型预测的算法模型开发全流程。作为业界首个同时支持批式算法、流式算法的机器学习平台，Alink 提供了 Python 接口，开发者无需 Flink 技术背景也可以轻松构建算法模型。 Alink 这个名字取自相关名称（Alibaba, Algorithm, AI, Flink,Blink）的公共部分。 据悉，Alink 已被广泛运用在阿里巴巴搜索、推荐、广告等多个核心实时在线业务中。在刚刚落幕的天猫双 11 中，单日数据处理量达到 970PB，每秒处理峰值数据高达 25 亿条。Alink 成功经受住了超大规模实时数据训练的检验，并帮助提升 4% CTR（商品点击转化率）。 阿里开源全球首个批流一体机器学习平台 Alink，Blink 功能已全部贡献至 Flink Alink 是阿里巴巴机器学习算法团队基于实时计算引擎 Flink 研发的新一代机器学习算法平台 ctolib","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"}]},{"title":"5.Hive环境安装搭建","date":"2019-12-16T04:56:24.000Z","path":"wk/数据/数据处理/组件安装配置/Hadoop组件安装/5.Hive环境安装搭建/","text":"https://sqoop.apache.org/ 准备mysql环境(账号创建及授权.) 下载hive, 修改hive-site.xml. 添加环境变量 hive —service metastore &amp; [初始化元信息] 执行hive. show databases 查看是否正常.","tags":[{"name":"hive","slug":"hive","permalink":"https://quano.gitee.io/tags/hive/"}],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"Hadoop组件安装","slug":"数据/数据处理/组件安装配置/Hadoop组件安装","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/Hadoop%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"Flink基本架构","date":"2019-12-07T03:55:57.000Z","path":"wk/数据/数据处理/Flink/2.Flink的基本架构/","text":"架构与Spark类似，是一个基于Master-Slave风格的架构。 Flink集群启动时，会启动一个JobManager进程、至少一个TaskManager进程。 当Flink程序提交后，会创建一个Client来进行预处理，并转换为一个并行数据流，这是对应着一个Flink Job，从而可以被JobManager和TaskManager执行。在实现上，Flink基于Actor实现了JobManager和TaskManager，所以JobManager与TaskManager之间的信息交换，都是通过事件的方式来进行处理。 JobManagerJobManager是Flink系统的协调者，它负责接收Flink Job，调度组成Job的多个Task的执行。同时，JobManager还负责收集Job的状态信息，并管理Flink集群中从节点TaskManager。JobManager所负责的各项管理功能，它接收到并处理的事件主要包括： RegisterTaskManager 在Flink集群启动的时候，TaskManager会向JobManager注册，如果注册成功，则JobManager会向TaskManager回复消息AcknowledgeRegistration。 SubmitJob Flink程序内部通过Client向JobManager提交Flink Job，其中在消息SubmitJob中以JobGraph形式描述了Job的基本信息。 CancelJob 请求取消一个Flink Job的执行，CancelJob消息中包含了Job的ID，如果成功则返回消息CancellationSuccess，失败则返回消息CancellationFailure。 UpdateTaskExecutionState TaskManager会向JobManager请求更新ExecutionGraph中的ExecutionVertex的状态信息，更新成功则返回true。 RequestNextInputSplit 运行在TaskManager上面的Task，请求获取下一个要处理的输入Split，成功则返回NextInputSplit。 JobStatusChanged ExecutionGraph向JobManager发送该消息，用来表示Flink Job的状态发生的变化，例如：RUNNING、CANCELING、FINISHED等。 TaskManagerTaskManager也是一个Actor，它是实际负责执行计算的Worker，在其上执行Flink Job的一组Task。每个TaskManager负责管理其所在节点上的资源信息，如内存、磁盘、网络，在启动的时候将资源的状态向JobManager汇报。TaskManager端可以分成两个阶段： 注册阶段 TaskManager会向JobManager注册，发送RegisterTaskManager消息，等待JobManager返回AcknowledgeRegistration，然后TaskManager就可以进行初始化过程。 可操作阶段 该阶段TaskManager可以接收并处理与Task有关的消息，如SubmitTask、CancelTask、FailTask。如果TaskManager无法连接到JobManager，这是TaskManager就失去了与JobManager的联系，会自动进入“注册阶段”，只有完成注册才能继续处理Task相关的消息。 Client 当用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群中处理，所以Client需要从用户提交的Flink程序配置中获取JobManager的地址，并建立到JobManager的连接，将Flink Job提交给JobManager。Client会将用户提交的Flink程序组装一个JobGraph， 并且是以JobGraph的形式提交的。一个JobGraph是一个Flink Dataflow，它由多个JobVertex组成的DAG。其中，一个JobGraph包含了一个Flink程序的如下信息：JobID、Job名称、配置信息、一组JobVertex等 组件栈这个很有学习意义。 Flink是一个分层架构的系统，每一层所包含的组件都提供了特定的抽象，用来服务于上层组件。 1. Deployment层Flink支持多种部署模式：本地、集群（Standalone/YARN）、云（GCE/EC2）。Standalone部署模式与Spark类似. 2. Runtime层Runtime层提供了支持Flink计算的全部核心实现，比如：支持分布式Stream处理、JobGraph到ExecutionGraph的映射、调度等等，为上层API层提供基础服务。 3. API层API层主要实现了面向无界Stream的流处理和面向Batch的批处理API，其中面向流处理对应DataStream API，面向批处理对应DataSet API。 4. Libraries层该层也可以称为Flink应用框架层，根据API层的划分，在API层之上构建的满足特定应用的实现计算框架，也分别对应于面向流处理和面向批处理两类。面向流处理支持：CEP（复杂事件处理）、基于SQL-like的操作（基于Table的关系操作）；面向批处理支持：FlinkML（机器学习库）、Gelly（图处理）。","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"}]},{"title":"SpringBootStarter的定义方式","date":"2019-11-26T14:56:24.000Z","path":"wk/MicroService/技术框架/SpringBoot/02.SpringBootStarter定义的方式/","text":"定义AutoConfiguration一. 常用注解1. Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。 和xml配置一样，可以配置Bean的生命周期中的各个方法。 1@Bean(name=&quot;testBean&quot;,initMethod=&quot;start&quot;,destroyMethod=&quot;stop&quot;) 问题1:加了Configuration后，怎么将想要的Bean加载到应用的Spring容器中呢？ 可以想想之前xml的bean配置文件怎么加载的。 123456789public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable &#123; ...&#125;FileSystemXmlApplicationContextClassPathXmlApplicationContextEmbeddedWebApplicationContextGroovyWebApplicationContextAnnotationConfigApplicationContext 也就是在初始化以上各个ApplicationContext的时候，会加载指定的Configuration， 不管是xml还是注解方式的。 那Configuration配置的Bean的加载方式就是可以通过AnnotationConfigApplicationContext。ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class); 问题2: Configuration的配置类在做一些组件的时候怎么定义，来实现组件的灵活性 这个问题如果了解一些初始化ApplicationContext的时候对Configuration的识别加载流程可能更容易理解。TODO. 另外，在@configuration中还可以引入其它注解配置 12@ImportResource(&quot;classpath:applicationContext-configuration.xml&quot;)@Import(TestConfiguration.class) 主要作用理解为是将相关的Bean加载到Spring容器。 2. EnableConfigurationProperties@EnableConfigurationProperties注解的作用是：使使用 @ConfigurationProperties 注解的类生效。 如果一个配置类只配置@ConfigurationProperties注解，而没有使用@Component，那么在IOC容器中是获取不到properties 配置文件转化的bean。 @EnableConfigurationProperties 相当于把使用 @ConfigurationProperties 的类进行了一次注入。 当@EnableConfigurationProperties注解应用到@Configuration时， 任何被@ConfigurationProperties注解的beans将自动被Environment属性配置。 这种风格的配置特别适合与SpringApplication的外部YAML配置进行配合使用。 感觉和@Component的功能类似。将属性配置类注入到容器。 3. Conditional Spring4推出了@Conditional注解，方便程序根据当前环境或者容器情况来动态注入bean. 继@Conditional注解后，又基于此注解推出了很多派生注解，比如@ConditionalOnBean、@ConditionalOnMissingBean、@ConditionalOnExpression、@ConditionalOnClass……实现动态注入bean ConditionalOnClass 自动配置的重要支撑之一。判断当前classpath下是否存在指定类，若是则将当前的配置装载入spring容器。 但这个还不会熟练使用。只是理解了大概是这个意思。 12@ConditionalOnClass(JsonRedisTemplate.class)public class LinkWhiteListRedisOps&#123;&#125; 如果classpath存在JsonRedisTemplate的情况下，则将LinkWhiteListRedisOps装载到spring容器。 4. ConditionalXXXX @ConditionalOnBean 当指定一个Bean存在是，才创建当前这个Bean @ConditionalOnMissingBean 当指定Bean不存在是，才创建这个Bean. @ConditionalOnProperty来控制Configuration是否生效 Class的存在与否作为条件。 从使用来看，和前面基本上没有太大的区别，无非就是将bean换成了class；这样就可以避免因为Class Not Found导致的编译异常了。 如提供了一个bean名为RedisOperBean，用于封装redis相关的操作；但是我这个bean需要依赖restTemplate这个bean，只有当应用引入了redis的相关依赖，并存在RestTemplate这个bean的时候，我这个bean才会生效.12345678@Component@ConditionalOnBean(name=&quot;redisTemplate&quot;)public class RedisOperBean &#123; private final RedisTemplate redisTemplate; public RedisOperBean(RedisTemplate redisTemplate) &#123; // ... &#125;&#125; springboot注解丰富，我们可以利用好这些注解来实现我们自定义的starter配置，减少硬编码的校验，降低组件间的耦合性!!! 二. 两种方式集成方式主动生效和被动生效 从使用者的角度。 1. 主动生效使用@Import注解。主动声明启用该starter才生效。比如加到我们的启动来，或者将该注解标记到你自定义的@Enable注解上。 123456@Target(ElementType.TYPE)@Documented@Import(RedisToolsAutoConfiguration.class)public @interface EnableRedisTools&#123;&#125; 2. 被动生效在starter组件集成入SpringBoot应用时，就已经被应用捕捉到。类似java的SPI机制。 新建 META-INF/spring.factories文件。写入AutoConfiguration全限定名。 123# AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ ch.quiz.redis.distributed.config.RedisLimitAutoConfiguration 3. 优缺点 主动生效的方式需要在使用的项目中手动指定，enable. 也属于硬编码。而相对被动生效。我们可以通过配置来实现组件的生效。 被动生效虽然可以通过配置来控制组件生效，但AutoConfiguration中配置的一些组件对象会实例到容器。比如redis连接，不管是否生效，他都会在实例化的时候连接默认的redis.如果不适用，实例化就是有些浪费。 三.命名规范Spring官方Starter通常命名为spring-boot-starter-{name}如 spring-boot-starter-web Spring官方建议非官方Starter命名应遵循{name}-spring-boot-starter的格式, 如mybatis-spring-boot-starter。","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quano.gitee.io/tags/SpringBoot/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"MicroService/技术框架/SpringBoot","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot/"}]},{"title":"workFlow","date":"2019-11-26T14:56:24.000Z","path":"wk/MicroService/技术框架/workflow/001.README/","text":"WorkFlow学习总结 工作流，指的是一系列相互衔接、自动进行的业务活动或任务。 任务 它们的关系 它们的启动和终止条件 业务过程按照预先设定的规则并借助应用程序和人对相关数据的处理而完成 在日常办公中，当撰写好某份报告之后，可能需要将其提交给领导进行审阅或批示；审批意见可能需要汇集并提交给另外一个人，以便对报告进行进一步的修改。这样，可能会形成同一篇文档在多个人之间的顺序或同时传递。对于这样的情况，我们可以使用工作流技术来控制和管理文档在各个计算机之间自动传递，而非手工传递。这就可以称之为工作流。 类似的关于文档的自动化处理只是工作流技术的一种简单应用。事实上，工作流技术在现实生活中能够完成更多更复杂的任务: 如企业（或机构）内部的各种数据或信息的自动处理，多种业务流程的整合，企业（或机构）之间的数据交换，借助Internet技术实现跨地域的数据传输和处理等等。 工作流的特点： 图形化、可视化设计流程图 支持各种复杂流程 组织结构级处理者指定功能 灵活的外出、超时管理策略 处理过程可跟踪、管理 丰富的统计、查询、报表功能 与MAIL系统集成 工作流的实现工作流的实施需要三个基本步骤：映射、建模和管理。 映射是第一个步骤，其首要任务是确定并且文档化组织内全部现有的手工和自动化的业务流程； 建模则是开发一个有助于建成流线型业务过程的模型。 第三阶段是软件实施以及跨越全部工作部门、业务单元甚至是整个企业的无缝系统集成。","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quano.gitee.io/tags/SpringBoot/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"workflow","slug":"MicroService/技术框架/workflow","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/workflow/"}]},{"title":"SpringBoot常见starter","date":"2019-11-22T14:56:24.000Z","path":"wk/MicroService/技术框架/SpringBoot/01.SpringBoot常见starter/","text":"简化配置、开箱即用、快速集成. 举个例子。redis-starter，会根据luttuce、redisson、jedis 的变化实例化不同的客户端链接。实现方式是使用了@Conditional系列注解 Redis的三个框架：Jedis,Redisson,Lettuce spring-boot的各个starter. 是spring-boot场景启动器，后面跟的单词就是场景，比如说后面跟web,就是导入web场景的所有依赖。 1. spring-boot-starterSpring Boot的核心启动器，包含了自动配置、日志和YAML 2. spring-boot-starter-parent控制版本信息 3. spring-boot-starter-webweb的场景，自动帮我们引入了web模块开发需要的相关jar包 4. spring-boot-starter-testspringboot程序测试依赖，如果是自动创建项目默认添加 5. spring-boot-starter-actuator用于支持 SpringBoot 应用的监控。 Actuator 这个词即使翻译过来也不是很容易理解（比如翻译成“制动器；传动装置；执行机构”等）。 为了能够感知应用的运行状态，我们通常会： 123451. 设置一些监控指标并采集分析2. 监控指标的采集需要在应用内部设置相应的监控点3. 这类监控点一般只是读取状态数据，我们通常称它们为 Sensor，即中文一般称为“传感器”的东西。4. 应用的运行状态数据通过 Sensors 采集上来之后，我们通常会有专门的系统对这些数据进行分析和判断。5. 一旦某个指标数据超出了预定的阈值，这往往意味着应用的运行状态在这个指标上出现了“不健康”的现象，我们希望对这个指标进行调整，而为了能够执行调整，我们需要预先在应用内部设置对应的执行调整逻辑的控制器。 比如，直接关闭的开关，或者可以执行微调甚至像刹车一样直接快速拉低某个指标值的装置，这些控制器就称为 Actuator。虽然我们日常天天在说“监控，监控”，但实际上“监”跟“控”是两个概念，Sensor 更多服务于“监”的场景，而 Actuator 则服务于“控”的场景。 SpringBoot的Endpoint主要是用来监控应用服务的运行状况，并集成在Mvc中提供查看接口。 spring-boot-starter-actuator 自动配置模块默认提供了很多 endpoint，虽然自动配置模块名为 spring-boot-starter-actuator，但实际上这些 endpoint 可以按照“监”和“控”划分为两类： Sensor 类 endpoints 和 Actuator 类 endpoints. Sensor：感知器,传感器 类型。 Actuator：执行器 类型 1234567----- Sensorautoconfig - 提供一份 SpringBoot 的自动配置报告，告诉我们哪些自动配置模块生效了，以及哪些没有生效，原因是什么。beans - 给出当前应用的容器中所有 bean 的信息。configprops - 对现有容器中的 ConfigurationProperties 提供的信息进行“消毒”处理后给出汇总信息。info - 提供当前 SpringBoot 应用的任意信息，我们可以通过 Environment 或者 application.properties 等形式提供以 info. 为前缀的任何配置项，然后 info 这个 endpoint 就会将这些配置项的值作为信息的一部分展示出来metrics - 当前 SprinBoot 应用的 metrics 信息。trace - 当前 SpringBoot 应用的 trace 信息。 123----- Actuatorshutdown - 用于关闭当前 SpringBoot 应用的 endpoint。dump - 用于执行线程的 dump 操作。 参考: spring-boot-starter-actuator与应用监控,Spring Boot提供的监控和管理接口-2.0 endpoints 属于 spring-boot-starter-actuator 提供的主要功能之一.除此之外，spring-boot-starter-actuator 还提供了更多针对应用监控的支持和实现方案。 上面主要介绍了spring-boot-starter-actuator。 6. 各Spring-Boot-Starters介绍Spring Boot application starters 问题: 以上starter其实已经很完备了，为什么都要自定义。 简化配置、开箱即用、快速集成、灵活装配使用。 自定义starterSpring Boot入门教程(三十一): 自定义Starter 最详细的自定义Spring Boot Starter开发教程 SpringBoot使用AutoConfiguration自定义Starter","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quano.gitee.io/tags/SpringBoot/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"MicroService/技术框架/SpringBoot","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot/"}]},{"title":"SpringBoot应用启动流程","date":"2019-11-22T14:56:24.000Z","path":"wk/MicroService/技术框架/SpringBoot/03.SpringBoot应用启动流程/","text":"bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application: Create an appropriate {@link ApplicationContext} instance (depending on your classpath) Register a {@link CommandLinePropertySource} to expose command line arguments as Spring properties Refresh the application context, loading all singleton beans Trigger any {@link CommandLineRunner} beans 12345678910/** * Run the Spring application, creating and refreshing a new * &#123;@link ApplicationContext&#125;. * @param args the application arguments (usually passed from a Java main method) * @return a running &#123;@link ApplicationContext&#125; */public ConfigurableApplicationContext run(String... args) &#123;&#125; ConfigurableApplicationContext SpringBoot启动原理解析 Spring Boot：启动原理解析","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quano.gitee.io/tags/SpringBoot/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"MicroService/技术框架/SpringBoot","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot/"}]},{"title":"SpringBoot:自定义Endpoint","date":"2019-11-22T14:56:24.000Z","path":"wk/MicroService/技术框架/SpringBoot/04.自定义Endpoint/","text":"EndpointSpringBoot的Endpoint主要是用来监控应用服务的运行状况，并集成在Mvc中提供查看接口。 内置的Endpoint比如HealthEndpoint会监控dist和db的状况，MetricsEndpoint则会监控内存和gc的状况。 Endpoint的接口如下，其中invoke()是主要的方法，用于返回监控的内容，isSensitive()用于权限控制。 123456public interface Endpoint&lt;T&gt; &#123; String getId(); boolean isEnabled(); boolean isSensitive(); T invoke();&#125;","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quano.gitee.io/tags/SpringBoot/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"MicroService/技术框架/SpringBoot","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot/"}]},{"title":"scala环境搭建","date":"2019-11-16T17:13:34.000Z","path":"wk/平台工具/工作相关/环境搭建/003.scala环境搭建/","text":"下载部署包下载路径 放到指定路径/data/tools/ 配置环境变量123export JAVA_HOME=/data/tools/jdk1.8.0_25export SCALA_HOME=/data/tools/scala-2.11.12export PATH=$JAVA_HOME/bin:$SCALA_HOME/bin:$PATH JDK包安装下载华为镜像 华为开源镜像站 java.lang.NumberFormatException: For input string: “0x100” 问题export TERM=xterm-color","tags":[{"name":"scala","slug":"scala","permalink":"https://quano.gitee.io/tags/scala/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工作相关","slug":"平台工具/工作相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"环境搭建","slug":"平台工具/工作相关/环境搭建","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Maven命令","date":"2019-10-16T03:55:57.000Z","path":"wk/平台工具/工具组件/IDE/Maven命令/","text":"项目升级版本1mvn versions:set -DnewVersion=1.0.6.19","tags":[{"name":"mvn","slug":"mvn","permalink":"https://quano.gitee.io/tags/mvn/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"IDE","slug":"平台工具/工具组件/IDE","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/IDE/"}]},{"title":"0.C和c++区别","date":"2019-07-22T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/0.C与c++区别及入门/","text":"区别 C是一个结构化语言，它的重点在于算法和数据结构。 设计首要考虑: 如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。 首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域 一.具体的区别点 类，类对于初学者，它是一个累赘。类的封装使得初学者对程序产生厌倦，感到不适和麻烦。 引用，引用是C++中最好尽量不要用它，除非万不得已。引用对于初学者就更容易产生混淆，不知道哪个是引用，哪个是变量 函数的重载，初学者学函数的重载好像没什么坏处，但是，这会使初学者潜意识里对C语言的变量类型的重要性产生淡化，要记住C语言是对变量类型最敏感了的，变量的类型在C语言里的重要性是不言而喻的。 流操作符，和上面同样的道理，使得对变量类型的重要性产生淡化，有时会产生使初学者莫名其妙的结果。 http://c.biancheng.net/cpp/html/798.html 聊天查询的限制， 只能查询安全风险用户的聊天信息","tags":[{"name":"C++","slug":"C","permalink":"https://quano.gitee.io/tags/C/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"JavaJNI的支持","date":"2019-07-22T13:13:34.000Z","path":"wk/平台工具/程序语言/C++/7.JavaJNI的支持/","text":"123456789101112/** * StringAppendOperator is a merge operator that concatenates * two strings. */public class StringAppendOperator extends MergeOperator &#123; public StringAppendOperator() &#123; super(newSharedStringAppendOperator()); &#125; private native static long newSharedStringAppendOperator(); @Override protected final native void disposeInternal(final long handle);&#125; 以上代码是调用native方法的java代码. 在Java中native是关键字，它一般在本地声明，异地用C和C++来实现. 12345声明有以下几点注意:1. native与访问控制符前后的关系不受限制.2. 必须在返回类型之前3. 它一般为非抽象类方法.4. native方法在异地实现,像抽象方法一样,所以没有方法体,以分号结束. 下面是对应的C++实现代码 123456789101112131415161718192021222324252627/* * Class: org_rocksdb_StringAppendOperator * Method: newSharedStringAppendOperator * Signature: (C)J */jlong Java_org_rocksdb_StringAppendOperator_newSharedStringAppendOperator( JNIEnv* /*env*/, jclass /*jclazz*/, jchar jdelim) &#123; auto* sptr_string_append_op = new std::shared_ptr&lt;ROCKSDB_NAMESPACE::MergeOperator&gt;( ROCKSDB_NAMESPACE::MergeOperators::CreateStringAppendOperator( (char)jdelim)); return reinterpret_cast&lt;jlong&gt;(sptr_string_append_op);&#125;/* * Class: org_rocksdb_StringAppendOperator * Method: disposeInternal * Signature: (J)V */void Java_org_rocksdb_StringAppendOperator_disposeInternal(JNIEnv* /*env*/, jobject /*jobj*/, jlong jhandle) &#123; auto* sptr_string_append_op = reinterpret_cast&lt;std::shared_ptr&lt;ROCKSDB_NAMESPACE::MergeOperator&gt;*&gt;( jhandle); delete sptr_string_append_op; // delete std::shared_ptr&#125; 问题：那这个对应关系是怎么找到的呢，就是说java的接口，怎么找到c++里的这个方法的呢？ include 引入 Signature: (Ljava/lang/String;)V 函数的标记符。当从本地方法端访问Java端的方法时，会用到这个标记符。JNI中为每种数据类型也定义了标记符，标记符的规则请查看JNI标准文档。 native方法的使用方式1231. 用loadLibrary导入存在源文件目录下的*.dll文件,2. 然后定义native方法时,与c/c++实现的函数有相同的参数和返回类型．3.方法被映射为固定的形式。其中函数名的映射规则是（Java_包名_类名_方法名）。 如下rocksDB中的使用方式. 见 org.rocksdb.NativeLibraryLoader 1234567891011public synchronized void loadLibrary(final String tmpDir) throws IOException &#123; try &#123; System.loadLibrary(sharedLibraryName); &#125; catch(final UnsatisfiedLinkError ule1) &#123; try &#123; System.loadLibrary(jniLibraryName); &#125; catch(final UnsatisfiedLinkError ule2) &#123; loadLibraryFromJar(tmpDir); &#125; &#125;&#125; 那.ddl ,.so文件又是什么，怎么来的呢？先说所JNI JNIJNI是Java Native Interface的缩写，中文为JAVA本地调用.它允许Java代码和其它语言写的代码进行交互. JNI使得运行在JVM虚拟机上的JAVA代码能够操作使用其它语言编写的应用程序和库,比如C/C++以及汇编语言等. JNI的设计目的： 123 ·标准的java类库可能不支持你的程序所需的特性。 ·或许你已经有了一个用其他语言写成的库或程序，而你希望在java程序中使用它。 ·你可能需要用底层语言实现一个小型的时间敏感代码，比如汇编，然后在你的java程序中调用这些功能。 JAVA中native方法调用","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"平台工具/程序语言/C","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"}]},{"title":"FlinkStart","date":"2019-06-30T03:55:57.000Z","path":"wk/数据/数据处理/Flink/FlinkStart/","text":"《Flink官方文档》监控Wikipedia 编辑流 123456789mvn archetype:generate \\ -DarchetypeGroupId=org.apache.flink \\ -DarchetypeArtifactId=flink-quickstart-java \\ -DarchetypeVersion=1.2.0 \\ -DgroupId=wiki-edits \\ -DartifactId=wiki-edits \\ -Dversion=0.1 \\ -Dpackage=wikiedits \\ -DinteractiveMode=false","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Flink","slug":"数据/数据处理/Flink","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/Flink/"}]},{"title":"DockerCompose","date":"2019-06-25T17:13:34.000Z","path":"wk/平台工具/工具组件/Docker/9.Docker-compose/","text":"pip 安装docker-compose. 1/home/zhangquanquan/anaconda3/bin/docker-compose","tags":[{"name":"Docker","slug":"Docker","permalink":"https://quano.gitee.io/tags/Docker/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"01.开发使用环境","date":"2019-06-17T01:56:24.000Z","path":"wk/MicroService/微服务架构/001.开发学习支持/","text":"elasticsearch docker 搭建es开发环境1docker run --name es-kibana -d -p 9200:9200 -p 5601:5601 nshou/elasticsearch-kibana By Dockerfile mysql docker 搭建mysql环境 1docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=quantumcs -d mysql:5.7 手动安装mysql支持监听mysql-binlog rabbitMqkafka123456# 启动容器docker run -d --name data-dev --restart always --net=host -e ADV_HOST=127.0.0.1 landoop/fast-data-dev# 创建topicbin/kafka-topics.sh --create --zookeeper 172.16.26.193:2181 --replication-factor 1 --partitions 5 --topic my-replicated-topic# 更新partition大小bin/kafka-topics.sh --alter --zookeeper 127.0.0.1:2181 --partitions 5 --topic nginx_log 对技术提升很不错的书 Spring Boot 2(一)：Spring Boot 2.0新特性 https://github.com/Bypass007/Safety-Project-Collection https://github.com/ysrc/Liudao https://github.com/momosecurity/aswan https://github.com/threathunterX/nebula_doc/blob/master/chapter2/section1/section1.","tags":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/tags/MicroService/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"微服务架构","slug":"MicroService/微服务架构","permalink":"https://quano.gitee.io/categories/MicroService/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"}]},{"title":"01.micronaut介绍","date":"2019-06-17T01:56:24.000Z","path":"wk/MicroService/技术框架/micronaut/README/","text":"https://micronaut.io/ https://github.com/micronaut-projects","tags":[{"name":"micronaut","slug":"micronaut","permalink":"https://quano.gitee.io/tags/micronaut/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"micronaut","slug":"MicroService/技术框架/micronaut","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/micronaut/"}]},{"title":"1.决策树","date":"2019-06-15T14:55:57.000Z","path":"wk/算法/001.机器学习/机器学习实战/1.决策树/","text":"优点计算复杂度不高， 输出结果易于理解。对中间值的缺失不敏感，可以处理不相关特征数据。 缺点可能会产生过度匹配问题 适合数据类型数值型和标称型 第一个问题：当前数据集中哪个特征在划分数据分类时起决定性作用。 为了找到决定性的特征，划分出最好的结果，我们必须评估每一个特征。 决策树的流程 收集数据：可以使用任意方法 准备数据：树构造算法只适用于标称型数据，因此数值型必须离散化 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期 训练算法：构造树的数据结构 测试算法：使用经验树计算错误率 使用算法：此步骤可以使用任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 一些决策树算法采用二分法划分数据，这里依据某个属性划分数据将会产生4个可能的值，我们把数据划分为四块，并创建四个不同的分支。 这里使用ID3算法划分数据集。 每次划分数据集时我们只选取一个特征属性，如果训练集中存在20个特征，第一次我们选择哪个特征作为划分的参考属性呢？？ 比如：特征有，不浮出水面是否可以生存，是否有脚蹼。可以将这些动物分为两类：鱼类和非鱼类。现在想决定依据第一个特征还是第二个特征划分数据呢。 我们比如采用量化的方法判断如何划分数据 信息增益划分数据集的原则：将无序的数据变得更加有序。可以由很多种方法划分数据集，各有各的优缺点。其中一种是使用信息论度量信息。信息论是量化处理信息的分支科学。可以在划分数据集前后使用信息论量化度量信息的内容。 在划分数据集之前之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择 如何计算信息增益集合信息的度量方式称为香农熵或者简称熵。这个名字来源于信息论之父克劳德·香农。 熵定义为信息的期望值。 信息：如果待分类的事物可能划分在多个分类之中，则符号xi的信息定义为l(xi)=-log2p(xi). 其中p(xi)是选择该分类的概率。 为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过下面的公式。H = -Ep(xi)log2p(xi).其中n为分类的数目。 1234567891011121314151617# 计算给定数据集的香农熵from math import log2pdef calcShannonEnt(dataSet): numEntries = len(dataSet) labelCounts = &#123;&#125; # 以下五行为所有可能分类创建字典 for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 for key in labelCounts: prob = float(labelCounts[key]) / numEntries # 以2为底求对数 shannonEnt -= prob * log(prob,2) return shannonEnt 以上，首先计算数据集中实例的总数，我们也可以在需要时再计算这个值，但是由于代码中多次用到这个值，为了提高代码效率，我们显式地声明一个变量保存实例总数。然后，创建一个数据字段，它的键值是最后一列的数值。 最后，使用所有类标签的发生频率计算类别出现的概率，我们将用这个概率计算香农熵，统计所有类标签发生的次数。 下面看看如何使用熵划分数据集。 123456789# trees.pydef createDataSet(): dataSet = [[1,1,&#x27;yes&#x27;], [1,1,&#x27;yes&#x27;], [1,0,&#x27;no&#x27;], [0,1,&#x27;no&#x27;], [0,1,&#x27;no&#x27;]]labels = [&#x27;no surfacing&#x27;, &#x27;flippers&#x27;]return dataSet, labels 12myDat, labels = trees.createDataSet()trees.calcShannonEnt(myDat) 熵越高，则混合的数据也越多，我们可以在数据集中添加更多的分类，观察熵是如何变化的。 1234# 增加一个类别myDat[0][-1] = &#x27;maybe&#x27;myDattrees.calcShannonEnt(myDat) 得到熵之后，我们就可以按照获取最大信息增益的方法划分数据集，下面具体介绍：如何划分数据集以及如何度量信息增益。 另一度量集合无序程度的方法是基尼不纯度，简单地说就是从一个数据集中随机选取子项，度量其被错误分类到其他分组里的概率。 划分数据集上面介绍了如何度量数据集的无序程度，分类算法除了需要测量信息熵，还需要划分数据集。度量划分数据集的熵，以便判断当前是否正确的划分了数据集。 我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据集是最好的划分方式。 想象一个分部在二维空间的数据散点图，需要在数据之间画条线，将它们分为两部分，我们应该按照x轴还是y轴划线呢？ 123456789def splitDataSet(dataSet, axis, value): # 创建新的list对象 retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reducedFeatVec = featVec[:axis] reducedFeatVec.extend(featVec[axis +1:]) retDataSet.append(reducedFeatVec) return retDataSet 以上输入三个参数：待划分的数据集，划分数据集的特征，需要返回的特征的值。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习实战","slug":"算法/001-机器学习/机器学习实战","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/"}]},{"title":"1.目标检测","date":"2019-06-15T14:55:57.000Z","path":"wk/算法/003.图像识别/目标检测/001.目标检测/","text":"定义目标检测（ObjectDetection）是计算机视觉中的一项任务，其目标是在图像或视频中识别和定位图像中存在的多个物体，并为每个物体提供相应的边界框（Bounding Box）。与图像分类任务不同，目标检测不仅要求识别图像中的物体类别，还要准确标定每个物体的位置。 识别图像中的物体类别 + 准确标定每个物体的位置. 1234图像分类。是计算机视角最基本的任务之一。在图像分类的基础上，还有更复杂和有意思的任务，如目标检测，物体定位，图像分割等。 目标检测: 可以看成图像分类与定位的结合。 给定一张图片，目标检测系统要能够识别出图片的目标并给出其位置，由于图片中目标数是不定的，且要给出目标的精确位置，目标检测相比分类任务更复杂。 应用场景目标检测的一个实际应用场景就是无人驾驶，如果能够在无人车上装载一个有效的目标检测系统，那么无人车将和人一样有了眼睛，可以快速地检测出前面的行人与车辆，从而作出实时决策。 两类流行的算法近几年来，目标检测算法取得了很大的突破。 1.R-CNN系算法一类是基于Region Proposal的R-CNN系算法（R-CNN，Fast R-CNN, Faster R-CNN），它们是two-stage的，需要先使用启发式方法（selective search）或者CNN网络（RPN）产生Region Proposal，然后再在Region Proposal上做分类与回归。 2. Yolo，SSD这类one-stage算法，其仅仅使用一个CNN网络直接预测不同目标的类别与位置。第一类方法是准确度高一些，但是速度慢，但是第二类算法是速度快，但是准确性要低一些。 Yolo全称是You Only Look Once: Unified, Real-Time Object Detection. You Only Look Once说的是只需要一次CNN运算，Unified指的是这是一个统一的框架，提供end-to-end的预测，而Real-Time体现是Yolo算法速度快。这里我们谈的是Yolo-v1版本算法，其性能是差于后来的SSD算法的，但是Yolo后来也继续进行改进，产生了Yolo9000算法。本文主要讲述Yolo-v1算法的原理，特别是算法的训练与预测中详细细节，最后将给出如何使用TensorFlow实现Yolo算法。 1. 滑动窗口与CNN","tags":[{"name":"图像识别","slug":"图像识别","permalink":"https://quano.gitee.io/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"003.图像识别","slug":"算法/003-图像识别","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"},{"name":"目标检测","slug":"算法/003-图像识别/目标检测","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/003-%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"6.EsJavaClient","date":"2019-04-28T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/6.EsJavaClient/","text":"Document APIs","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"Nlp学习资料","date":"2019-04-22T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/NLP学习资料/","text":"系统学习NLP（三）—NLP入门综述 如何学习自然语言处理：NLP领域经典《自然语言处理综论》英文版第三版更新 阿里自然语言处理部总监分享：NLP技术的应用及思考","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"分词","date":"2019-04-22T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/分词实现原理/","text":"Trie树分词 Aho Corasick自动机结合DoubleArrayTrie极速多模式匹配","tags":[{"name":"NLP","slug":"NLP","permalink":"https://quano.gitee.io/tags/NLP/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"多模匹配","date":"2019-04-22T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/多模匹配/","text":"给出一个关键词列表(模式串)，和一段字符串text。输出text中存在的关键词。 以上也是多模匹配的定义， 多模的名字应该来源与模式匹配（两个字符串之间的匹配,我们常听的KMP算法） 多模匹配有以下场景： 关键字过滤, 分词, 入侵检测, 病毒检测 算法实现 AC算法实现状态机入门：从定义到使用 多模字符串匹配算法-Aho–Corasick–java AC自动机+trie树实现高效多模式匹配字典（java源码） WM（Wu-Manber）算法字符串匹配的Boyer-Moore算法（很详细） 多模匹配 Wu-Manber算法 案例说明输入：关键字数组：[“研究”, “脂肪酶”, “水平下”, “哮喘”, “正相关”, “表达式”, “研究结果”]待匹配字符：“该研究结果表明，IL-17A和IL-9高表达以及脂肪酶、CCL11水平下降与成人哮喘之间呈正相关。” 输出：匹配成功关键词组：[‘研究’, ‘研究结果’, ‘脂肪酶’, ‘水平下’, ‘哮喘’, ‘正相关’] 测试结果：TODO AC与WM对比：内存占用：WM改进算法比AC改进算法的内存小很多；预处理： WM改进算法比AC改进算法的预处理时间小很多；匹配速度：WM算法的匹配速度跟加载的模式串内容有很大的关系；AC算法跟加载的模式串内容无关；前缀：如果前缀内容大量相似，WM改进算法的Shift表和HASH表冲突比较多，匹配慢。 AC算法优化：采用双数组来优化内存占用。 多模匹配—历程","tags":[{"name":"NLP","slug":"NLP","permalink":"https://quano.gitee.io/tags/NLP/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"字典树","date":"2019-04-22T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/字典树/","text":"Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。 字典树(Trie树)的实现及应用 应用场景 Trie树和DFA，确定有限状态自动机trie树实际上是一个DFA，通常用转移矩阵表示。行表示状态，列表示输入字符，（行，列）位置表示转移状态。这种方式的查询效率很高，但由于稀疏的现象严重，空间利用效率很低。也可以采用压缩的存储方式即链表来表示状态转移，但由于要线性查询，会造成效率低下。 Trie树的实现Trie树的创建要考虑的是父节点如何保存孩子节点，主要有链表和数组两种方式： 使用节点数组，因为是英文字符，可以用Node[26]来保存孩子节点(如果是数字我们可以用Node[10])，这种方式最快，但是并不是所有节点都会有很多孩子，所以这种方式浪费的空间太多 用一个链表根据需要动态添加节点。这样我们就可以省下不小的空间，但是缺点是搜索的时候需要遍历这个链表，增加了时间复杂度。 查询操作 如何构建 双数组Trie树(DoubleArrayTrie)Java实现 Trie 树的以下几个特点 根节点不包含字符，除根节点外每个节点只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符都不相同，这一点也就保证了相同的前缀能够得到复用","tags":[{"name":"NLP","slug":"NLP","permalink":"https://quano.gitee.io/tags/NLP/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"Mysql数据库导入导出","date":"2019-03-26T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mysql/Mysql数据库导入导出/","text":"导出整个数据库mysqldump -h192.168.1.34 -utest -ptest database_name &gt; data_file_name 导入整个数据库mysql -h192.168.1.35 -utest -p’test’ database_name &lt; data_file_name Docker集中化web界面管理平台-Shipyard部署记录 导入csv格式数据mysqlimport -h192.168.1.34 -utest -ptest database_name —fields-terminated-by=’\\t’ ‘filepath’ —columns=’element,element_type,index‘ —local","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mysql","slug":"数据/数据处理/DataStore/Mysql","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mysql/"}]},{"title":"MySQL常见命令","date":"2019-03-26T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mysql/Mysql相关命令/","text":"创建唯一索引CREATE UNIQUE INDEX uk_content_type ON corpus(content,type_id); 修改字段类型ALTER TABLE roster ADD COLUMN del_flag int(1) DEFAULT 0 NOT NULL COMMENT ‘删除标识’; ALTER TABLE corpus add unique index uk_content(user_account_id,game_id,daily_date); ALTER TABLE roster MODIFY COLUMN del_flag COMMENT ‘0:没有删除,1:已删除’; ALTER TABLE freeze_white_list ADD column com_id bigint(20) unsigned NOT NULL DEFAULT ‘0’ COMMENT ‘公司Id’; 权限配置1234grant all privileges on *.* to nova identified by &#x27;quantumcs&#x27;;flush privileges;// 本地用户访问权限grant all privileges on *.* to nova@&#x27;127.0.0.1&#x27; identified by &#x27;quantumcs&#x27;; mysql表占用空间","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mysql","slug":"数据/数据处理/DataStore/Mysql","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mysql/"}]},{"title":"Awk文本处理神奇","date":"2019-03-24T01:56:24.000Z","path":"wk/项目管理/软件工程/Linux/Awk文本处理神奇/","text":"AWK工作流程是逐行扫描文件，从第一行到最后一行，寻找匹配特定模式的行，并在这些行上进行用户想要到的操作。 基本结构由模式匹配和处理过程组成. 1pattern &#123;action&#125; 离线上传mysql 网络状态查看查看某台服务器的tcp状态数 1netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27; awk执行shell.awk -F ‘ ‘ ‘{print $NF}’ | awk ‘{cmd=”wc -l $1”;system(cmd)}’ | more awk 多条件截取.s","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"内存查看","date":"2019-03-24T01:56:24.000Z","path":"wk/项目管理/软件工程/Linux/内存/001.内存查看/","text":"cat /proc/meminfo 可以查看系统内存使用情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546MemTotal: 8175236 kBMemFree: 3202196 kBMemAvailable: 5284992 kBBuffers: 125344 kBCached: 2060772 kBSwapCached: 0 kBActive: 3913980 kBInactive: 655548 kBActive(anon): 2412548 kBInactive(anon): 60252 kBActive(file): 1501432 kBInactive(file): 595296 kBUnevictable: 3652 kBMlocked: 3652 kBSwapTotal: 0 kBSwapFree: 0 kBDirty: 180 kBWriteback: 0 kBAnonPages: 2387064 kBMapped: 258428 kBShmem: 86964 kBSlab: 336368 kBSReclaimable: 292052 kBSUnreclaim: 44316 kBKernelStack: 10928 kBPageTables: 12948 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 4087616 kBCommitted_AS: 5205168 kBVmallocTotal: 34359738367 kBVmallocUsed: 0 kBVmallocChunk: 0 kBHardwareCorrupted: 0 kBAnonHugePages: 1951744 kBCmaTotal: 0 kBCmaFree: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 124784 kBDirectMap2M: 7215104 kBDirectMap1G: 3145728 kB MemTotal 是全部物理内存，我的虚拟器配置的是1G内存，MemAvailable = memfree+buffers+cached 当memfree不够时，内核会通过回写机制(pdflush线程)把cached和buffered内存回写到后备存储器，也可以通过手动方式显式释放cache内存 1echo 3 &gt; /proc/sys/vm/drop_caches 释放后，Buffers和Cached 表小了好多，MemFree变大了许多 进程内存","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"},{"name":"内存","slug":"项目管理/软件工程/Linux/内存","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/%E5%86%85%E5%AD%98/"}]},{"title":"01.Netty服务端启动流程","date":"2019-03-17T01:56:24.000Z","path":"wk/MicroService/技术框架/Netty/01.netty服务端启动流程/","text":"两个线程组12EventLoopGroup boosGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup(); EventLoopGroup的定义 1234567891011121314151617181920212223242526public class NioEventLoopGroup extends MultithreadEventLoopGroup&#123; /** * Sets the percentage of the desired amount of time spent for I/O in the child event loops. The default value is * &#123;@code 50&#125;, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks. */ public void setIoRatio(int ioRatio) &#123; for (EventExecutor e: children()) &#123; ((NioEventLoop) e).setIoRatio(ioRatio); &#125; &#125; /** * Replaces the current &#123;@link Selector&#125;s of the child event loops with newly created &#123;@link Selector&#125;s to work * around the infamous epoll 100% CPU bug. */ public void rebuildSelectors() &#123; for (EventExecutor e: children()) &#123; ((NioEventLoop) e).rebuildSelector(); &#125; &#125; @Override protected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception &#123; return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]); &#125;&#125; 专门用于处理网络的事件 一个用于处理接受客户端的连接，一个用于进行 SocketChannel 的网络读取。 boos这个EventLoopGroup作为一个acceptor负责接收来自客户端的请求，然后分发给worker这个EventLoopGroup来处理所有的事件event和channel的IO。 引导程序ServerBootstrap. 启动NIO服务的辅助启动类. 12345678ServerBootstrap b = new ServerBootstrap() .group(boosGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 1012) .childHandler(new ChildChannelHandler());ChannelFuture f = b.bind(port).sync(); // 绑定端口f.channel().closeFuture().sync();// 等待服务器端监听端口关闭 group方法绑定了两个NIO线程组 绑定处理消息的Handler. handler处理流程和管理流程-TODO","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"01.Netty服务端启动流程","date":"2019-03-17T01:56:24.000Z","path":"wk/MicroService/技术框架/RPC/Netty/01.netty服务端启动流程/","text":"两个线程组12EventLoopGroup boosGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup(); EventLoopGroup的定义 1234567891011121314151617181920212223242526public class NioEventLoopGroup extends MultithreadEventLoopGroup&#123; /** * Sets the percentage of the desired amount of time spent for I/O in the child event loops. The default value is * &#123;@code 50&#125;, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks. */ public void setIoRatio(int ioRatio) &#123; for (EventExecutor e: children()) &#123; ((NioEventLoop) e).setIoRatio(ioRatio); &#125; &#125; /** * Replaces the current &#123;@link Selector&#125;s of the child event loops with newly created &#123;@link Selector&#125;s to work * around the infamous epoll 100% CPU bug. */ public void rebuildSelectors() &#123; for (EventExecutor e: children()) &#123; ((NioEventLoop) e).rebuildSelector(); &#125; &#125; @Override protected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception &#123; return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]); &#125;&#125; 专门用于处理网络的事件 一个用于处理接受客户端的连接，一个用于进行 SocketChannel 的网络读取。 boos这个EventLoopGroup作为一个acceptor负责接收来自客户端的请求，然后分发给worker这个EventLoopGroup来处理所有的事件event和channel的IO。 引导程序ServerBootstrap. 启动NIO服务的辅助启动类. 12345678ServerBootstrap b = new ServerBootstrap() .group(boosGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 1012) .childHandler(new ChildChannelHandler());ChannelFuture f = b.bind(port).sync(); // 绑定端口f.channel().closeFuture().sync();// 等待服务器端监听端口关闭 group方法绑定了两个NIO线程组 绑定处理消息的Handler. handler处理流程和管理流程-TODO","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Netty","slug":"MicroService/技术框架/RPC/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/Netty/"}]},{"title":"实体Bean与Map之间的转换","date":"2019-03-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/BeanToMap/","text":"反射方式 Introspector 方式 123456789101112131415161718192021222324public static Object convertMap(Class type, Map map) throws IntrospectionException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; BeanInfo beanInfo = Introspector.getBeanInfo(type); // 获取类属性 Object obj = type.newInstance(); // 创建 JavaBean 对象 // 给 JavaBean 对象的属性赋值 PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); for (int i = 0; i&lt; propertyDescriptors.length; i++) &#123; PropertyDescriptor descriptor = propertyDescriptors[i]; String propertyName = descriptor.getName(); if (map.containsKey(propertyName)) &#123; // 下面一句可以 try 起来，这样当一个属性赋值失败的时候就不会影响其他属性赋值。 Object value = map.get(propertyName); Object[] args = new Object[1]; args[0] = value; descriptor.getWriteMethod().invoke(obj, args); &#125; &#125; return obj;&#125; 1234567891011121314151617181920// 反射方式/** * Java Map反射成POJO(ResourcesBean ) */private static ResourcesBean mapToObject(Map&lt;String, Object&gt; map, String ObjectBeanPath) &#123; ResourcesBean resourcesBean = new ResourcesBean(); try &#123; Class clazz = Class.forName(ObjectBeanPath); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; Field filed = clazz.getDeclaredField(entry.getKey()); filed.setAccessible(true); filed.set(resourcesBean, entry.getValue() != null ? String .valueOf(entry.getValue()) : &quot;&quot;); &#125; &#125; catch (Exception e) &#123; log.error(e); &#125; return resourcesBean;&#125; | 530277 | 79773174 | 1 | 1 | 4 |","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"jdk下载镜像","date":"2019-03-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/Jdk镜像/","text":"下载镜像 安装下载指定版本后解压。 配置环境变量： 123export JAVA_HOME=/opt/middleware/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"函数式接口-FunctionalInterface","date":"2019-03-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/函数式接口-FunctionalInterface/","text":"什么是函数式接口其实之前在讲Lambda表达式的时候提到过，所谓的函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。 这种类型的接口也称为SAM接口，即Single Abstract Method interfaces。 用途它们主要用在Lambda表达式和方法引用（实际上也可认为是Lambda表达式）上 12345@FunctionalInterfaceinterface GreetingService &#123; void sayMessage(String message);&#125; 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)： 1GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message); 关于@FunctionalInterface注解Java 8为函数式接口引入了一个新注解@FunctionalInterface，主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。 提醒：加不加@FunctionalInterface对于接口是不是函数式接口没有影响，该注解知识提醒编译器去检查该接口是否仅包含一个抽象方法 函数式接口里允许定义默认方法函数式接口里是可以包含默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的； 123456789101112131415@FunctionalInterfaceinterface GreetingService&#123; void sayMessage(String message); default void doSomeMoreWork1() &#123; // Method body &#125; default void doSomeMoreWork2() &#123; // Method body &#125;&#125; JDK中的函数式接口举例java.lang.Runnable,java.awt.event.ActionListener,java.util.Comparator,java.util.concurrent.Callablejava.util.function包下的接口，如Consumer、Predicate、Supplier等 Java 8 函数式接口 - Functional Interface","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"线性代数的定义","date":"2019-03-09T03:55:57.000Z","path":"wk/项目管理/软件工程/数学基础/线性代数定义/","text":"对于线性代数中的线性理解一直比较模糊。大学数学学科，线性代数是最为抽象的一门课。 从中学的初等数学和初等物理一路走来，很少人去怀疑一门数学学科是不是自然规律，当学习微积分、概率统计时也从来没有怀疑过，唯独线性代数它的各种符号和运算规则太抽象太奇怪，完全对应不到生活经验。 线性代数可以理解为一门工具，通过建立的一套模型并通过符号系统完成语法和语义的映射，方便解决线性空间的几何问题。实际上，向量、矩阵、运算规则的语法和语义都是人为的设计，这和一门语言中的各种概念性质相同，它是一种创造，但是前提是必须满足语言契约。 不像初等数学，概率论，微积分都包含着一种自然现象。从应用的角度看，线性代数是一种人为设计的领域特定语言（DSL）. 线性代数好在哪里？线性代数的核心：向量模型。 123我们在初等数学中学习的坐标系属于笛卡尔所提出的解析模型，这个模型很有用，但同时也有很大的缺点。坐标系是人为加上的虚拟参考系，但是我们要解决的问题，比如求面积，图形旋转、拉伸等应用都是和坐标系无关的，建立一个虚拟的坐标系往往无助于解决问题，刚才三角形面积的例子就是这样。向量模型很好地克服了解析模型的缺点，如果说解析模型代表了某种“绝对性”的世界观，那么向量模型就代表了某种“相对性”的世界观，我推荐把向量模型和解析模型看作对立的两种模型。 向量模型中定义了向量和标量的概念。向量具有大小和方向，满足线性组合法则；标量是只有大小没有方向的量（注：标量的另一种更深刻的定义是在旋转变换下保持不变的量）。向量模型的优点之一是其坐标系无关性，也就是相对性，它在定义向量和运算规则的时候从一开始就抛开了坐标系的束缚，不管你坐标轴怎么旋转，我都能适应，向量的线性组合、内积、叉积、线性变换等等运算全部都是坐标系无关的。注意，所谓坐标系无关性不是说就没有坐标系了，还是有的，刚才三角形例子的顶点就是用坐标表示的，只是在解决问题的时候不同的坐标系不会构成影响。用一个比喻，Java号称平台无关，不是说Java就是空中楼阁，而是说你用Java编程时底层是Linux还是Windows往往对你没有影响。 学术界严格的定义线性线性关系 L(x)具有以下两个性质：可加性： { L(x+t)=L(x)+L(t)} { L(x+t)=L(x)+L(t)}一次齐次性： { L(mx)=mL(x)} { L(mx)=mL(x)} 线性，通俗地说，就是变量只有两种运算，数乘与加减。数乘就是kx，把x放缩为原来的k倍；加减就是x±y±z，不能有x²，xy或者sin(x)这种花里胡哨的形式。因此，线性组合的定义，就是ax+by+cz+…，其中abc…为常数，xyz…为变量。 什么是线性和非线性 线性与非线性的区别什么是线性和非线性 线性与非线性的区别 在数学上，线性关系是指自变量x与因变量yo之间可以表示成y=ax+b ,（a,b为常数），即说x与y之间成线性关系。 不能表示成y=ax+b ,（a,b为常数），即非线性关系，非线性关系可以是二次，三次等函数关系，也可能是没有关系。 机器学习中线性模型和非线性的区别机器学习中线性模型和非线性的区别 线性模型与非线性模型判别 【神经网络】线性模型非线性模型，感知机与神经网络 神经网络是非线性的解释 线性模型可以是用曲线拟合样本，但是分类的决策边界一定是直线的，例如logistics模型 区分是否为线性模型：最简单判别一个模型是否为线性的，只需要判别决策边界是否是直线，也就是是否能用一条直线来划分 区分是否为线性模型，主要是看一个乘法式子中自变量x前的系数w,如果w只影响一个x，那么此模型为线性模型。或者判断决策边界是否是线性的 神经网络是非线性 浅谈机器学习中的非线性 程序观点下的线性代数","tags":[{"name":"数学","slug":"数学","permalink":"https://quano.gitee.io/tags/%E6%95%B0%E5%AD%A6/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"数学基础","slug":"项目管理/软件工程/数学基础","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"HashMap扩容","date":"2019-03-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/HashMap/HashMap扩容/","text":"HashMap的扩容机制—-resize()","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"HashMap","slug":"平台工具/程序语言/Java/HashMap","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/HashMap/"}]},{"title":"线程状态说明及状态流转","date":"2019-03-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Java/多线程/001.线程状态/","text":"Java中线程的状态分为6种。 各个状态怎么流转来的就绪状态 调用线程的start()方法 当前线程sleep()方法结束 其他线程join()结束 等待用户输入完毕 某个线程拿到对象锁 当前线程时间片用完了，调用当前线程的yield()方法 锁池里的线程拿到对象锁后，进入就绪状态 运行中从可运行池中选择一个线程作为当前线程时线程所处的状态。 这也是线程进入运行状态的唯一一种方式 阻塞状态 线程阻塞在进入synchronized关键字修饰的方法 或synchronized代码块(获取锁)时的状态 等待 WAITING不会被分配CPU执行时间. 它们要等待被显式地唤醒. 否则会处于无限期等待的状态 超时等待不会被分配CPU执行时间 不过无须无限期等待 被其他线程显示地唤醒. 达到一定时间后会自动唤醒 终止状态 当线程的run()方法完成时。或者主线程的main()方法完成时。 线程对象也许是活的，但是已经不是单独执行的了，一旦终止，不能复生 在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 等待队列 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。 LockSupport.park()/LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines) 等 Java线程的6种状态及切换","tags":[{"name":"Java","slug":"Java","permalink":"https://quano.gitee.io/tags/Java/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"},{"name":"多线程","slug":"平台工具/程序语言/Java/多线程","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"02.Netty的NioEventLoop","date":"2019-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/002.Netty中的NioEventLoop/","text":"几点简单的概述 是一个基于JDK NIO的异步事件循环类; 负责处理一个Channel的所有事件在这个Channel的生命周期期间 整个生命周期只会依赖于一个单一的线程来完成 一个NioEventLoop可以分配给多个Channel NioEventLoop通过JDK Selector来实现I/O多路复用; 以对多个Channel进行管理。 如果调用Channel操作的线程是EventLoop所关联的线程，那么该操作会被立即执行;否则会将该操作封装成任务放入EventLoop的任务队列中 所有提交到NioEventLoop的任务都会先放入队列中，然后在线程中以有序(FIFO)/连续的方式执行所有提交的任务。 NioEventLoop的事件循环主要完成了：a)已经注册到Selector的Channel的监控，并在感兴趣的事件可执行时对其进行处理；b)完成任务队列(taskQueue)中的任务，以及对可执行的定时任务和周期性任务的处理(scheduledTaskQueue中的可执行的任务都会先放入taskQueue中后，再从taskQueue中依次取出执行)。","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"02.Netty的NioEventLoop","date":"2019-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/02.Netty的NioEventLoop/","text":"NioEventLoop1234567891011121314151617181920212223public final class NioEventLoop extends SingleThreadEventLoop &#123; private Selector selector; private Selector unwrappedSelector; private SelectedSelectionKeySet selectedKeys; private final SelectorProvider provider; /** * Boolean that controls determines if a blocked Selector.select should * break out of its selection process. In our case we use a timeout for * the select method and the select method will block for that time unless * waken up. */ private final AtomicBoolean wakenUp = new AtomicBoolean(); private final SelectStrategy selectStrategy; private volatile int ioRatio = 50; private int cancelledKeys; private boolean needsToSelectAgain; ...&#125; NioEventLoop 是Netty的核心类。 NioEventLoop 的首要职责就是为注册在它上的 channels 服务，发现这些 channels 上发生的新连接事件、读写等 I/O 事件，然后将事件转交 channel 流水线处理。 NioEventLoop 的职责 核心逻辑NioEventLoop最核心的地方在于事件循环，具体代码在NioEventLoop.java在run方法中，如下逻辑： 首先根据默认的选择策略DefaultSelectStrategy判断本次循环是否select，具体逻辑为：如果当前有任务则使用selectNow立刻查询是否有准备就绪的I/O；如果当前没有任务则返回SelectStrategy.SELECT，并将wakenUp设置为false，并调用select()进行查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; // &#x27;if (wakenUp.get()) &#123; ... &#125;&#x27;. (OK) case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); // &#x27;wakenUp.compareAndSet(false, true)&#x27; is always evaluated // before calling &#x27;selector.wakeup()&#x27; to reduce the wake-up // overhead. (Selector.wakeup() is an expensive operation.) // // However, there is a race condition in this approach. // The race condition is triggered when &#x27;wakenUp&#x27; is set to // true too early. // // &#x27;wakenUp&#x27; is set to true too early if: // 1) Selector is waken up between &#x27;wakenUp.set(false)&#x27; and // &#x27;selector.select(...)&#x27;. (BAD) // 2) Selector is waken up between &#x27;selector.select(...)&#x27; and // In the first case, &#x27;wakenUp&#x27; is set to true and the // following &#x27;selector.select(...)&#x27; will wake up immediately. // Until &#x27;wakenUp&#x27; is set to false again in the next round, // &#x27;wakenUp.compareAndSet(false, true)&#x27; will fail, and therefore // any attempt to wake up the Selector will fail, too, causing // the following &#x27;selector.select(...)&#x27; call to block // unnecessarily. // // To fix this problem, we wake up the selector again if wakenUp // is true immediately after selector.select(...). // It is inefficient in that it wakes up the selector for both // the first case (BAD - wake-up required) and the second case // (OK - no wake-up required). if (wakenUp.get()) &#123; selector.wakeup(); &#125; // fall through default:&#125;cancelledKeys = 0;needsToSelectAgain = false;final int ioRatio = this.ioRatio;if (ioRatio == 100) &#123; try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. runAllTasks(); &#125;&#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125;&#125; SelectStrategySelectStrategy selectStrategy12345678final class DefaultSelectStrategy implements SelectStrategy &#123; static final SelectStrategy INSTANCE = new DefaultSelectStrategy(); private DefaultSelectStrategy() &#123; &#125; @Override public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123; return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; &#125;&#125; Netty源码笔记 Reactor线程模型详解(二)NioEventLoop的执行 Netty源码分析之NioEventLoop","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"03.Netty之Channel","date":"2019-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/03.Netty之Channel/","text":"Netty之Channel*","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"02.Netty的NioEventLoop","date":"2019-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/总结/001.网络-Netty、Tomcat、安全/","text":"1. 几种网络IO介绍下(BIO、NIO、AIO)网络中，客户端与请求的集中关系： 客户端阻塞，请求同步(时刻检测服务端是否给出响应), 发请求后，一直等待响应 客户端非阻塞，请求同步： client发送请求后。轮询服务端是否给出响应 客户端阻塞，请求异步（服务端完成之后，通知客户端），client发请求后，一直等待服务端返回响应 客户端非阻塞，请求异步： client发送请求后，去执行别的任务，服务端给出响应后，通知客户端. NIO 是同步非阻塞IO. 使用NIO读取数据时， 线程不会阻塞，需要线程主动去查询是否有IO事件。（selector） AIO NIO2.0，异步非阻塞IO，使用AIO读取数据时，线程不会阻塞，并当有数据可读时会通知给线程，不需要主动查询 适用于连接较多、操作时间长. 例如相册服务. 2. NIO的核心组件 channel、buffer、selector 每个channel对应一个buffer缓冲区，buffer的内容通过channel进行传递 channel注册到selector,selector根据channel上发送的读写事件，将请求交给空闲线程. buffer和channel都是可读可写的. 3. select、epoll、poll的区别 select模型，维护一个通道（FD）的集合(FD_set), 扫描这些所有的fd, 将fd复制到内核空间，由内核空间激活，再通过socket连接完成io 12使用 数组 来存储Socket，容量固定，通过轮询来判断是否发送IO事件，开销比较大、需要数据零拷贝，容量受限制 poll模型，使用链表存储FD(socket), 1机制和select差不多，将FD_set结构进行优化，但是也需要拷贝fd epoll模型，EventPoll, 时间通知模型（事件驱动）， 不再扫描所有fd, 将用户关心的事件存放再一个内核的事件表中，当socket发送IO事件后，应用程序才进行IO操作，不主动轮询 12epoll事件回调，红黑树，无上限，IO效率高.???? 红黑树的作用&gt;&gt; 4. 零拷贝避免让cpi执行大量数据拷贝任务，应用程序再需要把内核中的一块区域数据转移到另外一块内核区域时，不需要先复制到用户空间。 5. Netty和TomcatNetty,基于NIO的异步网络通信框架、性能高、封装了原生NIO. 12封装的是IO模型，关注网络数据的传输，不关心具体的协议异步、高性能、高扩展、高可定制化、易用性 Tomcat，一个web服务器，Servlet容器，内部只会运行Servlet程序，处理HTTP请求. 6.Netty高性能体现在哪些方面 NIO模型，用最少资源做更多事情 内存零拷贝，减少不必要的内存拷贝 内存池设计，申请的内存可以复用，主要指直接内存 串行化处理读写，避免使用锁带来的性能开销，消息的处理尽可能再同一个线程内完成。 不做线程却换，避免多线程竞争和同步锁. 12表面上看串行化设计的CPU利用率不高，并发程度不高，但是通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行重点： 这种局部无锁化的串行线程设计比一个队列，多个工作线程模型性能更有 高性能序列化协议，支持protobuf等高性能序列化协议 高效并发编程，大量使用volatile; CAS和原子类 的广泛应用；线程安全容器；通过读写锁提升并发性能. 7.Netty线程模型 支持Reactor单线程模型，Reactor多线程模型、主从多线程模型. 可通过参数切换 8.Tomcat为什么要使用自定义类加载器. 部署多个应用. 9. Tomcat优化 两方面：内存和线程. 10.跨域请求.11. CSRF攻击12. OAuth2.013. JWT令牌14.SSO15. 认证和授权16. RBAC分类17. 如何设计一个开放授权平台18. 嵌入式服务器网络","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"},{"name":"网络","slug":"网络","permalink":"https://quano.gitee.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://quano.gitee.io/tags/Tomcat/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"},{"name":"总结","slug":"MicroService/技术框架/Netty/总结","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/%E6%80%BB%E7%BB%93/"}]},{"title":"03.Netty之Channel","date":"2019-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/RPC/Netty/03.Netty之Channel/","text":"Netty之Channel*","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Netty","slug":"MicroService/技术框架/RPC/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/Netty/"}]},{"title":"02.Netty的NioEventLoop","date":"2019-03-08T17:13:34.000Z","path":"wk/MicroService/技术框架/RPC/Netty/02.Netty的NioEventLoop/","text":"NioEventLoop1234567891011121314151617181920212223public final class NioEventLoop extends SingleThreadEventLoop &#123; private Selector selector; private Selector unwrappedSelector; private SelectedSelectionKeySet selectedKeys; private final SelectorProvider provider; /** * Boolean that controls determines if a blocked Selector.select should * break out of its selection process. In our case we use a timeout for * the select method and the select method will block for that time unless * waken up. */ private final AtomicBoolean wakenUp = new AtomicBoolean(); private final SelectStrategy selectStrategy; private volatile int ioRatio = 50; private int cancelledKeys; private boolean needsToSelectAgain; ...&#125; NioEventLoop 是Netty的核心类。 NioEventLoop 的首要职责就是为注册在它上的 channels 服务，发现这些 channels 上发生的新连接事件、读写等 I/O 事件，然后将事件转交 channel 流水线处理。 NioEventLoop 的职责 核心逻辑NioEventLoop最核心的地方在于事件循环，具体代码在NioEventLoop.java在run方法中，如下逻辑： 首先根据默认的选择策略DefaultSelectStrategy判断本次循环是否select，具体逻辑为：如果当前有任务则使用selectNow立刻查询是否有准备就绪的I/O；如果当前没有任务则返回SelectStrategy.SELECT，并将wakenUp设置为false，并调用select()进行查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; // &#x27;if (wakenUp.get()) &#123; ... &#125;&#x27;. (OK) case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); // &#x27;wakenUp.compareAndSet(false, true)&#x27; is always evaluated // before calling &#x27;selector.wakeup()&#x27; to reduce the wake-up // overhead. (Selector.wakeup() is an expensive operation.) // // However, there is a race condition in this approach. // The race condition is triggered when &#x27;wakenUp&#x27; is set to // true too early. // // &#x27;wakenUp&#x27; is set to true too early if: // 1) Selector is waken up between &#x27;wakenUp.set(false)&#x27; and // &#x27;selector.select(...)&#x27;. (BAD) // 2) Selector is waken up between &#x27;selector.select(...)&#x27; and // In the first case, &#x27;wakenUp&#x27; is set to true and the // following &#x27;selector.select(...)&#x27; will wake up immediately. // Until &#x27;wakenUp&#x27; is set to false again in the next round, // &#x27;wakenUp.compareAndSet(false, true)&#x27; will fail, and therefore // any attempt to wake up the Selector will fail, too, causing // the following &#x27;selector.select(...)&#x27; call to block // unnecessarily. // // To fix this problem, we wake up the selector again if wakenUp // is true immediately after selector.select(...). // It is inefficient in that it wakes up the selector for both // the first case (BAD - wake-up required) and the second case // (OK - no wake-up required). if (wakenUp.get()) &#123; selector.wakeup(); &#125; // fall through default:&#125;cancelledKeys = 0;needsToSelectAgain = false;final int ioRatio = this.ioRatio;if (ioRatio == 100) &#123; try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. runAllTasks(); &#125;&#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125;&#125; SelectStrategySelectStrategy selectStrategy12345678final class DefaultSelectStrategy implements SelectStrategy &#123; static final SelectStrategy INSTANCE = new DefaultSelectStrategy(); private DefaultSelectStrategy() &#123; &#125; @Override public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123; return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; &#125;&#125; Netty源码笔记 Reactor线程模型详解(二)NioEventLoop的执行 Netty源码分析之NioEventLoop","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Netty","slug":"MicroService/技术框架/RPC/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/Netty/"}]},{"title":"NLP_ability","date":"2019-03-06T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/001.Readme/","text":"NLP_abilityNLP_ability","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"FastText","date":"2019-03-06T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/FastText/","text":"ngramfastText可以在词向量的训练和句子分类上取得非常好的表现，尤其表现在对罕见词进行字符粒度上的处理。 每个单词除了单词本身外还被表示为多个字符级别的n-grams(有时候也称为N元模子) 例如对于单词 matter. 当n=3时， fasttext对该词对字符ngram就表示为 1&lt;ma, mat, att, tte, ter, er&gt; 其中&lt; 和 &gt; 是作为边界符号被添加，来将一个单词的ngrams与单词本身区分开来。 再举一个例子，如果单词mat属于我们的词汇表，则会被表示为 . 这么做刚好让一些短词以其他词的ngram出现，有助于更好的学习到这些短词的含义。 从本质上讲，这可以帮助你捕捉后缀/前缀的含义。 minn,maxn可以通过-minn和-maxn这两个参数来控制ngrams的长度，这两个标志分别决定了ngrams的最小和最大字符数，也即控制了ngrams的范围。 这个模型被认为是一个词袋模型，因为除了用于选择n-gram的滑动窗口外,它并没有考虑对单词的内部结构进行特征选择。 它只要求字符落在窗口以内，但并不关心ngrams的顺序。 你可以将这两个值都设为0来完全关闭n-gram. 也就是不产生n-gram符号，单纯用单词作为输入. 当您的模型中的“单词”不是特定语音的单词时或者说字符级别的n-gram没有意义的时候，这会变得很有用。最常见的例子是当您将id作为您的单词输入。 在模型更新期间，fastText会学习到每个ngram以及整个单词符号的权重。 读取数据虽然fastText的训练是多线程的，但是读取数据却是通过单线程来完成。而文本解析和分词则在读取输入数据时就被完成了。让我们来看看具体是怎么做到的: FastText通过-input参数获取一个文件句柄用于输入数据。FastText不支持从stdin读取数据，它初始化两个向量word2int和words来跟踪输入信息。 word2int是一个字符串到数值的映射集，索引键是单词字符串，根据字符串哈希值可以得到一个数值作为它的值，同时这个数值恰好就对应到了words数组(std:::vector)的索引。 words_数组在读取输入时根据单词出现的顺序递增创建索引，每个索引对应的值是一个结构体entry，这个entry封装了单词的所有信息。条目包含以下信息: 123456struct entry &#123; std::string word; int64_t count; entry_type type; std::vector&lt;int32_t&gt; subwords;&#125;; https://baijiahao.baidu.com/s?id=1606667200878009384&amp;wfr=spider&amp;for=pc","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"简单线性回归实现","date":"2019-03-03T15:55:57.000Z","path":"wk/算法/001.机器学习/机器学习100天/002.简单线性回归实现/","text":"第一步：数据预处理12345678910import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdataset = pd.read_csv(&#x27;studentscores.csv&#x27;)X = dataset.iloc[ : , : 1 ].valuesY = dataset.iloc[ : , 1 ].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split( X, Y, test_size = 1/4, random_state = 0) 第二步：训练集使用简单线性回归模型来训练123from sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor = regressor.fit(X_train, Y_train) 第三步：预测结果1Y_pred = regressor.predict(X_test) 第四步：可视化123456789101112131415161718192021222324252627import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import train_test_splitdataset = pd.read_csv(&#x27;~/Documents/100-Days-Of-ML-Code/datasets/studentscores.csv&#x27;)X = dataset.iloc[ : , : 1 ].valuesY = dataset.iloc[ : , 1 ].valuesX_train, X_test, Y_train, Y_test = train_test_split( X, Y, test_size = 1/4, random_state = 0) from sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor = regressor.fit(X_train, Y_train)Y_pred = regressor.predict(X_test)plt.scatter(X_train , Y_train, color = &#x27;red&#x27;)plt.plot(X_train , regressor.predict(X_train), color =&#x27;blue&#x27;)plt.show()plt.scatter(X_test , Y_test, color = &#x27;red&#x27;)plt.plot(X_test , regressor.predict(X_test), color =&#x27;blue&#x27;)plt.show()","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习100天","slug":"算法/001-机器学习/机器学习100天","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"}]},{"title":"数据预处理","date":"2019-02-28T15:55:57.000Z","path":"wk/算法/001.机器学习/机器学习100天/001.数据预处理/","text":"导入需要的包numpy, pandas 导入数据集数据集通常为.csv格式. 使用Pandas的read_csv方法读取本地csv文件为一个数据帧。 然后，从数据帧中制作自变量和因变量的矩阵和向量。 处理丢失数据集大多数据集是不完整的，为了不降低机器学习模型的性能，需要处理数据。 可以使用整列的平均值或中间值替换丢失的数据。我们使用sklean.preprocssing库中的Imputer类完成这项任务。 解析分类数据分类数据指的是含有标签值而不是数字值的变量。取值范围通常是固定的。例如”Yes”和“No”.不能用于模型的数学计算，所以需要解析成数字。 为了实现这一功能，我们从sklearn.preprocesing库中导入LabelEncoder类。 拆分数据集为测试集合和训练集合一般比例为80:20 导入sklearn.crossvalidation库中的train_test_split()方法。 特征缩放大部分模型算法使用两点间的欧式距离表示，但此特征在幅度、单位和范围姿态问题上变化很大。 在距离计算中，高幅度的特征比低幅度特征权重更大。可用特征标准化或Z值归一化解决。 导入sklearn.preprocessing库中的StandardScalar类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#Day 1: Data Prepocessing#Step 1: Importing the librariesimport numpy as npimport pandas as pd#Step 2: Importing datasetdataset = pd.read_csv(&#x27;../datasets/Data.csv&#x27;)X = dataset.iloc[ : , :-1].valuesY = dataset.iloc[ : , 3].valuesprint(&quot;Step 2: Importing dataset&quot;)print(&quot;X&quot;)print(X)print(&quot;Y&quot;)print(Y)#Step 3: Handling the missing datafrom sklearn.preprocessing import Imputerimputer = Imputer(missing_values = &quot;NaN&quot;, strategy = &quot;mean&quot;, axis = 0)imputer = imputer.fit(X[ : , 1:3])X[ : , 1:3] = imputer.transform(X[ : , 1:3])print(&quot;---------------------&quot;)print(&quot;Step 3: Handling the missing data&quot;)print(&quot;step2&quot;)print(&quot;X&quot;)print(X)#Step 4: Encoding categorical datafrom sklearn.preprocessing import LabelEncoder, OneHotEncoderlabelencoder_X = LabelEncoder()X[ : , 0] = labelencoder_X.fit_transform(X[ : , 0])#Creating a dummy variableonehotencoder = OneHotEncoder(categorical_features = [0])X = onehotencoder.fit_transform(X).toarray()labelencoder_Y = LabelEncoder()Y = labelencoder_Y.fit_transform(Y)print(&quot;---------------------&quot;)print(&quot;Step 4: Encoding categorical data&quot;)print(&quot;X&quot;)print(X)print(&quot;Y&quot;)print(Y)#Step 5: Splitting the datasets into training sets and Test setsfrom sklearn.model_selection import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split( X , Y , test_size = 0.2, random_state = 0)print(&quot;---------------------&quot;)print(&quot;Step 5: Splitting the datasets into training sets and Test sets&quot;)print(&quot;X_train&quot;)print(X_train)print(&quot;X_test&quot;)print(X_test)print(&quot;Y_train&quot;)print(Y_train)print(&quot;Y_test&quot;)print(Y_test)#Step 6: Feature Scalingfrom sklearn.preprocessing import StandardScalersc_X = StandardScaler()X_train = sc_X.fit_transform(X_train)X_test = sc_X.transform(X_test)print(&quot;---------------------&quot;)print(&quot;Step 6: Feature Scaling&quot;)print(&quot;X_train&quot;)print(X_train)print(&quot;X_test&quot;)print(X_test)","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习100天","slug":"算法/001-机器学习/机器学习100天","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0100%E5%A4%A9/"}]},{"title":"nebula容器化","date":"2019-02-28T15:55:57.000Z","path":"wk/算法/001.机器学习/003.知识图谱/存储/nebula/001.nebula容器化/","text":"des 部署方式有多种方式可以部署 Nebula Graph. Docker Compose. Docker Compose 是最快的方式. Docker Compose 方式安装.使用 Docker Compose 部署 Nebula Graph 123git clone -b v3.0.0 https://github.com/vesoft-inc/nebula-docker-compose.gitcd nebula-docker-compose/docker-compose up -d docker-compose.yaml 的解读见下一篇文章. 安装后 使用 nebula client 链接nebula-console 12# 进入容器docker run --rm -ti --network nebula-docker-compose_nebula-net --entrypoint=/bin/sh vesoft/nebula-console 1nebula-console -u root -p 123 --address=172.18.0.10 --port=9669 1. 相关命令2. nGQL3. 图构建4. 图建模 以性能为目标进行建模 没有完美的建模方法， 如何建模取决于想从数据中挖掘的内容。分析数据并根据业务模型创建方便直观的数据模型，测试模型并优化，逐渐适应业务。为了更好的性能， 可以多次更改或重新设计模型. 合理设置边属性.","tags":[{"name":"Graph","slug":"Graph","permalink":"https://quano.gitee.io/tags/Graph/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"003.知识图谱","slug":"算法/001-机器学习/003-知识图谱","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"存储","slug":"算法/001-机器学习/003-知识图谱/存储","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%98%E5%82%A8/"},{"name":"nebula","slug":"算法/001-机器学习/003-知识图谱/存储/nebula","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%98%E5%82%A8/nebula/"}]},{"title":"nebula应用","date":"2019-02-28T15:55:57.000Z","path":"wk/算法/001.机器学习/003.知识图谱/存储/nebula/002.nebula应用例子/","text":"总结nebula应用场景及流程.","tags":[{"name":"Graph","slug":"Graph","permalink":"https://quano.gitee.io/tags/Graph/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"003.知识图谱","slug":"算法/001-机器学习/003-知识图谱","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"存储","slug":"算法/001-机器学习/003-知识图谱/存储","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%98%E5%82%A8/"},{"name":"nebula","slug":"算法/001-机器学习/003-知识图谱/存储/nebula","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/003-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E5%AD%98%E5%82%A8/nebula/"}]},{"title":"在看的书和文章","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/在看的书和文章/","text":"个人博客 Docker — 从入门到实践 学习java设计模式 设计模式之禅（第2版） hadoop-notebook gitee-pages 有趣的文章Web应用架构演进及系统性能、稳定性所需要解决的问题 dubbo学习过程、使用经验分享及实现原理简单介绍","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}]},{"title":"规则引擎入门","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/Drools/001.规则引擎入门/","text":"Drools Documentation Drools概述业务决策自动化 任何一家组织或企业都面临着作出决定或决策性的问题，这些问题通常比较复杂，一般都需要算法分析大量决策相关的数据，例如当前一些热门的话题，如物联网、人工智能、认知计算都基于算法分析海量数据，产生有用信息的过程。Drools 作为一个开源的推理引擎，有 20 年历史，基于规则匹配算法非常适用与与这一场景。 用于业务规则管理，业务资源优化和复杂事件处理（CEP）。 构建一个全面的业务自动化平台 语法见Documennt 复杂规则编写: 条件元素，比较运算符,两种dialect的比较 CEP复杂时间处理. 复杂时间是多事件的事件处理概念，目标是在事件集合（事件流，事件云）中识别用户定义的有意义事件，CEP采用诸如检测许多事件的复杂模式，事件关联和抽象以及事件层的流程。 丢失包裹检测 规则设计要求： 设计规则检测如果一个包裹在通过 CHECK_IN 位置 10 分钟以后是否通过 SORTING 位置，如果否则说明规则丢失。 包裹数统计 编写规则统计最近一小时内经过 SORTING 位置的包裹总数。 包裹重量统计 编写规则统计统计过去通过 CHECK_IN 的 5 个包裹的平均重量。 统计包裹从 CHECK_IN 到 SORTING 的平均时间 包裹扫描系统需要统计过去 5 个连续的包裹从 CHECK_IN 到 SORTING 的平均处理时间。 Entry Point 插入事件 编辑规则可以获取不同位置的包裹。 规则整合通过不同的方式来管理获取规则 优化问题LABS本部分通过实验来验证 Drools 相关的理论及概念。 drools-examples doc drools-examples github 业务规则的定义抽象.规则有哪些元素组成. 规则的执行流程多个规则的智行顺序和规则管理","tags":[{"name":"规则引擎","slug":"规则引擎","permalink":"https://quano.gitee.io/tags/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Drools","slug":"平台工具/工具组件/Drools","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Drools/"}]},{"title":"Redis的安装及集群配置","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/ActiveMQ/","text":"ActiveMQ官方下载地址 安装启动 第一步：把ActiveMQ 的压缩包上传到Linux系统 第二步：解压缩 第三步：启动12345678910使用bin目录下的activemq命令启动：[root@localhost bin]# ./activemq start关闭：[root@localhost bin]# ./activemq stop查看状态：[root@localhost bin]# ./activemq status进入管理后台：http://IP:8161/admin用户名：admin密码：admin 登录用户名密码可在 conf/jetty-realm.properties 文件中修改","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Elasticsearch","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/ElasticSearch/","text":"ElasticsearchElasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它： 分布式的实时文件存储，每个字段都被索引并可被搜索 分布式的实时分析搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据 官方网址 官方Github 官方中文权威指南 官方Java API文档 推荐学习资源 Elasticsearch Java API 手册 Elasticsearch权威指南 安装环境 CentOS7 依赖 Java 8+ 安装Elasticsearch 官方下载地址 解压安装包 # tar zxvf elasticsearch-5.6.2.tar.gz 运行elasticsearch脚本启动 # cd /elasticsearch-5.6.2/bin # ./elasticsearch 后台启动：# ./elasticsearch -d 踩坑解决错误 内存不足 Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=&#39;Cannot allocate memory&#39; (errno=12) 因个人服务器只有1g内存，需配置 elasticsearch/config/jvm.options，只有根据服务器改小分配堆空间的最大值了(或者启用Swap交换分区)： 123456789################################################################# Xms represents the initial size of total heap space# Xmx represents the maximum size of total heap space-Xms128m-Xmx128m################################################################ root账号错误 [WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [] uncaught exception in thread [main] org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:125) ~[elasticsearch-5.2.0.jar:5.2.0] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:112) ~[elasticsearch-5.2.0.jar:5.2.0] at ... 6 more 由于ElasticSearch可以接收用户输入的脚本并且执行，为了系统安全考虑，建议创建一个单独的用户用来运行ElasticSearch 创建elsearch用户组及elsearch用户 groupadd es useradd es -g es -p es 更改Elasticsearch文件夹及内部文件的所属用户及组为es:es chown -R es:es /usr/local/elasticsearch 切换到elsearch用户再启动 su es cd elasticsearch/bin ./elasticsearch 最大虚拟内存过小错误 ERROR: bootstrap checks failed max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 切换至root用户：su root 修改虚拟内存配置至提示的最低值：sysctl -w vm.max_map_count=262144 日志权限错误 进入 elasticsearch/logs 文件夹下修改文件权限：chmod 744 * 外网无法访问 http://你的服务器IP:9200/ 修改 elasticsearch/config/elasticsearch.yml 配置文件：network.host: 0.0.0.0 123456789101112# ---------------------------------- Network -----------------------------------## Set the bind address to a specific IP (IPv4 or IPv6):#network.host: 0.0.0.0# Set a custom port for HTTP:#http.port: 9200## For more information, consult the network module documentation.## --------------------------------- Discovery ---------------------------------- 测试是否启动成功访问 http://127.0.0.1:9200 插件Elasticsearch-head安装Head-GitHub官网 依赖：Git Node.js 官网安装教程 1234git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run start 打开浏览器输入：IP:9100 正常的话可以看到已经连接了ES，但是看不到连接信息，这时候需要在在 es 的 elasticsearch.yml 里添加如下配置： http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; 插件Elasticsearch-Analysis-IK安装IK Analysis-GitHub官网 预编译安装包下载(注意需下载对应Elasticsearch版本的IK插件) 官网安装教程 解压预编译包 elasticsearch-analysis-ik-&#123;version&#125;.zip 后拷贝至elasticsearch安装目录plugins文件夹下，重命名解压后的文件夹名为ik： your-es-root/plugins/ik 重启Elasticsearch即可（关闭ES：杀进程：ps -aux|grep elasticsearch、kill -9 进程ID号","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Maven的安装配置使用","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/Maven安装配置使用/","text":"Maven的安装配置使用 下载maven 官方网站 Maven是使用java开发，需要安装JDK1.6以上 安装maven 第一步：安装JDK1.6及以上 第二步：将maven下载的压缩包进行解压缩 第三步：配置maven的环境变量MAVEN_HOME 第四步：配置maven的环境变量PATH 第五步：测试maven是否安装成功，在系统命令行中执行命令：mvn –v 配置maven 在maven中有两个配置文件：用户配置、全局配置（默认） 全局配置 在maven安装目录的conf里面有一个settings.xml文件，这个文件就是maven的全局配置文件。 该文件中配置来maven本地仓库的地址 默认在系统的用户目录下的m2/repository中，该目录是本地仓库的目录。 Maven命令的使用 Maven的命令要在pom.xml所在目录中去执行，可在pom.xml所在文件夹中按住shift右键，点击“在此处启动命令窗口” mvn compile编译的命令 mvn clean清除命令，清除已经编译好的class文件，具体说清除的是target目录中的文件 mvn test测试命令，该命令会将test目录中的源码进行编译 mvn package打包命令 Mvn install安装命令，会将打好的包，安装到本地仓库 组合命令 mvn clean compile 先清空再编译 mvn clean test 先执行clean，再执行test，通常应用于测试环节 mvn clean package 先执行clean，再执行package，将项目打包，通常应用于发布前执行过程： 清理————清空环境 编译————编译源码 测试————测试源码 打包————将编译的非测试类打包 mvn clean install 查看仓库，当前项目被发布到仓库中 组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前 执行过程： 清理————清空环境 编译————编译源码 测试————测试源码 打包————将编译的非测试类打包 部署————将打好的包发布到资源仓库中 IDEA中Maven配置","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"JRebel 安装使用","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/JRebel/","text":"IntelliJ IDEA - JRebel 安装使用JRebel能做什么 以前Tomcat中解决方案： 修改server.xml的配置：&lt;Context path=&quot;/helloapp&quot; docBase=&quot;helloapp&quot; reloadable=&quot;true&quot;/&gt; 但改 java代码后果是tomcat会重启整个项目。 JRebel是一款热部署插件。当你的Java-Web项目在Tomcat中run/debug的时候，修改某一个java文件时，JRebel就可以解决在项目运行状态run/debug状态下任意修改java文件并动态反馈实时更新到运行的项目中。 JRebel插件获取与安装 插件安装 IDEA中 File-Settings-Plugin 中搜索JRebel下载安装后重启IDEA 激活 网友分享激活链接 JRebel使用 普通Spring Web应用添加Tomcat等服务器容器配置时，VM option 下方都勾选Update classes and resources，Spring Boot项目忽略此步骤，但IDEA编译器需设置自动编译 左下角勾选要使用热部署的项目模块，在IDEA上方菜单栏中找到JRebel按钮选择以JRebel启动项目 添加热部署的模块可在 resource 中看到 rebel.xml 配置文件，打开可看到其监听的文件夹，当然可根据自己需求修改","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Linux常用命令","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/Linux常用命令/","text":"Linux常用命令 查看内存使用情况：free -h -h：显示可用mb单位 修改文件权限：chmod 777 * 切换用户： su root 解压 tar包：tar -xvf file.tar 解压tar.gz：tar -xzvf file.tar.gz 解压tar.xz：tar xvJf file.tar.xz 解压rar：unrar e file.rar 解压zip：unzip file.zip 下载网络文件 wget http://file.zip 改变文件所有者 chown [选项] [所有者]:[组] file -R 处理指定目录以及其子目录下的所有文件 查看进程 ps -ef | grep java 或 ps -aux | grep java -aux 显示所有状态 查看端口 netstat -nap|grep 端口号 终止进程 kill -9 [PID] Tomcat查看日志 cd logs tail -f catalina.out yum -y install 包名（支持*） ：自动选择y，全自动 yum install 包名（支持*） ：手动选择y or n yum remove 包名（不支持*） rpm -ivh 包名（支持*）：安装rpm包 rpm -e 包名（不支持*）：卸载rpm包JAVA开发环境常用软件安装及配置 更新yum：yum update JDK1.8安装 查看可安装JDK版本： yum list java* 安装指定1.8版本： yum -y install java-1.8.0-openjdk* 查看是否安装成功：java -version MariaDB(MySQL)数据库安装 注：默认CentOS7已没有MySQL源, MySQL隶属的sun公司被甲骨文收购，担心闭源的社区人员维护的一个新的分支 安装：yum install mariadb-server 配置初始化 启动服务 service mariadb start 初始化命令 mysql_secure_installation12345678910111213Set root password? [Y/n] &lt;– 是否设置root用户密码，建议yNew password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 确认你设置的密码其他配置Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，建议yDisallow root login remotely? [Y/n] &lt;–是否禁止root远程登录，建议yRemove test database and access to it? [Y/n] &lt;– 是否删除test数据库，建议yReload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，建议y 新增远程管理用户 登录数据库：mysql -u root -p 输入密码，回车 使用mysql数据库：use mysql 新增用户，name用户名，pwd密码，%代表任何客户端机器上能以该用户登录到MySQL服务器：CREATE USER &#39;name&#39;@&#39;%&#39; IDENTIFIED BY &#39;pwd&#39;; 授权123456//grant 普通 DBA 管理某个 MySQL 数据库的权限grant all privileges on 你的某个db名 to 用户名;//grant 高级 DBA 管理 MySQL 中所有数据库的权限 建议grant all on *.* to 用户名;//刷新权限flush privileges;­ 输入exit或Ctrl+c退出，重启MySQL：service mariadb restart 设置开机启动：systemctl enable mariadb Maven安装(可不用安装) 官网 找到较新版本下载地址：wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz 解压：tar -zvxf apache-maven-3.5.2-bin.tar.gz 打开/etc/profile，配置环境变量，在末尾加入：12345MAVEN_HOME=/usr/local/maapache-maven-3.5.2PATH=$PATH:$MAVEN_HOME/binexport PATH MAVEN_HOME 使更改生效：soucre /etc/profile mvn -v Git安装 yum -y install git git --version Nodejs安装1 推荐 安装更新一些依赖：yum -y install gcc gcc-c++ openssl-devel make 官网 找到较新版本下载地址：wget https://nodejs.org/dist/v8.9.1/node-v8.9.1.tar.gz 解压：tar -zvxf node-v8.9.1.tar.gz 进入解压后文件夹后执行：./configure 编译安装：make &amp;&amp; make install node -v Nodejs安装2 yum -y install nodejs node -v 文件上传安装 yum -y install lrzsz 更换阿里yum源 默认源：ll /etc/yum.repos.d 备份 /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载新的CentOS-Base.repo 到/etc/yum.repos.d/123456CentOS 5wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repoCentOS 6wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repoCentOS 7wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 生成缓存：yum makecache 端口开放与关闭 以防火墙开放3306端口为例 firewall-cmd --add-port=3306/tcp --permanent 关闭3306端口为例 firewall-cmd --remove-port=3306/udp --permanent 重启防火墙 firewall-cmd --reload 防火墙 开启firewall：systemctl start firewalld.service 停止firewall：systemctl stop firewalld.service 禁止firewall开机启动：systemctl disable firewalld.service 查看默认防火墙状态：firewall-cmd --state 创建swap空间 通常创建物理内存2~2.5倍大小的文件作为交换区，创建2G的swap交换区空白文件名为swapfile dd if=/dev/zero of=/root/swapfile bs=1M count=2048 格式化文件为swap文件系统 mkswap swapfile 启用：swapon swapfile 设置开机自动启用swap文件交换区，修改/etc/fstab，增加一行 /root/swapfile swap swap defaults 0 0 关闭swap：swapoff swapfile","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Redis的安装及集群配置","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/Redis安装及集群配置/","text":"Redis的安装及集群配置官方下载地址 Redis的安装Redis是c语言开发的，安装需要c语言的编译环境,如果没有gcc需要在线安装: yum install gcc-c++ 安装步骤： 第一步：Redis的源码包上传到Linux 第二步：解压缩: tar -xvf redis-3.0.0.tar.gz -C /usr/local 第三步：编译 进入redis源码目录: make 第四步：安装: make install PREFIX=/usr/local/redis PREFIX参数指定redis的安装目录,一般软件安装到/usr目录下 Redis的启动： 前端启动：在redis的安装目录下直接启动redis-server[root@localhost bin]# ./redis-server 后台启动： 123把 /root/redis-3.0.0/redis.conf 复制到 /usr/local/redis/bin 目录下 cp redis.conf /usr/local/redis/bin/修改 redis.conf 文件 设置 daemonize yes启动时添加配置文件 ./redis-server redis.conf 关闭：[root@localhost bin]# ./redis-cli shutdown Redis-cli连接 默认连接localhost运行在6379端口的redis服务[root@localhost bin]# ./redis-cli 自定义连接端口[root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379 -h：连接的服务器的地址 -p：服务的端口号 远程连接：注释掉 redis.conf 中 bind 127.0.0.1 设置 protected-mode no 重启redis 设置密码：配置文件中添加 requirepass 你的密码 重启redisRedis-cluster集群搭建由于容错机制，Redis集群中至少应该有三个节点。要保证集群的高可用，需要每个节点有一个备份机，因此，Redis集群至少需要6台服务器。 由于个人只有一台服务器，只有搭建伪分布式：一台服务器运行6个redis实例，需要修改Redis的端口号7001-7006 集群搭建环境 使用Ruby脚本搭建集群,需要Ruby的运行环境,安装Ruby yum install ruby yum install rubygems 安装Ruby脚本运行使用的包 上传所需Ruby库文件redis-3.0.0.gem 安装执行： [root@localhost ~]# gem install redis-3.0.0.gem 进入 redis-3.0.0/src 会找到redis-trib.rb文件，为了方便可将其拷贝至下一步创建的 redis-cluster 文件夹中 搭建Redis集群 拷贝创建6个Redis实例，方便管理将刚复制的6个Redis拷贝至创建 redis-cluster 文件夹，每个实例运行在不同的端口。需要修改redis.conf配置文件：把 cluster-enabled yes 前的注释去掉，并且分别修改端口 port 7001~7006 创建开启集群的脚本： 123456789101112131415161718192021[root@localhost redis-cluster]# vim start-all.shcd redis01./redis-server redis.confcd ..cd redis02./redis-server redis.confcd ..cd redis03./redis-server redis.confcd ..cd redis04./redis-server redis.confcd ..cd redis05./redis-server redis.confcd ..cd redis06./redis-server redis.confcd ..//修改脚本文件可执行权限[root@localhost redis-cluster]# chmod u+x start-all.sh 执行脚本启动每个redis实例 使用ruby脚本搭建集群 ./redis-trib.rb create --replicas 1 123.207.121.135:7001 123.207.121.135:7002 123.207.121.135:7003 123.207.121.135:7004 123.207.121.135:7005 123.207.121.135:7006 连接集群 [root@localhost redis-cluster]# redis01/redis-cli -p 7002 -c 关闭集群 杀进程：ps -aux|grep redis kill -9 进程ID 踩坑解决问题 重启服务器后重新启动ruby脚本报错1[ERR] Node 123.207.121.135:7001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0. 由于非正常关闭集群，需删除每个节点中的数据文件aof、rdb、nodes.conf，实在不行就只有重装一遍… 强制停止redis快照导致，redis运行用户没有权限写rdb文件或者磁盘空间满了1MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. 解决办法：修改配置文件 stop-writes-on-bgsave-error no","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Redis-client安装配置","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/Redis-clinet/","text":"Redis-client安装配置下载 https://redis.io/download 1234wget http://download.redis.io/releases/redis-5.0.7.tar.gztar xzf redis-5.0.7.tar.gzcd redis-5.0.7make src/redis-cli","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"SpringMVC总结","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/SpringMvc总结/","text":"SpringMVC总结@Controller 通过@controller标注即可将class定义为一个controller类 @RestController 组合注解@Controller和@ResponseBody @RequestMapping value 表示需要匹配的url的格式 method 表示所需处理请求的http 协议(如get,post,put,delete等) 1@RequestMapping(value = &quot;/member/add&quot;,method = RequestMethod.POST) params 格式为”paramname=paramvalue” 或 “paramname!=paramvalue”。 表示参数必须等于某值，或者不等于才进入此映射方法。不填写的时候表明不限制。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法： 12345@RequestMapping (value= &quot;testParams&quot; , params=&#123; &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; &#125;) public String testParams() &#123; System. out .println( &quot;test Params...........&quot; ); return &quot;testParams&quot; ; &#125; headers 用来限定对应的reqeust请求的headers中必须包括的内容，例如headers={“Connection=keep-alive”}, 表示请求头中的connection的值必须为keep-alive。当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法： 1234@RequestMapping (value= &quot;testHeaders&quot; , headers=&#123; &quot;host=localhost&quot; , &quot;Accept&quot; &#125;) public String testHeaders() &#123; return &quot;headers&quot; ; &#125; produces指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回1234@RequestMapping (value= &quot;testProduces&quot; , produces=&quot;text/plain;charset=utf-8&quot;)@RequestMapping (value= &quot;testProduces&quot; , produces=&quot;application/json;charset=utf-8&quot;)@RequestMapping (value= &quot;testProduces&quot; , produces=&quot;application/xml;charset=utf-8&quot;) @DeleteMapping 映射HTTP的delete请求，等同于@RequestMapping(value = &quot;/member/add&quot;,method = RequestMethod.DELETE)，以下同理 @GetMapping @PostMapping @PutMapping @RequestParam value 对应表单name空间的值 required 是否允许为空 defaultValue 默认值 1234@RequestMapping ( &quot;requestParam&quot; ) public String testRequestParam( @RequestParam(required=false) String name, @RequestParam ( &quot;age&quot; ) int age) &#123; return &quot;requestParam&quot; ;&#125; @PathVariable 获得地址栏中传的参数 例如： 1234@RequestMapping(value=&quot;/&#123;groupId&#125;.do&quot;)public void detail(@PathVariable long groupId)&#123; groupRepository.selectOne(groupId);&#125; @RequestBody 用来将指定的客户端发送过来的请求参数的数据格式转换成Java实体 1234@RequestMapping(value = &quot;/xxxxx.do&quot;)public void create(@RequestBody() String host)&#123; System.out.println(&quot;-----------&quot; + host);&#125; @ResponseStatus返回一个指定的http response状态码。 12345@ResponseStatus(reason=&quot;no reason&quot;,value=HttpStatus.BAD_REQUEST)@RequestMapping(&quot;/responsestatus&quot;)public void responseStatusTest()&#123; &#125; @CookieValue可以把Requestheader中关于cookie的值绑定到方法的参数上。 例如有如下Cookie值： JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84，即把JSESSIONID的值绑定到参数cookie上。 123@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; &#125; @ExceptionHandler 123456789@RequestMapping(&quot;/exception&quot;) public void ExceptionTest() throws Exception&#123; throw new Exception(&quot;i don&#x27;t know&quot;); &#125; @ExceptionHandler public String handleException(Exception e,HttpServletRequest request)&#123; System.out.println(e.getMessage()); return &quot;helloworld&quot;; &#125;","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Swagger2安装使用","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/Swagger2安装使用/","text":"Swagger2安装使用 Maven依赖安装 1234567891011&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; Swagger的Java配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.exrick.swagger;import io.swagger.annotations.ApiOperation;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Created by Exrick on 2017/8/15. */@Configuration //让Spring来加载该类配置@EnableWebMvc //非SpringBoot需启用@EnableSwagger2 //启用Swagger2public class Swagger2Config &#123; static final Logger log= LoggerFactory.getLogger(Swagger2Config.class); @Bean public Docket createRestApi() &#123; log.info(&quot;加载Swagger2&quot;); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).select() //扫描指定包中的swagger注解 //.apis(RequestHandlerSelectors.basePackage(&quot;cn.exrick.controller&quot;)) //扫描所有有注解的api，用这种方式更灵活 .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;XMall Api Documentation&quot;) .description(&quot;XMall商城API接口文档&quot;) .termsOfServiceUrl(&quot;http://blog.exrick.cn&quot;) .contact(new Contact(&quot;Exrick&quot;, &quot;http://blog.exrick.cn&quot;, &quot;1012139570@qq.com&quot;)) .version(&quot;1.0.0&quot;) .build(); &#125;&#125; Controller中API文档说明注解添加 1234567891011121314151617181920212223242526272829303132333435363738package cn.exrick.controller;import cn.exrick.common.utils.XMallResult;import cn.exrick.pojo.DataTablesResult;import cn.exrick.pojo.TbMember;import cn.exrick.service.MemberService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;/** * Created by Exrick on 2017/8/11. */@RestController@Api(description= &quot;会员列表信息&quot;)public class MemberController &#123; @Autowired private MemberService memberService; /** * 分页搜索查询会员 * @param draw * @param start * @param length * @param search * @return */ @RequestMapping(value = &quot;/member/list&quot;,method = RequestMethod.GET) @ResponseBody @ApiOperation(value = &quot;分页搜索获取会员列表&quot;) public DataTablesResult getMemberList(int draw, int start, int length, @RequestParam(&quot;search[value]&quot;) String search)&#123; DataTablesResult result=memberService.getMemberList(draw,start,length,search); return result; &#125;&#125; 按常规, 现在访问 http://localhost:8090/swagger-ui.html 应该能看到效果了, 但出现404 处理方法：在 GitHub 上下载 SwaggerUI 项目，建议下载2.0分支版本，界面清爽点，将dist下所有内容拷贝到本地项目resource/static/swagger下面, 并修改 index.html12//url = &quot;http://petstore.swagger.io/v2/swagger.json&quot;; url = &quot;http://localhost:8888/v2/api-docs&quot;; 然后访问 http://localhost:8888/static/swagger/index.html 使用总结 12345678@ApiOperation(value = &quot;获取图片资源&quot;,response = byte[].class,produces = &quot;application/json;charset=UTF-8&quot;) @ApiResponses(&#123; @ApiResponse(code=404,message=&quot;没有找到该图片&quot;) &#125;) @GetMapping(value = &quot;/files/images/&#123;id&#125;&quot;,produces = &quot;image/jpeg;image/png;image/gif&quot;) public ResponseEntity&lt;String&gt; getImg(@PathVariable(&quot;id&quot;) long id) &#123; return new ResponseEntity&lt;String&gt;(fileService.getFileBydId(id), HttpStatus.OK); &#125;","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"ZooKeeper","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/Zookeeper/","text":"ZooKeeperZookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 可以作为集群的管理工具使用。 可以集中管理配置文件。 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 官方下载地址 Zookeeper的安装 安装环境： Linux：CentOS JDK:1.7以上版本 Zookeeper是Java开发的可以运行在windows、linux环境。需要先安装JDK。安装步骤： 第一步：安装jdk 第二步：把zookeeper的压缩包上传到linux系统。 第三步：解压缩压缩包 tar -zxvf zookeeper-3.4.6.tar.gz 第四步：进入zookeeper-3.4.6目录，创建data文件夹。 第五步：把zoo_sample.cfg改名为zoo.cfg [root@localhost conf]# mv zoo_sample.cfg zoo.cfg 第六步：修改data属性：dataDir=/root/zookeeper-3.4.6/data 第七步：启动zookeeper [root@localhost bin]# ./zkServer.sh start 关闭：[root@localhost bin]# ./zkServer.sh stop 查看状态：[root@localhost bin]# ./zkServer.sh status 注意：需要关闭服务器防火墙 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"Ngix安装","date":"2019-02-24T01:56:24.000Z","path":"wk/平台工具/工具组件/组件安装配置/nginx/","text":"Ngix安装(Linux)官方下载地址 安装与启动 gcc环境 yum install gcc-c++ 第三方的开发包 PCRE yum install -y pcre pcre-devel zlib yum install -y zlib zlib-devel openssl yum install -y openssl openssl-devel 安装 解压 [root@localhost ~]# tar zxf nginx-1.8.0.tar.gz 进入解压后文件夹复制执行以下命令./configure --prefix=/usr/local/nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx/nginx.pid --lock-path=/var/lock/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=/var/tmp/nginx/client/ --http-proxy-temp-path=/var/tmp/nginx/proxy/ --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi --http-scgi-temp-path=/var/tmp/nginx/scgi --with-pcre [root@localhost nginx-1.8.0]# make [root@localhost nginx-1.8.0]# make install [root@localhost sbin]# mkdir /var/tmp/nginx/client -p 进入目录 cd /usr/local/nginx/ 启动 [root@localhost sbin]# ./nginx 配置文件目录nginx/conf/nginx.conf 重新加载配置文件 避免重启sbin/nginx -s reload 配置 配置虚拟主机与反向代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream resume&#123; server 123.207.121.135:8080; &#125; server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://resume; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; server_name www.img.exrick.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html81; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; server_name www.xmall.exrick.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 负载均衡（直接添加server即可） 123456789...http &#123; ... upstream resume&#123; server 123.207.121.135:8080; server 123.207.121.135:8081; &#125; ...&#125; 权重调节（weight） 123456789...http &#123; ... upstream resume&#123; server 123.207.121.135:8080; server 123.207.121.135:8081 weight=2; &#125; ...&#125; 压缩文件 12345gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_comp_level 9;gzip_types text/plain application/x-javascript application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png eventsource script png; 解决代理IP地址 123456789101112131415161718192021server &#123; listen 80; server_name xmall.exrick.cn; location / &#123; proxy_pass http://xmall; index index.html index.htm; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; error_page 404 /50x.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 踩坑解决问题 [emerg]: getpwnam(“nginx”) failed 解决方法1：在nginx.conf中 把user nobody的注释去掉既可 解决方法2：错误的原因是没有创建nginx这个用户，应该在服务器系统中添加nginx用户组和用户nginx，如下命令：/usr/sbin/groupadd -f nginx/usr/sbin/useradd -g nginx nginx [emerg] mkdir() “/var/temp/nginx/client” failed (2: No such file or directory)root下手动创建即可：mkdir -p /var/temp/nginx/client 重启服务器后启动提示/var/run/nginx找不到1nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory) 进入/var/run新建nginx文件夹：mkdir nginx","tags":[{"name":"组件安装配置","slug":"组件安装配置","permalink":"https://quano.gitee.io/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"组件安装配置","slug":"平台工具/工具组件/组件安装配置","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"}]},{"title":"TODOLIST","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/TODOLIST/README/","text":"一周计划 一道算法题 一篇英语文章 一个技术小技巧 一个观点分享 把握好机会，别人给你的机会。要看懂一些事情。不要装作什么都不知道。 不要说一些没有用的话，还不如不说（补充自2024.02.19：公开讲话，作为一种重要的传播和交流方式，其核心目的往往是为了传达特定的立场和维护某种利益） 云计算 图像算法 架构设计（复杂系统的设计） 技术决策、技术方案；设计质量。 华为机试.","tags":[{"name":"todo","slug":"todo","permalink":"https://quano.gitee.io/tags/todo/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"TODOLIST","slug":"项目管理/生活学习/TODOLIST","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/TODOLIST/"}]},{"title":"201902","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/TODOLIST/201902/","text":"20190224","tags":[{"name":"todo","slug":"todo","permalink":"https://quano.gitee.io/tags/todo/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"TODOLIST","slug":"项目管理/生活学习/TODOLIST","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/TODOLIST/"}]},{"title":"金融","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/了解点金融/未来十年,买房还是买股/","text":"回看历史，以个人或家庭投资和股市为例，两者可谓是冰火两重天 的不同经济命运， 放假在过去的二十年翻了20倍.而股市的综合指数十年原地踏步。国内波澜壮阔的房地产牛市坚定了一批又一批的投资者买房才是硬道理的信念。 不过看看欧美发达国家，你不禁会发现富人都是把投资股票作为首选，并且很多的普通家庭选择了租房方式，为什么会有这样的差异呢？ 一轮经济周期里几乎每一类资产都有上涨机会，包括衰退初期的债券，衰退后期的股票，复苏初期的房地产和大宗商品。 一.我国房地产牛市的根本原因经济高速发展带动城市化率的快速提升。 人口红利的持续释放。","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"了解点金融","slug":"项目管理/生活学习/了解点金融","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E4%BA%86%E8%A7%A3%E7%82%B9%E9%87%91%E8%9E%8D/"}]},{"title":"体制-公务员","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/关于体制/001.公务员/","text":"2014年清华大学硕士毕业。乡镇副镇长，县委办副主任。 2016年辞职。 “很多人说公务员社会地位高，其实社会地位这个概念本身就是一面镜子。反映的是观察者的价值观和期望，而非被观察者的真实状态。真正的地位，我认为是来源于个人的品格、能力、和对社会的贡献，而非由职业定义，公务员本身并无特殊，只是舞台罢了” 公务员的工作是什么状态？优缺点？ 资料： 抖音：人间清醒石老师.","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"关于体制","slug":"项目管理/生活学习/关于体制","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E5%85%B3%E4%BA%8E%E4%BD%93%E5%88%B6/"}]},{"title":"系统思维.","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/思维/001.系统思维/","text":"如何学习系统思维 什么是系统思维 什么是系统系：指联系。 统：指统一。 所谓系统，是指由相互之间具有联系的各种元素组成的统一整体。 例如社会、国家、公司、家庭以及我们的身体，都是系统。 系统的三个特征 系统是由各种元素组成的。 元素可以是有形的实体，例如公司系统中的办公楼、员工、办公用品等，也可以是无形的状态，例如规章、制度、命令、文化等。 系统中的元素存在各种联系。 例如员工根据领导安排， 服从公司制度，通过办公用品，出售自己时间，产出工作成果，获得工作报酬等。 系统有自己的目的或功能。 什么是系统思维 如何学习系统思维？","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"思维","slug":"项目管理/生活学习/思维","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%80%9D%E7%BB%B4/"}]},{"title":"时间和注意力.","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/思维/002.时间和注意力/","text":"人最宝贵的是时间和注意力. 高效能人士的七个习惯.","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"思维","slug":"项目管理/生活学习/思维","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%80%9D%E7%BB%B4/"}]},{"title":"After美西","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/生活学习/旅行/2019美西之行/","text":"2019年也算是幸运的一年. 虽然工作懒散了. 也没有想着升值加薪. 首先感觉很nice的是十一去了泰国，虽然玩的不是很理想，但是就像那句话: 旅行是即不舒适又不安全的，但它能带给我们流光溢彩、繁花似锦的世界. 看到了一个不一样的国家, 见到了大学学习很好的同学. 真的对生活有了一些新的认识. 12月底有有机会去了美国， 从面签到期待已久的行程。 美国的行程还是满心欢喜的，虽然去之前想着都是领导可能会不好玩。但当第一天晚上在旧金山的 希尔顿联合广场酒店（Cityscape Lounge ）看到旧金山的夜景的时候, 感觉美国行还是很快乐. 洛杉矶的海滩, 斯台普斯球馆. 当时还不知道斯台普斯球馆 是什么，只是看到大家都去拍照，后来才知道是NBA常用的体育馆.ß 1.便宜坊的烤鸭，天外天，1949全鸭季，全聚德2.火锅，海底捞3.宇宙中心的串串（成都的串串）。付小姐在成都【这个】4.烧烤-木屋烧烤。猪蹄很好吃，很辣。羊蝎子5.313羊庄，铁锅烀羊肉。清汤的很鲜，不同的口味汤真的很好喝。【这个】6.海鲜7.炸酱面8.稻香村的点心9.眉州东坡 北戴河，厦门，深圳，台湾 最大的感受就是 那边的中国人的餐馆。 从他们身上可以看到一种异国他乡的艰辛和服务态度，还有对现在生活的踏实和一丝的满足(就是那种经历过一些艰辛之后的收获，不管是物质还是精神上的收获)。 也看到一些对祖国的一些感慨和自豪吧。问他们说会考虑回去生活吗。 他们说是回不去了，那边已经没有家了。 一定程度上美国的生活还是很不错，物质上的比如人少，生活环境很好。发达国家的那种生活状态。国内一些地方还是不能比的（比如国内一线城市的拥挤，二三线城市的也是拥挤和四五线的落后相比）","tags":[{"name":"生活学习","slug":"生活学习","permalink":"https://quano.gitee.io/tags/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"旅行","slug":"项目管理/生活学习/旅行","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%97%85%E8%A1%8C/"}]},{"title":"ubunut 挂载samba","date":"2019-02-24T01:56:24.000Z","path":"wk/项目管理/软件工程/Linux/ubuntu挂载samba/","text":"ubunut 挂载smbubuntu18.04挂载smblinux挂载samba文件系统的方法12sudo apt install cifs-utilssudo mount -t cifs -o username=xxx,password=xxx //$&#123;ip&#125;/deploy/download /mnt/download sslocal -s 108.160.129.222 -p 25002 -k ‘2018vultr@lgqsb’ -l 1080 -t 600 -m aes-256-cfb -d $1 —pid-file /tmp/vpn-agent.pid —log-file /tmp/vpn-agent.log export GIO_EXTRA_MODULES=/usr/lib/x86_64-linux-gnu/gio/modules/ if [ $1 == ‘stop’ ];then gsettings set org.gnome.system.proxy mode ‘none’ echo ‘stop 1232.’else gsettings set org.gnome.system.proxy.http host ‘127.0.0.1’ gsettings set org.gnome.system.proxy.http port 1080 gsettings set org.gnome.system.proxy mode ‘manual’ echo ‘start 22222.’fi","tags":[{"name":"linux","slug":"linux","permalink":"https://quano.gitee.io/tags/linux/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Linux","slug":"项目管理/软件工程/Linux","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Linux/"}]},{"title":"伪集群模式安装","date":"2019-02-16T04:56:24.000Z","path":"wk/数据/数据处理/组件安装配置/Hadoop组件安装/2.伪集群模式安装/","text":"搭建hadoop-2.6.0-cdh5.4.7伪分布式 CDH版下载地址 先来看看什么是CDH，为什么选择CHD版的Hadoop。 CDH属于Hadoop的一个发行版。 Hadoop有以下发行版： Apache Hadoop Cloudera’s Distribution Including Apache Hadoop（CDH） Hortonworks Data Platform (HDP) MapR EMR CDH版有以下优点： 版本划分清晰 版本更新速度快 支持Kerberos安全认证 文档清晰 支持多种安装方式（Cloudera Manager方式） 安装hadoop-2.6.0-cdh5.4.0首先到指定网站下载安装包CDH版下载地址 解压下载的安装包 配置伪集群 1、进入 hadoop-2.6.0-cdh5.4.0/etc/hadoop 2、编辑 hadoop-env.sh1vi hadoop-env.sh 3、修改JAVA_HOME的配置为1export JAVA_HOME=/opt/tools/jdk1.8.0_131 4、编辑core-site.xml,添加如下配置： 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node2:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; node2说明，如果没有配置hosts，请将node2换成IP地址:wp保存并退出。 5、编辑hdfs-site.xml,添加如下配置 1234567891011121314151617181920212223242526&lt;configuration&gt; &lt;property&gt; &lt;!--开启web hdfs--&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/opt/cdh/hadoop/name&lt;/value&gt; &lt;description&gt; namenode 存放name table(fsimage)本地目录（需要修改）&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.edits.dir&lt;/name&gt; &lt;value&gt;$&#123;dfs.namenode.name.dir&#125;&lt;/value&gt; &lt;description&gt;namenode存放 transactionfile(edits)本地目录（请自行修改）&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/opt/cdh/hadoop/data&lt;/value&gt; &lt;description&gt;datanode存放block本地目录（请自行修改）&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 以上配置完成，还需要创建文件夹 12mkdir -p cdh/hadoop/namemkdir cdh/hadoop/data 6、配置mapred-site.xml 12345678cp mapred-site.xml.template mapred-site.xml之后加入以下配置&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 7、编辑yarn-site.xml 1234567&lt;configuration&gt; &lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 到此，所有配置都已完成。 格式化HDFS1bin/hdfs namenode -format 看到如下信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263************************************************************/15/09/22 14:59:46 INFO namenode.NameNode: registered UNIX signal handlers for [TERM, HUP, INT]15/09/22 14:59:46 INFO namenode.NameNode: createNameNode [-format]15/09/22 14:59:48 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable15/09/22 14:59:49 WARN common.Util: Path /opt/cdh/hadoop/name should be specified as a URI in configuration files. Please update hdfs configuration.15/09/22 14:59:49 WARN common.Util: Path /opt/cdh/hadoop/name should be specified as a URI in configuration files. Please update hdfs configuration.Formatting using clusterid: CID-41ea6672-a32e-4b16-b704-962381ed409a15/09/22 14:59:49 INFO namenode.FSNamesystem: No KeyProvider found.15/09/22 14:59:49 INFO namenode.FSNamesystem: fsLock is fair:true15/09/22 14:59:49 INFO blockmanagement.DatanodeManager: dfs.block.invalidate.limit=100015/09/22 14:59:49 INFO blockmanagement.DatanodeManager: dfs.namenode.datanode.registration.ip-hostname-check=true15/09/22 14:59:49 INFO blockmanagement.BlockManager: dfs.namenode.startup.delay.block.deletion.sec is set to 000:00:00:00.00015/09/22 14:59:49 INFO blockmanagement.BlockManager: The block deletion will start around 2015 九月 22 14:59:4915/09/22 14:59:49 INFO util.GSet: Computing capacity for map BlocksMap15/09/22 14:59:49 INFO util.GSet: VM type = 64-bit15/09/22 14:59:49 INFO util.GSet: 2.0% max memory 966.7 MB = 19.3 MB15/09/22 14:59:49 INFO util.GSet: capacity = 2^21 = 2097152 entries15/09/22 14:59:50 INFO blockmanagement.BlockManager: dfs.block.access.token.enable=false15/09/22 14:59:50 INFO blockmanagement.BlockManager: defaultReplication = 115/09/22 14:59:50 INFO blockmanagement.BlockManager: maxReplication = 51215/09/22 14:59:50 INFO blockmanagement.BlockManager: minReplication = 115/09/22 14:59:50 INFO blockmanagement.BlockManager: maxReplicationStreams = 215/09/22 14:59:50 INFO blockmanagement.BlockManager: shouldCheckForEnoughRacks = false15/09/22 14:59:50 INFO blockmanagement.BlockManager: replicationRecheckInterval = 300015/09/22 14:59:50 INFO blockmanagement.BlockManager: encryptDataTransfer = false15/09/22 14:59:50 INFO blockmanagement.BlockManager: maxNumBlocksToLog = 100015/09/22 14:59:50 INFO namenode.FSNamesystem: fsOwner = root (auth:SIMPLE)15/09/22 14:59:50 INFO namenode.FSNamesystem: supergroup = supergroup15/09/22 14:59:50 INFO namenode.FSNamesystem: isPermissionEnabled = true15/09/22 14:59:50 INFO namenode.FSNamesystem: HA Enabled: false15/09/22 14:59:50 INFO namenode.FSNamesystem: Append Enabled: true15/09/22 14:59:50 INFO util.GSet: Computing capacity for map INodeMap15/09/22 14:59:50 INFO util.GSet: VM type = 64-bit15/09/22 14:59:50 INFO util.GSet: 1.0% max memory 966.7 MB = 9.7 MB15/09/22 14:59:50 INFO util.GSet: capacity = 2^20 = 1048576 entries15/09/22 14:59:50 INFO namenode.NameNode: Caching file names occuring more than 10 times15/09/22 14:59:50 INFO util.GSet: Computing capacity for map cachedBlocks15/09/22 14:59:50 INFO util.GSet: VM type = 64-bit15/09/22 14:59:50 INFO util.GSet: 0.25% max memory 966.7 MB = 2.4 MB15/09/22 14:59:50 INFO util.GSet: capacity = 2^18 = 262144 entries15/09/22 14:59:50 INFO namenode.FSNamesystem: dfs.namenode.safemode.threshold-pct = 0.999000012874603315/09/22 14:59:50 INFO namenode.FSNamesystem: dfs.namenode.safemode.min.datanodes = 015/09/22 14:59:50 INFO namenode.FSNamesystem: dfs.namenode.safemode.extension = 3000015/09/22 14:59:50 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.window.num.buckets = 1015/09/22 14:59:50 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.num.users = 1015/09/22 14:59:50 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.windows.minutes = 1,5,2515/09/22 14:59:50 INFO namenode.FSNamesystem: Retry cache on namenode is enabled15/09/22 14:59:50 INFO namenode.FSNamesystem: Retry cache will use 0.03 of total heap and retry cache entry expiry time is 600000 millis15/09/22 14:59:50 INFO util.GSet: Computing capacity for map NameNodeRetryCache15/09/22 14:59:50 INFO util.GSet: VM type = 64-bit15/09/22 14:59:50 INFO util.GSet: 0.029999999329447746% max memory 966.7 MB = 297.0 KB15/09/22 14:59:50 INFO util.GSet: capacity = 2^15 = 32768 entries15/09/22 14:59:50 INFO namenode.NNConf: ACLs enabled? false15/09/22 14:59:50 INFO namenode.NNConf: XAttrs enabled? true15/09/22 14:59:50 INFO namenode.NNConf: Maximum size of an xattr: 1638415/09/22 14:59:51 INFO namenode.FSImage: Allocated new BlockPoolId: BP-314159059-192.168.1.3-144290519105615/09/22 14:59:51 INFO common.Storage: Storage directory /opt/cdh/hadoop/name has been successfully formatted.15/09/22 14:59:51 INFO namenode.NNStorageRetentionManager: Going to retain 1 images with txid &gt;= 015/09/22 14:59:51 INFO util.ExitUtil: Exiting with status 015/09/22 14:59:51 INFO namenode.NameNode: SHUTDOWN_MSG: /************************************************************SHUTDOWN_MSG: Shutting down NameNode at node2/192.168.1.3************************************************************/ 如果不报错，则格式化成功。 然后分别启动HDFS和Yarn： 12sbin/start-dfs.shsbin/start-yarn.sh 启动过程没有错误则启动成功。 验证 使用jps可以查看相关进程 显示如下： 1234567nova@ubuntu208:~$ jps7667 Jps28532 DataNode28742 SecondaryNameNode29319 NodeManager28376 NameNode29018 ResourceManager 管理地址 yarn: http://192.168.1.34:8088/cluster hdfs状态: http://192.168.1.34:50070/dfshealth.html#tab-overview","tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://quano.gitee.io/tags/hadoop/"}],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"Hadoop组件安装","slug":"数据/数据处理/组件安装配置/Hadoop组件安装","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/Hadoop%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"HBase伪集群模式安装","date":"2019-02-16T04:56:24.000Z","path":"wk/数据/数据处理/组件安装配置/Hadoop组件安装/3.HBase伪集群模式安装/","text":"同Hadoop安装，到CDH版下载地址下载hbase。选择 hbase-1.0.0-cdh5.4.0.tar.gz hbase伪分布式模式是基于hdfs环境的 因此，在安装hadoop的前提下，我们配置Hbase的伪分布式模式如下： 1.下载并解压 2.配置环境变量（可选） 123456vi ~/.bashrc#添加export PATH=$PATH:/opt/app/skyeye/hbase-1.0.0-cdh5.4.0/bin. ~/.bashrc#验证hbase version 伪集群模式配置 1.配置 conf/hbase-env.sh将JAVA_HOME变量设置为本机jdk路径。如下： 12export JAVA_HOME=/opt/tools/jdk1.8.0_131 #配置本机的java安装根目录export HBASE_MANAGES_ZK=true #配置使用hbase自带的zookeeper，不使用自己搭建的zookeeper 如果使用 export HBASE_MANAGES_ZK=true， 即配置不使用hbase自带的zookeeper，使用自己搭建的zookeeper hbase可以使用自定义zookeeper管理，也可以使用自带的zookeeper。 2.配置conf/hbase-site.xml修改hbase.rootdir,将其指向hdfs，并指定Hbase在HDFS上的存储路径。将hbase.cluster.distributed设置为true。添加zk的节点地址。如下： 1234567891011121314151617181920&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;!--以下信息只有在使用自己搭建的zk时添加--&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;cdhnode1,cdhnode2,cdhnode3&lt;/value&gt; &lt;/property&gt; &lt;!--默认为/tmp/目录下--&gt; &lt;property&gt; &lt;name&gt;hbase.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/app/skyeye/data/hbasetmp/&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 3.启动HBase 完成上述操作之后，启动HBase，需要先启动Hadoop。 启动及检查： 123456789zbm@node3:~$ start-all.sh zbm@node3:~$ jps9250 ResourceManager9683 Jps9365 NodeManager9110 SecondaryNameNode8935 DataNode8795 NameNode 上述则Hadoop启动成功。 当前版本。使用start-all.sh启动hadoop时会提示以下信息，所以建议分别启动hdfs和yarn。 1This script is Deprecated. Instead use start-dfs.sh and start-yarn.sh 之后启动HBase，启动及检查 123456789101112start-hbase.sh # 启动Hbasezbm@node3:~$ jps # 检查3728 Jps3123 HRegionServer2407 NodeManager1961 DataNode2298 ResourceManager3004 HMaster1852 NameNode2158 SecondaryNameNode2943 HQuorumPeer 以上几个进程说明Hbase启动成功。 4.Hbase操作 可以进入shell模式，通过命令行操作查看hbase数据库信息。 12345hbase shell #进入shell模式list # 查看当前数据库所有表信息describe &#x27;member&#x27; # 查看表结构# 创建一个member表，其拥有member_id,address,info三个列族create &#x27;member&#x27;,&#x27;member_id&#x27;,&#x27;address&#x27;,&#x27;info&#x27; 5.查看HDFS的HBase数据库文件 12345678910zbm@node3:～$ hadoop fs -ls /hbase17/10/28 20:45:14 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableFound 6 itemsdrwxr-xr-x - nova supergroup 0 2017-10-28 00:03 /hbase/.tmpdrwxr-xr-x - nova supergroup 0 2017-10-28 00:03 /hbase/WALsdrwxr-xr-x - nova supergroup 0 2017-10-28 00:03 /hbase/data-rw-r--r-- 3 nova supergroup 42 2017-10-28 00:03 /hbase/hbase.id-rw-r--r-- 3 nova supergroup 7 2017-10-28 00:03 /hbase/hbase.versiondrwxr-xr-x - nova supergroup 0 2017-10-28 00:14 /hbase/oldWALs 6.停止HBase 1stop-hbase.sh #停止Hbase 问题：停止hbase时，HRegionServer进程不能停止。会导致下次启动hbase时出错。 原因: HBase的用户界面 yarn: http://192.168.1.20:8088/cluster hdfs状态: http://192.168.1.20:50070/dfshealth.html#tab-overview Master: http://192.168.1.20:60010/master.jsp","tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://quano.gitee.io/tags/hadoop/"},{"name":"hbase","slug":"hbase","permalink":"https://quano.gitee.io/tags/hbase/"}],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"Hadoop组件安装","slug":"数据/数据处理/组件安装配置/Hadoop组件安装","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/Hadoop%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"常用操作命令与问题记录","date":"2019-02-16T04:56:24.000Z","path":"wk/数据/数据处理/组件安装配置/Hadoop组件安装/4.常用操作与问题记录/","text":"启动hadoop12start-dfs.shstart-yarn.sh 停止hadoop12stop-dfs.shstop-yarn.sh 启动或停止所有，即：HDFS和Yarn 问题记录一、dfs的端口9000不通原因：忘记格式化hdfs。 启动顺序 1.启动hdfs 2.启动yarn 3.启动hbase 二、查看hbase在hdfs中目录时使用hadoop fs -ls /hbase查看hbase目录，出现以下信息： 117/10/28 22:25:28 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable hbase 可以配置使用本地文件系统（一般单击模式），也可以使用hdfs（伪集群或集群模式） hbase 可以配置使用自己安装的zk，也可以使用自带的zk。 hadoop的name、data文件夹下存放什么？","tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://quano.gitee.io/tags/hadoop/"},{"name":"hbase","slug":"hbase","permalink":"https://quano.gitee.io/tags/hbase/"}],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"Hadoop组件安装","slug":"数据/数据处理/组件安装配置/Hadoop组件安装","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/Hadoop%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"Reactive","date":"2019-01-08T03:55:57.000Z","path":"wk/平台工具/编程相关/响应式编程/","text":"响应式编程基于事件驱动(事件模式，或者订阅者模式)，类似于Netty异步事件编程模型． 对不同的事件做不同的处理．所有信息都通过一个编程模型处理． 好处传统模型相比 JavaWeb开发，基于Servlet. Servlet3.0之前 线程阻塞模型，只有当业务处理完成并返回后时结束Servlet线程． 3.0规范新特性，支持异步处理－Servlet线程将耗时操作委派给另一个线程完成.在不生成响应的情况下返回至容器．（问题） Guava的EventBus实现订阅者模式，观察者模式 1234567891011121314151617public class EventBusDemo &#123; @Subscribe public void sendMessageByMail(String message) &#123; System.out.println(&quot;邮件发送一条信息：&quot; + message); &#125; @Subscribe public void sendMessageByPhone(String message) &#123; System.out.println(&quot;短信发送一条信息:&quot; + message); &#125; public static void main(String[] args) &#123; EventBus eventBus = new EventBus(); eventBus.register(new EventBusDemo()); eventBus.post(&quot;hi, boys&quot;); &#125;&#125; Mono和Flux常用API都是数据反应式编程的核心组件． Reactor是JVM的完全非阻塞响应式编程基础，具有高效的需求管理（以管理”背压”的形式）它直接与Java 8功能的API，特别是整合CompletableFuture，Stream和 Duration Flux 相当于一个 RxJava Observable 观察者 WebFluxSpring WebFlux是随Spring 5推出的响应式Web框架。 Spring WebFlux快速上手——响应式Spring的道法术器 微服务,部署包大小,应用占用内存大小. Rsocket用于响应式应用程序的新网络协议(应用层协议)． 提供Java，JavaScript，C ++和Kotlin等实现 它是一种基于Reactive Streams背压的双向，多路复用，基于消息的二进制协议 语言无关. 目的该协议专门设计用于与Reactive风格应用配合使用，这些应用程序基本上是非阻塞的，并且通常（但不总是）与异步行为配对 所谓Reactive背压: 即发布者无法向订户发送数据直到该订户已经准备就绪的想法，这是与“异步”的关键区别。（服务端主动） 问题: 很多个客户端对于同一个消息，准备好的时间层次不一，服务端怎么控制这个(这个消息需要一直保存着吗，什么时候清理)． 反应式编程(响应式reactive)是 Java 中高效应用的下一个前沿。但有两个主要障碍 -数据访问和网络。RSocket旨在解决后一个问题，而R2DBC旨在解决前者问题。 响应式应用新协议RSocket iPhone和Andriod手机，与后端服务交互，提供数据统计，所有这些互动模型，http并不是为此设计． http. 超文本传输协议,用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少. rest. 基于HTTP的REST服务. restTemplate. 获取http资源, 通过指定的一些格式(json等)． 数据统计收集 消息推送 异步响应 RSocket、. Envoy和. Istio从微服务治理的角度看RSocket、. Envoy和. Istio 重点是把反应流的实现，提升到应用层上来。其实在底层的协议中，就有反应流的实现，tcp的滑动窗口就是很好的例子。 很大一部分的线上故障是由于阻塞链接造成的. 简单的例子是如果所有的通讯都是反应式的，那就不用容断了. 与http不同的四种交互模式 （重点） Fire-and-Forget优化请求/响应，在不需要响应时非常有用，例如非关键事件日志记录。 请求/响应当您发送一个请求并收到一个响应时，就像HTTP一样。即使在这里，该协议也具有优于HTTP的优点，因为它是异步和多路复用的。 请求/流类似于返回集合的请求/响应，集合被回送而不是查询直到完成，因此例如发送银行帐号，用实时的帐户事务流进行响应。 频道允许任意交互模型的双向消息流。 Unix网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作． 多路复用的Selector不短的轮询注册在其上的Channel.如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来．然后通过SelectionKey可以获取就绪的Channel的集合，进行后续的I/O操作. TomcatNio 针对网络IO层面的异步－多路复用.(读写) Rsocket是交互模式的异步.(或者说Rsocket的请求和响应与Http的请求和响应有什么区别，优点在那里.) Http的异步通过callBack回调实现.(比如短信交互流程) 客户端使用http发送，短信平台和网关再到运营商都是长链接协议.短信平台受到同一链路上的送达之后．会callBack客户端.客户端收到后，处理回调．如果回调资源处理不当(处理不过来),会导致回调消息丢失． (Rsocket回压场景) 这种http的异步是通过应用程序多次请求实现.再就是客户端层面控制异步. 将请求后的等待丢进线程池或者队列来存储 AsyncCall，然后去做其他的事情． 将 AsycnCall 添加到队列中。将任务交给 Dispatcher 去执行。比如 OKHTTP实现的异步请求． 使用线程池处理异步任务（这种开销太大，很少做）.真正的异步执行者 AsyncCall 使用队列.将 AsycnCall 添加到队列中。将任务交给 Dispatcher 去执行 在使用 Dispatcher 会将 AsyncCall 交给指定的线程去执行，而 AsyncCall 是 NamedRunnable 的子类 OKHTTP异步和同步请求简单分析 Rsocket的异步，理解为没有收到响应，链接保持，但可以做其他事情，受到响应后再做处理.Rsocket天然支持? 深度解读Tomcat中的NIO模型 异步编程：协作性多任务处理","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"编程相关","slug":"平台工具/编程相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"}]},{"title":"开发工具","date":"2019-01-08T03:55:57.000Z","path":"wk/平台工具/工具组件/IDE/开发工具/","text":"好用的开发工具dbeaver https://nosqlbooster.com/downloads","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"IDE","slug":"平台工具/工具组件/IDE","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/IDE/"}]},{"title":"前端框架选择方案","date":"2019-01-08T03:55:57.000Z","path":"wk/平台工具/工具组件/前端方案/前端框架记录/","text":"*后台方案 Github上 10 个开源免费且优秀的后台控制面板（接私活必备哦）java钢铁侠-马克51号 链接 AntVAntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。 比较完善的各个场景的方案。 G2可视化引擎 G6图可视化方案 G2Plot开箱即用的图表库 L7 空间数据可视分析. 图表魔方,图表的生成ChartCube 将用户的gps信息 使用flink统计保存。然后将坏人的信息保存。 AntV文档 AntD Adminhttps://antd-admin.zuiidea.com/zh/dashboard 中后台解决方案. 中后台解决方案Fusion Adminui后台管理系统。基于Bootstrap3.3.6。 echartsjs图可视化方案. element-ui重点https://ruoyi.setworld.net/system/userhttps://gitee.com/fuzui/RuoYi-Antdv?_from=gitee_search https://gitee.com/big-hedgehog/aidex-sharp 深度关系探索、关联分析、路径搜索、特征抽取、数据聚类、社区检测、 知识图谱等，适用业务领域有如网络安全、电信诈骗、金融风控、广告推荐、社交网络和智能机器人 fantastic-admin [推荐指数 *] 半付费.Vue中后台管理系统框架. 兼容PC、移动端.https://gitee.com/hooray/fantastic-admin Vue 更适合 中后台项目. react 适合大型前端项目, 性能更好些.","tags":[{"name":"后台系统方案","slug":"后台系统方案","permalink":"https://quano.gitee.io/tags/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"前端方案","slug":"平台工具/工具组件/前端方案","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88/"}]},{"title":"Vue特性","date":"2019-01-08T03:55:57.000Z","path":"wk/平台工具/编程相关/vue/Vue特性/","text":"声明式渲染Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统： 文本插值 数据和 DOM 建立关联，所有东西都是响应式的。 绑定元素特性 v-bind 特性被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性 条件与循环 控制切换一个元素是否显示 我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM 结构。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用过渡效果。 还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表： 1234567&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 处理用户输入 为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法： Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。 组件化应用构建组件系统是 Vue的另一个重要概念， 因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树： 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"编程相关","slug":"平台工具/编程相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"name":"vue","slug":"平台工具/编程相关/vue","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/vue/"}]},{"title":"Vue项目采坑记录","date":"2019-01-08T03:55:57.000Z","path":"wk/平台工具/编程相关/vue/Vue项目问题记录-采坑记/","text":"npm install 失败. 应该是系统某个软件占用了翻墙，导致翻墙失败，在无法翻墙的情况下，安装CNPM 或 直接安装，都无法成功。 使用安装cnpm: npm install -g cnpm —registry=https://registry.npm.taobao.org 然后使用 cnpm install","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"编程相关","slug":"平台工具/编程相关","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"name":"vue","slug":"平台工具/编程相关/vue","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/vue/"}]},{"title":"ssh免密登录","date":"2019-01-08T03:55:57.000Z","path":"wk/数据/数据处理/组件安装配置/Hadoop组件安装/1.配置ssh免密登录/","text":"1.首先查看电脑的SSH Keys是否存在 1ls -al ~/.ssh 2.存在以下文件则说明key已生成 12-rw------- 1 zbm zbm 1675 Oct 28 11:04 id_rsa-rw-r--r-- 1 zbm zbm 399 Oct 28 11:04 id_rsa.pub 3.否则生成key: 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 4.之后配置免密登陆：即将pub key put到远程服务器。输入密码，之后每次就可免密登陆。 1ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;romte_ip&gt;","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"组件安装配置","slug":"数据/数据处理/组件安装配置","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"name":"Hadoop组件安装","slug":"数据/数据处理/组件安装配置/Hadoop组件安装","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/Hadoop%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"1.ES介绍","date":"2018-12-15T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/1.ES介绍/","text":"es核心介绍 Elasticsearch Clients Kibana 用户手册 Es介绍 elasticsearch百科 Elasticsearch－基础介绍及索引原理分析 推荐google浏览器的json浏览工具:chrome://extensions/ JSON Viewer0.18.0","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"5.Logstash安装","date":"2018-12-15T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/5.Logstash安装/","text":"logstash是做数据采集的，类似于flume。 官网logstash介绍 下载地址 解压后执行一下命令,查看效果: 1bin/logstash -e &#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27; 安装logstash-input-jdbc参考 logstash-input-jdbc插件是logstash 的一个个插件。 使用ruby语言开发. 安装gem, 替换淘宝镜像 123456安装gemsudo apt install gemsudo apt install rubygem -vgem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/gem sources -l RubyGems镜像站 查看logstash可用插件 1bin/logstash-plugin list --verbose 以上找到对应的版本. 查看相应的文档https://www.elastic.co/guide/en/logstash-versioned-plugins/current/v4.3.9-plugins-inputs-jdbc.html 安装命令 1bin/logstash-plugin install logstash-input-jdbc 使用实现mysql数据同步到Elasticsearch 需要一个mysql驱动包，sql文件,以及conf配置文件 sql文件 bank_sync.sql 1234567SELECT t.id, t.`code`, t.`name`, t.per_day_limitFROM tb_bank_type t mysql.conf文件 12345678910111213141516171819202122232425262728293031323334353637input &#123; jdbc &#123; # mysql jdbc connection string to our backup databse jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/carinsurance&quot; # the user we wish to excute our statement as jdbc_user =&gt; &quot;carinsurance&quot; jdbc_password =&gt; &quot;123456&quot; # the path to our downloaded jdbc driver jdbc_driver_library =&gt; &quot;/opt/elasticsearch/logstash-6.2.2/sql/mysql-connector-java-5.1.40.jar&quot; # the name of the driver class for mysql jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; statement_filepath =&gt; &quot;/opt/elasticsearch/logstash-6.2.2/sql/bank_sync.sql&quot; schedule =&gt; &quot;*/1 * * * *&quot; type =&gt; &quot;jdbc&quot; &#125;&#125;filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;127.0.0.1:9200&quot; index =&gt; &quot;bank&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; 上面配置文件中的sql文件和mysql驱动注意路径正确 启动logstash 123bin/logstash -f mysql.conf 后台启动: nohup ./logstash -f mysql.conf &gt; /dev/null 2&gt;&amp;1 &amp;nohup bin/logstash -f sync-data/mysql.conf &amp; 注意: es需要外网访问,同kibana,需要配置如下: 1network.host: 0.0.0.0 配置以上后出现问题: 系统最大文件描述符限制,最大虚拟内存限制 解决: 12345678vi /etc/security/limits.conf 将65535 改为65536root用户执行以下:vi /etc/sysctl.conf 添加一下配置vm.max_map_count=655360使其生效sysctl -p 应用【技术实验】mysql准实时同步数据到Elasticsearch 全文搜索引擎 Elasticsearch （三）logstash-input-jdbc同步数据 到elasticsearch","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"Redis常用操作","date":"2018-12-14T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Redis/Redis常用操作/","text":"Redis开发运维实践指南 monitor1redis-cli -p 6380 monitor info123456789101112131415Server：运行的redis实例一些信息，包括：redis版本，操作系统信息，端口，GCC版本，配置文件路径等；Clients：redis客户端信息，包括：已连接客户端数量，阻塞客户端数量等；Memory：使用内存，峰值内存，内存碎片率，内存分配方式。这几个参数都非常重要；Persistence：AOF和RDB持久化信息；Stats：一些统计信息，最重要三个参数：OPS(instantaneous_ops_per_sec)，keyspace_hits和keyspace_misses两个参数反应缓存命中率；Replication：redis集群信息；CPU：CPU相关信息；Keyspace：redis中各个DB里key的信息； configconfig是一个非常有价值的命令，主要体现在对redis的运维。因为生产环境一般是不允许随意重启的，不能因为需要调优一些参数就修改conf配置文件并重启。redis作者早就想到了这一点，通过config命令能热修改一些配置，不需要重启redis实例，可以通过如下命令查看哪些参数可以热修改： 1config get * 热修改就比较容易了，执行如下命令即可： 1config set 这样修改的话，如果以后由于某些原因redis实例故障需要重启，那通过config热修改的参数就会被配置文件中的参数覆盖，所以我们需要通过一个命令将config热修改的参数刷到redis配置文件中持久化，通过执行如下命令即可：1config rewrite","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Redis","slug":"数据/数据处理/DataStore/Redis","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Redis/"}]},{"title":"Docker 仓库搭建","date":"2018-12-14T13:55:57.000Z","path":"wk/平台工具/工具组件/Docker/003.镜像仓库-Docker镜像仓库搭建/","text":"123456789101112mkdir -p /opt/data/registry //创建目录docker run -d \\ -p 5000:5000 \\ --restart=always \\ --name docker-registry \\ -v /data/docker-registry:/var/lib/registry \\ registry:2-d : 让容器可以后台运行-p ：指定映射端口（前者是宿主机的端口号，后者是容器的端口号）-v ：数据挂载（前者是宿主机的目录，后者是容器的目录）--name : 为运行的容器命名","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"系统镜像","date":"2018-12-14T13:55:57.000Z","path":"wk/平台工具/工具组件/Docker/004.系统镜像/","text":"Ubuntu镜像地址 拉取镜像 启动镜像 在镜像中操作1docker run -i -t ubuntu bash CentOS下载镜像1docker pull centos:6.8 启动容器1docker run -ti --name centos001 centos:6.8 /bin/bash 安装软件12345vi 、 sshdyum install viyum install openssh-server 查看是否启动 123/etc/init.d/sshd statusservice sshd start","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"Ubuntu16安装Docker环境","date":"2018-12-12T03:55:57.000Z","path":"wk/平台工具/工具组件/Docker/002.Docker环境-Ubuntu16安装Docker环境/","text":"之前每次安装都是上网查查资料，每次待找半天。所以在这里总结下。首先Docker在Ubuntu下的安装分为以下几个步骤： 添加Docker源 安装aufs驱动linux-image-extra 安装Docker 安装后的设置 Docker更新 添加Docker源解释一下。使用Ubuntu在命令行可以直接安装Docker，但是一般都是老一些的版本，而且下载缓慢。所以换Docker源很有必要。 具体操作如下： 123456789101112131415sudo apt-get update# 增加CA证书sudo apt-get install apt-transport-https ca-certificates# 添加GPG Key(一种加密手段)sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D# 添加docker的源echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial main&quot; &gt; /etc/apt/sources.list.d/docker.list或echo &quot;deb https://apt.dockerproject.org/repo ubuntu-xenial main&quot; | sudo tee /etc/apt/sources.list.d/docker.list# 再次更新源sudo apt-get update# 清除过时源（以防万一）sudo apt-get purge lxc-docker# 验证APT是从正确的库源下载应用apt-cache policy docker-engine 安装aufs驱动linux-image-extraFor Ubuntu Trusty, Wily, and Xenial, it’s recommended to install the linux-image-extra kernel package. The linux-image-extra package allows you use the aufs storage driver可以实现容器间可执行文件和运行库的共享。 1sudo apt-get install linux-image-extra-$(uname -r) 安装Docker12sudo apt-get updatesudo apt-get install docker-engine 安装后的设置将用户添加到docker组中，避免每次都是用sudo。 1sudo usermod -aG docker $&#123;user&#125; Docker更新1234# 更新Dockersudo apt-get upgrade docker-engine# 卸载Dockersudo apt-get purge docker-engine","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"2.Docker环境Mysql使用","date":"2018-12-12T03:55:57.000Z","path":"wk/平台工具/工具组件/Docker/2.Docker环境使用MySQL/","text":"阿里云镜像仓库地址 配置docker使用阿里云镜像地址 获取镜像1docker pull mysql 启动镜像 1docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=zhangquanquan -d mysql 参数指定root用户密码 验证 进入容器，登录mysql，可以看到123456789Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.20 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. mysql创建用户并授权1234create database ibase4j; create user ibase; grant all privileges on ibase4j.* to ibase@&#x27;192.168.1.7&#x27; identified by &#x27;ibase&#x27;; flush privileges;","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"Docker环境其他中间件使用","date":"2018-12-12T03:55:57.000Z","path":"wk/平台工具/工具组件/Docker/3.Docker环境其他中间件使用/","text":"phpmyadmin 12docker run --name myadmin -d -e PMA_HOST=172.17.0.2 phpmyadmin/phpmyadmin docker run --name yst_myadmin -d -e PMA_HOST=10.10.73.109 phpmyadmin/phpmyadmin redis 12docker run --name some-redis -d redis docker run -d --name redis-server -p 6379:6379 redis --requirepass &quot;mypassword&quot; pika 123456789101112docker pull pikadb/pika:v3.2.2# 或者 docker pull wxstc/pika-alpine [镜像小一些]docker run -p 6399:9221 --name pika-server --hostname pika \\-d pikadb/pika:v3.2.2 \\./bin/pika -c conf/pika.conf Docker 搭建Pika分片多主集群 elasticsearch1docker run -d elasticsearch es的python 客户端 Elasticsearch Clients Elasticsearch集群和索引常用命令 rabbitmq 123docker run -d --hostname my-rabbit --name some-rabbit rabbitmqdocker run -d --hostname rabbit001 --name myrabbit -e RABBITMQ_DEFAULT_USER=admin \\-e RABBITMQ_DEFAULT_PASS=admin123 -p 5672:5672 rabbitmq zookeeper 1docker run --name some-zookeeper -p 2181:2181 --restart always -d zookeeper nexusnexus官方镜像 1docker pull registry.cn-hangzhou.aliyuncs.com/nichozuo/nexus 123456789docker run \\ --detach \\ --name nexus \\ --restart always \\ --publish 8081:8081 \\ --env CONTEXT_PATH=/nexus \\ --volume /opt/tools/nexus:/sonatype-work \\ --volume /etc/localtime:/etc/localtime:ro \\ registry.cn-hangzhou.aliyuncs.com/nichozuo/nexus 镜像启动见链接以上地址 nacos neo4j1docker run -d --name neo4j-server -p 7474:7474 -p 7687:7687 -v /home/neo4j/data:/data -v /home/neo4j/logs:/logs -v /home/neo4j/conf:/var/lib/neo4j/conf -v /home/neo4j/import:/var/lib/neo4j/import --env NEO4J_AUTH=neo4j/zhangquanquan neo4j","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"Dockerfile语法","date":"2018-12-12T03:55:57.000Z","path":"wk/平台工具/工具组件/Docker/4.Dockerfile语法/","text":"Dockerfile创建镜像 Dockerfile 1234567891011121314151617181920212223242526# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author: docker_user# Command format: Instruction [arguments / command] ..# Base image to use, this must be set as the first lineFROM ubuntu# Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)MAINTAINER docker_user docker_user@email.com# Commands to update the image#RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list#RUN apt-get update &amp;&amp; apt-get install -y nginx#RUN echo &quot;\\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf# Commands when creating a new container#CMD /usr/sbin/nginxENV JAVA_HOME=/opt/tools/jdk1.8.0_131ENV PATH=$JAVA_HOME/bin:$PATHENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# docker build -t nova/jdk .# docker run -it --name my-java -d java","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"Docker NetWork","date":"2018-12-12T03:55:57.000Z","path":"wk/平台工具/工具组件/Docker/6.Docker网络/","text":"docker容器跨主机互联小实验 docker 多种跨主机访问选择哪一种 理解Docker跨多主机容器网络 Docker rabbit12docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=password -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management Docker redis1docker run -d --name redis-server -p 6379:6379 redis --requirepass &quot;password&quot;","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"Python常用函数","date":"2018-12-09T03:55:57.000Z","path":"wk/平台工具/程序语言/Python/基础操作/","text":"shape读取矩阵的长度. shape函数是numpy.core.fromnumeric中的函数，它的功能是读取矩阵的长度，比如shape[0]就是读取矩阵第一维度的长度。shape的输入参数可以是一个整数（表示维度），也可以是一个矩阵。以下例子可能会好理解一些： Python numpy函数：shape用法 mat创建矩阵 python中的mat的操作","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"}]},{"title":"ELK","date":"2018-12-09T03:55:57.000Z","path":"wk/数据/数据处理/数据收集/ELK/","text":"Docker快速搭建elk服务镜像","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"数据收集","slug":"数据/数据处理/数据收集","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86/"}]},{"title":"其他算法","date":"2018-12-07T14:55:57.000Z","path":"wk/算法/001.机器学习/5.其他算法/","text":"Java中的字符串相似度","tags":[],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Tcp,Ip及其应用","date":"2018-12-04T15:11:57.000Z","path":"wk/项目管理/软件工程/计算机网络/TCP-IP及应用问题/","text":"SocketRead问题针对线程处于 at java.net.SocketInputStream.socketRead0(Native Method) , java.lang.Thread.State: RUNNABLE. 123456789&quot;http-nio-10251-exec-1213&quot; #86023 daemon prio=5 os_prio=0 tid=0x00007f838c0f8000 nid=0x1f9 runnable [0x00007f83693bd000] java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.security.ssl.InputRecord.readFully(InputRecord.java:465)... 关于TCP交互流程与客户端服务端状态 TimeWait,CloseWait 有没有问题","tags":[],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"计算机网络","slug":"项目管理/软件工程/计算机网络","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Kafka问题总结","date":"2018-12-04T15:11:57.000Z","path":"wk/数据/数据处理/DataStore/Kafka/关于最近kafka的几个问题/","text":"consumer提交offset失败使用spring-kafka, 配置auto.commit =true 会使用kafka.client的 自动提交机制(5秒钟提交一次-具体细节TODO). 然而一定时间取出的消息没有处理完,长时间没能提交成功??? 现象: offset没有提交成功, consumer的协调者处于dead状态, 恢复后但还能正常消费,但offset一直未能提交. Socket一个线程导致消费挂起现象: Socket一直处于read状态,导致往队列push消息失败,取出来的消息也没有处理, 没有提交offset. 可能1. socket read timeout 设置后, 其他线程就处于 Timewait 状态,但是 实际设置connect 超时时间在 socket 超时时间之后, 所以没有超时时间相当于.","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"}]},{"title":"机器学习认识","date":"2018-12-02T14:55:57.000Z","path":"wk/算法/001.机器学习/1.机器学习认识/","text":"传统上认为，让计算机完成某一件事情的唯一方法，就是详细的记录某个算法（就是一系列的指令，告诉计算机能做什么），并解释其如何运行。 但机器学习算法不一样：通过从数据中推断，计算机自己会弄明白该怎么做。掌握的数据越多，它们的工作就越顺利。现在我们不给计算机编程。它们自己给自己编程。 机器学习是以数据为依据，数据越多，能学的也越多、没有数据，那就什么也学不到。有了大数据？那就有太多的东西可以学习。 只要有足够的数据，一段只有几百行代码的程序可以轻易生成几百万代码的程序。而且可以不同问题持续的去编写不同的程序。 机器学习有时会和人工智能混淆。严格来说，机器学习是人工智能的子集，但机器学习发展如此壮大且成功，现已超越以前它引以为傲的母领域。人工智能的目标是教会计算机做现在人类能做的事，并且做的更好。而机器学习可以说就是其中最重要的事：不持续学习。计算机就永远无法跟上人类的步伐，有了学习，一切都与时俱进。 知乎-机器学习该怎么入门 机器学习入门资源不完全汇总","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Logistic回归","date":"2018-12-02T14:55:57.000Z","path":"wk/算法/001.机器学习/3.Logistic回归/","text":"概述回归: 假设有一组数据点,用一条直线对这些点进行拟合,这个拟合过程就是回归.回归一词源于最佳拟合,表示要找到最佳拟合参数. 训练分类器的做法就是寻找最佳拟合参数. 使用的一些优化算法: 梯度上升法,最小二乘法. 最优化算法1. 最小二乘法向量运算进行参数求解过程 损失函数,给定数据X,Y, 根据aX 的出的Y1 与Y之间的偏差,称为损失.怎么将这个损失降到最低. 首先定义这损失,线性空间的距离,通过欧几里得距离定义这个损失. 损失最小化: 对损失函数求导,得到参数方程. 进行参数计算. 2. 梯度下降为什么梯度下降是必须的? 最小二乘法参数计算的问题: 矩阵是否满秩 运算性能 梯度下降不仅限于线性回归. 经过多次的重复, 比直接运算(参数计算)的优点.","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Nlp认识","date":"2018-12-02T14:55:57.000Z","path":"wk/算法/001.机器学习/NLP/Nlp认识/","text":"七大NLP技术 技术1：文本嵌入（Text Embeddings）在传统的NLP中，我们将单词视为离散符号，然后可以用one-hot向量表示。向量的维度是整个词汇表中单词的数量。单词作为离散符号的问题在于，对于one-hot向量来说，没有自然的相似性概念。因此，另一种方法是学习在向量本身中编码相似性。核心思想是一个词的含义是由经常出现在其旁边的单词给出的。 技术2：机器翻译机器翻译是语言理解的经典测试。它由语言分析和语言生成组成。大型机器翻译系统具有巨大的商业用途。 1.端到端训练2.分布式表示的优势3.更好地探索上下文4.更流利的文本生成 技巧3：Dialogue和Conversations技术4：情绪分析用于情感分析的现代深度学习方法可用于形态学、语法和逻辑语义，其中最有效的是递归神经网络。顾名思义，递归神经网络开发的主要假设递归是描述语言的自然方式。递归在消歧方面很有用，有助于某些任务引用特定的短语，并且对于使用语法树结构的任务非常有效。 技术5：问答系统问答（QA）系统的想法是直接从文档、对话、在线搜索和其他地方提取信息，以满足用户的信息需求。QA系统不是让用户阅读整个文档，而是更喜欢简短而简洁的答案。如今，QA系统可以非常容易地与其他NLP系统结合使用，并且一些QA系统甚至超越了对文本文档的搜索，并且可以从图片集合中提取信息。 强大的深度学习架构（称为动态内存网络（DMN））已针对QA问题进行了专门开发和优化。给定输入序列（知识）和问题的训练集，它可以形成情节记忆，并使用它们来产生相关答案。该体系结构具有以下组件： ·语义内存模块（类似于知识库）被用来创建从输入句子的嵌入字序列预先训练手套载体。 ·输入模块处理与问题有关的输入矢量称为事实。该模块使用门控循环单元实现，GRU使网络能够了解当前正在考虑的句子是否相关或与答案无关。 ·问题模块逐字处理疑问词，并且使用输出相同权重的GRU输入模块的向量。事实和问题都被编码为嵌入。 ·情景记忆模块接收从输入中提取和编码的嵌入事实和问题载体。这使用了一个受大脑海马体启发的想法，它可以检索由某些反应触发的时间状态，如景点或声音。 ·答案生成模块，通过适当的响应，情景记忆应该包含回答问题所需的所有信息。该模块使用另一个GRU，使用正确序列的交叉熵错误分类进行训练，然后可以将其转换回自然语言。 技术6：文本摘要人类很难手动汇总大型文本文档。文本摘要是NLP为源文档创建简短、准确和流畅的摘要问题。随着推送通知和文章摘要获得越来越多的注意力，为长文本生成智能且准确摘要的任务每天都在增长。 文本摘要有两种基本方法：提取和抽象。前者从原始文本中提取单词和单词短语以创建摘要。后者是学习内部语言表示以生成更像人类的摘要，解释原始文本的意图。","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"算法/001-机器学习/NLP","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NLP/"}]},{"title":"KNN","date":"2018-12-02T03:55:57.000Z","path":"wk/算法/001.机器学习/2.KNN/","text":"概述简单的说,K-近邻算法采用测量不同特征值之间的距离方法进行分类. 工作原理: 存在一个样本数据集合, 也称作训练样本集, 并且样本集中的每个数据都存在标签(即我们知道样本集中每一数据与所属分类的对应关系),输入没有标签的新数据后.将新数据的每个特征与样本集中数据对应的特征进行比较,然后算法提取样本集中特征最相似数据(最近邻)的分类标签. 特性: 优点: 精度高,对异常值不敏感,无数据输入假设 缺点,计算复杂度高,空间复杂度高 使用数据范围: 数值型和标称型. 举例使用KNN 分类爱情片和动作片.基于电影中出现的亲吻,打斗出现的次数,使用k-近邻构造程序. 训练样本集: A 打斗镜头: 3 接吻镜头: 104 电影类型 : 爱情片B 打斗镜头: 2 接吻镜头: 100 电影类型 : 爱情片C 打斗镜头: 1 接吻镜头: 81 电影类型 : 爱情片D 打斗镜头: 101 接吻镜头: 10 电影类型 : 动作片E 打斗镜头: 99 接吻镜头: 5 电影类型 : 动作片F 打斗镜头: 98 接吻镜头: 2 电影类型 : 动作片G 打斗镜头: 18 接吻镜头: 90 电影类型 : ? 已知类型电影 (A,B,C,D,E,F) 与 未知类型电影(G) 的距离如下. 距离怎么定义的?? (二维空间的绝对距离?) A 与 G 的距离 : 20.5B 与 G 的距离 : 18.7C 与 G 的距离 : 19.2D 与 G 的距离 : 115.3E 与 G 的距离 : 117.4F 与 G 的距离 : 118.9 现在得到了样本集中所有电影与未知电影的距离,按照距离递增排序, 可以找到k个距离最近的电影.假设k=3, 则最近的三个电影依次为: F,E,D. 而 这三个都是爱情片, 因此我们判断未知电影为爱情片. 算法实现 收集数据 准备数据: 距离计算所需要的数值,最好是结构化的数据格式 分析数据 训练算法: k近邻不适用 测试算法: 计算错误率 使用算法 这里只介绍最后的算法使用步骤:实施KNN分类算法. 主要函数功能为: 使用k-近邻算法将每组数据划分到某个类别中.步骤如下 123456对未知类别属性的数据集中的每个点依次执行以下操作:1. 计算已知类别数据集中的点与当前点之间的距离2. 按照距离递增次序排序3. 选取与当前点距离最小的k个点4. 确定前k个点所在类别的出现频率 5. 返回前k个点出现频率最高的类别作为当前点的预测分类. python函数如下: 1234567891011121314def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] // 距离计算 diffMat = tile(inX, (dataSetSize, 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) disstances = sqDistances.argsort() classCount=&#123;&#125; // 选择距离最小的k个点 for i in rang(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 其它代码见:https://github.com/quantumcs/Machine-Learning-In-Action 算法测试有关数据收集 文本数据的转换及处理etc. 其它的一些应用 约会网站的配对 手写识别系统 问题1. 一个简单的模型,存在的问题现有一个模型, 针对每个新的句子,使用相似度算出与已知样本集中每个句子的相似度. 而已知样本集只有一个类别(也就是说都是负样本). 取最大的相似度值,和阈值比较,大于阈值的定义同一个类别,小于阈值的定为不同类别. 存在的问题: 1. 没有考虑正样本,这个策略效果肯定存在提升. 2. 另外的提升思路: 对句子做预处理,去除变化较大的实体,降低对相似性的影响.","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"AdaBoost算法","date":"2018-12-02T03:55:57.000Z","path":"wk/算法/001.机器学习/4.利用AdaBoost元算法提高分类性能/","text":"组合相似的分类器来提高分类性能 应用AdaBoost算法 处理非均衡分类问题 概述元算法: 对其他算法进行组合的一种方式. 代表-AdaBoost 不同分类器的集成方法: boosting方法(代表-AdaBoost) 非均衡分类问题 基于数据集多重抽样的分类器学习了常见的分类算法:KNN,决策树,朴素贝叶斯,logistic回归.他们各有优缺点,可以将不同的分类器进行组合,而这种组合结果就被称为集成方法或者元算法. 1. bagging基于数据随机重抽样的分类器构建方法 是从原始数据集选择S次后得到S个数据集的一种技术,新数据集和原数据集的大小相等. 一种先进的bagging方法 - 随机森林 2. boosting类似bagging技术. 不管是boosting还是bagging,所使用的多个分类器的类型都是一致的,但是在前者当中,不同分类器是通过串行训练而获得的,每个新分类器都根据已训练出的分类器的性能进行训练. boosting是通过集中关注被已有分类器错分的那些数据来获得新的分类器. 由于boosting分类的结果是基于所有分类器的加权求和结果的,因此boosting与bagging不太一样. bagging中的分类器权重是相等的,而boosting中的分类器权重并不相等,每个权重代表的是其对应分类器在上一轮迭代中的成功度. boosting方法拥有多个版本,本文只关注一个最流行的版本AdaBoost. AdaBoost一般流程 1234561. 收集数据2. 准备数据: 依赖于所使用的弱分类器类型,比如单层决策树,这种分类器可以处理任何数据类型.(作为弱分类器,简单分类器的效果更好)3. 分析数据4. 训练算法: AdaBoost的大部分时间都用在训练上,分类器将多次在同一数据集上训练弱分类器5. 测试算法: 计算分类的错误率6. 使用算法:同SVM一样,AdaBoost预测两个类别中的一个.如果想把它应用到多个类别的场合,那么就要像多累SVM中的做法一样对AdaBoost进行修改 关于分类性能度量指标:正确率\\召回率及ROC曲线. 128p. 基于代价函数的分类器决策控制. p131 处理非均衡问题的数据抽样方法 p132 代码:https://github.com/quantumcs/Machine-Learning-In-Action/tree/master/Ch07","tags":[{"name":"MchineLearning","slug":"MchineLearning","permalink":"https://quano.gitee.io/tags/MchineLearning/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"001.机器学习","slug":"算法/001-机器学习","permalink":"https://quano.gitee.io/categories/%E7%AE%97%E6%B3%95/001-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"sbt了解","date":"2018-12-02T03:55:57.000Z","path":"wk/平台工具/工具组件/Builder/sbt/","text":"下载安装:https://www.scala-sbt.org/download.html sbt是类似ANT、MAVEN的构建工具，全称为Simple build tool，是Scala事实上的标准构建工具。 主要特性: 原生支持编译Scala代码和与诸多Scala测试框架进行交互； 使用Scala编写的DSL（领域特定语言）构建描述 使用Ivy作为库管理工具 持续编译、测试和部署 整合scala解释器快速迭代和调试 支持Java与Scala混合的项目 加速 SBT 下载依赖库的速度 sbt介绍与构建Scala项目","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Builder","slug":"平台工具/工具组件/Builder","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Builder/"}]},{"title":"Python学习","date":"2018-12-02T03:55:57.000Z","path":"wk/平台工具/程序语言/Python/Python语法学习笔记/","text":"语言比较 有非常完善的基础代码库 定位:“优雅”、“明确”、“简单” Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 可以做什么? 网站、后台服务等都可以 数据类型在内存中存储的数据可以有多种类型。 例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。 Python 定义了一些标准类型，用于存储各种类型的数据。 Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 基本类型及Python数据类型转换 1. List1list = [ &#x27;runoob&#x27;, 786 , 2.23, &#x27;john&#x27;, 70.2 ] 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 2. Tuple1tuple = ( &#x27;runoob&#x27;, 786 , 2.23, &#x27;john&#x27;, 70.2 ) 元组是另一个数据类型，类似于List（列表）。 元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 3. Dictionary1234dict = &#123;&#125;dict[&#x27;one&#x27;] = &quot;This is one&quot;dict[2] = &quot;This is two&quot;tinydict = &#123;&#x27;name&#x27;: &#x27;john&#x27;,&#x27;code&#x27;:6734, &#x27;dept&#x27;: &#x27;sales&#x27;&#125; 4. 数据类型转换Python数据类型转换 其他Python 内置函数 Python GUI编程(Tkinter) Python JSON","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"}]},{"title":"Scala项目构建","date":"2018-12-02T03:55:57.000Z","path":"wk/平台工具/程序语言/Scala/使用maven构建scala项目/","text":"SCALA WITH MAVEN 1234mvn archetype:generate输入 groupId等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;2.11.8&lt;/version&gt; &lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- This plugin compiles Scala files --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;scala-compile-first&lt;/id&gt; &lt;phase&gt;process-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;add-source&lt;/goal&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;scala-test-compile&lt;/id&gt; &lt;phase&gt;process-test-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- This plugin compiles Java files --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- This plugin adds all dependencies to JAR file during &#x27;package&#x27; command. Pay EXTRA attention to the &#x27;mainClass&#x27; tag. You have to set name of class with entry point to program (&#x27;main&#x27; method) --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;ScalaRunner&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; scala和maven整合实践","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Scala","slug":"平台工具/程序语言/Scala","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Scala/"}]},{"title":"Scala学习","date":"2018-12-02T03:55:57.000Z","path":"wk/平台工具/程序语言/Scala/Scala入门/","text":"有了java,为什么要用scala.想学scala. 先了解下它有什么比java更优秀的地方. Scala是2001年诞生的一门多范式语言 .设计初衷是要集成面向对象编程和函数式编程的各种特性 Scala 特性 面向对象特性 函数式编程 静态类型 扩展性 并发","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Scala","slug":"平台工具/程序语言/Scala","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Scala/"}]},{"title":"数据处理相关","date":"2018-12-02T03:55:57.000Z","path":"wk/数据/数据处理/技术文章/Start/","text":"https://www.iteblog.com/archives/1947.html 事件驱动编程、消息驱动编程、数据驱动编程 不错的概念解释","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"技术文章","slug":"数据/数据处理/技术文章","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"}]},{"title":"Kafak监控","date":"2018-12-02T03:55:57.000Z","path":"wk/数据/数据处理/DataStore/Kafka/Kakfa监控/","text":"推荐的监控工具kafka-offset-monitor Python实现监控123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196topics = [&#x27;heimdallr-dev&#x27;]# 要监控的groupidmonitor_group_ids = [&#x27;heimdallr&#x27;]# broker-listservers = &#x27;localhost:9092&#x27;# 监控数据上报间隔 秒time_interval = 10# 历史全量数据上报间隔history_time_interval = 5 * 60# -*- coding:utf-8 -*-import timeimport sysfrom kafka.client import KafkaClientfrom kafka.protocol.commit import OffsetFetchRequest_v1, OffsetFetchResponse_v1, OffsetFetchRequest_v0, \\ OffsetFetchResponse_v0from kafka.protocol.offset import OffsetRequest_v0, OffsetResponse_v0#from monitor_constants import *duration = 0client = Noneconn = Nonepartition_cache = &#123;&#125;brokers_cache = []kafka_type = [&#x27;heimdallr&#x27;]zk_type = []def get_brokers(): if not brokers_cache: brokers = client.cluster.brokers() if brokers: brokers_cache.extend([x.nodeId for x in brokers]) return brokers_cachedef get_partitions(topic): if not partition_cache or topic not in partition_cache: partitions = client.cluster.available_partitions_for_topic(topic) if partitions: partition_cache[topic] = [x for x in partitions] else: return [] return partition_cache[topic]def get_logsize(): &quot;&quot;&quot; 获取topic 下每个partition的logsize(各个broker的累加) :return: &quot;&quot;&quot; tp = &#123;&#125; # topic : partition_dict brokers = get_brokers() for topic in topics: partitions = get_partitions(topic) pl = &#123;&#125; # partition : logsize for broker in brokers: # 这里取笛卡尔积可能有问题,但是不影响parse中解析了 for partition in partitions: client.send(broker, OffsetRequest_v0(replica_id=-1, topics=[(topic, [(partition, -1, 1)])])) responses = client.poll() pdict = parse_logsize(topic, partition, responses) append(pl, pdict) tp[topic] = pl return tpdef append(rdict, pdict): if rdict: # 已经有记录,累加 for k, v in pdict.items(): if k in rdict: rdict[k] = rdict[k] + v else: rdict[k] = v else: rdict.update(pdict)def parse_logsize(t, p, responses): &quot;&quot;&quot; 单个broker中单个partition的logsize :param responses: :param p: :param t: :return: &quot;&quot;&quot; for response in responses: if not isinstance(response, OffsetResponse_v0): return &#123;&#125; tps = response.topics topic = tps[0][0] partition_list = tps[0][1] partition = partition_list[0][0] # 异步poll来的数据可能不准 if topic == t and partition == p and partition_list[0][1] == 0: logsize_list = partition_list[0][2] logsize = logsize_list[0] return &#123;partition: logsize&#125; return &#123;&#125;def parse_offsets(t, responses): dr = &#123;&#125; for response in responses: if not isinstance(response, (OffsetFetchResponse_v1, OffsetFetchResponse_v0)): return &#123;&#125; tps = response.topics topic = tps[0][0] partition_list = tps[0][1] if topic == t: for partition_tunple in partition_list: if partition_tunple[3] == 0: offset = partition_tunple[1] dr[partition_tunple[0]] = offset return drdef get_offsets(): # &#123;gid: dict&#125; gd = &#123;&#125; for gid in monitor_group_ids: td = &#123;&#125; # &#123;topic:dict&#125; for topic in topics: pd = &#123;&#125; # &#123;partition:dict&#125; for broker in get_brokers(): partitions = get_partitions(topic) if not partitions: return &#123;&#125; else: responses = optionnal_send(broker, gid, topic, partitions) dr = parse_offsets(topic, responses) append(pd, dr) td[topic] = pd gd[gid] = td return gddef optionnal_send(broker, gid, topic, partitions): if gid in kafka_type: return kafka_send(broker, gid, topic, partitions) elif gid in zk_type: return zk_send(broker, gid, topic, partitions) else: responses = zk_send(broker, gid, topic, partitions) dct = parse_offsets(topic, responses) if is_suitable(dct): zk_type.append(gid) return responses responses = kafka_send(broker, gid, topic, partitions) dct = parse_offsets(topic, responses) if is_suitable(dct): kafka_type.append(gid) return responsesdef is_suitable(dct): for x in dct.values(): if x != -1: return Truedef kafka_send(broker, gid, topic, partitions): client.send(broker, OffsetFetchRequest_v1(consumer_group=gid, topics=[(topic, partitions)])) return client.poll()def zk_send(broker, gid, topic, partitions): client.send(broker, OffsetFetchRequest_v0(consumer_group=gid, topics=[(topic, partitions)])) return client.poll()def do_task(): offset_dict = get_offsets() #print (offset_dict) logsize_dict = get_logsize() #print (logsize_dict) print (&#x27;----------kafka monitor, info:-------------&#x27;) for gk, gv in offset_dict.items(): for tk, tv in gv.items(): for pk, pv in tv.items(): if logsize_dict and tk in logsize_dict: dr = logsize_dict[tk] # partition:logsize if dr and pk in dr: param = (gk, tk, pk, pv, dr[pk], time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;, time.localtime(time.time()))) print(param)if __name__ == &quot;__main__&quot;: client = KafkaClient(bootstrap_servers=servers, request_timeout_ms=3000) while True: do_task() time.sleep(time_interval) duration += time_interval 参考:https://my.oschina.net/ktlb/blog/863308","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"}]},{"title":"关于kafka的offset存储","date":"2018-11-24T17:36:57.000Z","path":"wk/数据/数据处理/DataStore/Kafka/关于kafka的offset存储/","text":"消费者通过offset控制消费的进度,这里有几个概念先解释一下. Offset: 每个ConsumerGroup中针对一个topic的每个Partition的消费进度.通过这个来控制消费进度. LogSize: Kafka的数据位置,随着新的数据到来而增加. Lag: LogSize - Offset . 指落后的大小. 因此正常Consumer的不堆积是Lag的值处于比较小的范围,比如 0~1000. 然而,存在的一些问题: 那随着数据量的增加,offset和logSize的值一直增加,到超过int的范围吗,还是有清零的规则.(应该是有相应的机制,这个不重要了) 有关offset的一些注意点如下 存储位置从kafka-0.9版本及以后,消费者组和offset信息就不存在zk中了,而是存到broker服务器上.存放在一个叫__consumer_offsets的topic中. 关于offset的消费者参数auto.offset.reset 123456earliest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费 latest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据 none topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常 也就是说,这个参数的指定只有在新的consumer group添加的时候,或者其他原因导致分区上的offset没有了的情况,才更有意义. 那随之又有的问题: 如果为了能消费新的数据,而对于老的customer-group,不想消费堆积的数据. 或者说想废弃掉这个group了,那不用之后会有什么影响 另外,对于无止尽的customer-group创建,对kafka集群有什么影响吗,当然不仅仅是新group替代旧的group.而是还有在用group的增多,会对集群有什么影响? 下面详细总结下 1. 废弃group的增多个人理解: group增多,增加了对group的管理成本,那对于不用的group,存放在broker中,不会对其它造成影响.目前只是猜测,具体再详细研究. 2. 在用group的增多对于老版本(zk管理customer信息和offset), 会增加customer与zk的交互成本. 新版本(大于0.9), customer信息和offset由broker管理,只是增加了customer与broker的交互, 然而这一部分交互信息对于整个数据流来说微乎其微,所以影响应该不大. 需要在研究下offset更新的流程(customer与broker) 再聊聊kafka的group coordinator Coordinator一般指的是运行在broker上的group Coordinator，用于管理Consumer Group中各个成员，每个KafkaServer都有一个GroupCoordinator实例，管理多个消费者组，主要用于offset位移管理和Consumer Rebalance。 在 Server 端增加了 GroupCoordinator 这个角色 将 topic 的 offset 信息由之前存储在 zookeeper(/consumers//offsets//,zk写操作性能不高) 上改为存储到一个特殊的 topic 中（__consumer_offsets） 1. rebalance时机 有新的consumer加入 旧的consumer挂了 coordinator挂了，集群选举出新的coordinator topic的partition新加 consumer调用unsubscrible()，取消topic的订阅 关于offset的提交,管理 2. __consumer_offsetsConsumer通过发送OffsetCommitRequest请求到指定broker（偏移量管理者）提交偏移量。 这个请求中包含一系列分区以及在这些分区中的消费位置（偏移量） 偏移量管理者会追加键值（key－value）形式的消息到一个指定的topic（__consumer_offsets）。key是由consumerGroup-topic-partition组成的，而value是偏移量。 感觉其实用HashMap应该更好一些,因为通过key来获取或管理offset(偏移量-value) 因为这种存储方式(队列), find的时间复杂度为O(n), 需要遍历整个__consumer_offsets,扫描全部偏移量topic日志. 因此集群的内存中也是维护了一份最近的记录,为了能在指定key的情况下能够快速的给出OffsetFetchRequests而不用扫描全部偏移量topic日志. 如果偏移量管理者因某种原因失败，新的broker将会成为偏移量管理者并且通过扫描偏移量topic来重新生成偏移量缓存。 ps: 内存中应该是Map结构,那内存中的记录与偏移量topic(__consumer_offsets)的数据怎么保证一致性的呢?? 3. Consumer与Consumer Groupconsumer group是kafka提供的可扩展且具有容错性的消费者机制。组内可以有多个消费者或消费者实例(consumer instance)，它们共享一个公共的ID，即group ID。组内的所有消费者协调在一起来消费订阅主题(subscribed topics)的所有分区(partition)。 consumer instance可以是一个进程，也可以是一个线程. 有关offset的几个概念Kafka 之 Group 状态变化分析及 Rebalance 过程","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"}]},{"title":"Kafak环境搭建","date":"2018-11-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Kafka/Kafka环境搭建/","text":"Docker创建kafka数据dev环境123docker run -d --name data-dev --restart always --net=host -e ADV_HOST=172.16.26.193 landoop/fast-data-devbin/kafka-topics.sh --create --zookeeper 172.16.26.193:2181 --replication-factor 1 --partitions 5 --topic my-replicated-topicbin/kafka-topics.sh --alter --zookeeper 127.0.0.1:2181 --partitions 5 --topic nginx_log 下载kafkahttp://kafka.apache.org/quickstart 启动zookeeperbin/zookeeper-server-start.sh config/zookeeper.properties &gt;&gt; zookeeper.out 2&gt;&amp;1 &amp; 启动kafka单机bin/kafka-server-start.sh config/server.properties &gt;&gt;kafka.out 2&gt;&amp;1 &amp; 集群启动bin/kafka-server-start.sh config/server.properties &gt;&gt;kafka-0.out 2&gt;&amp;1 &amp;bin/kafka-server-start.sh config/server-1.properties &gt;&gt;kafka-1.out 2&gt;&amp;1 &amp;bin/kafka-server-start.sh config/server-2.properties &gt;&gt;kafka-2.out 2&gt;&amp;1 &amp; 监控Kafka三款监控工具比较 Kafka监控工具KafkaOffsetMonitor配置及使用 下载KakfaOffsetMonitor 12345java -Xms512M -Xmx512M -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -cp KafkaOffsetMonitor-assembly-0.2.0.jar com.quantifind.kafka.offsetapp.OffsetGetterWeb \\--port 8088 \\--zk 10.0.0.50:12181,10.0.0.60:12181,10.0.0.70:12181 \\--refresh 5.minutes \\--retain 1.day &gt;/dev/null 2&gt;&amp;1; TODO 监控原理 PS: kafka 日志默认保存7天. topic创建1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 5 --topic my-replicated-topic 命令行消费者1bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic nginx_log --from-beginning ubuntu命令行设置系统代理 增加partition1bin/kafka-topics.sh --alter --zookeeper 127.0.0.1:2181 --partitions 10 --topic nginx_log 查看某个topic的 logSize指的是topic各个分区的logSize 1bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --topic nginx_log --time -1 time 为-2 表示查看offset的最小值, -1 表示最大值1bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 -topic nginx_log --time -2 查看消费者组内的offset位置(消费情况)关于kafka更改消费者对应分组下的offset值 12# To view offsets, as mentioned earlier, we &quot;describe&quot; the consumer group like this:bin/kafka-consumer-groups.sh --bootstrap-server api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --group consumer02 --describe Managing Consumer GroupsManaging Consumer Groups 123456# bin/kafka-consumer-groups.sh --bootstrap-server api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --list# provides the list of all active members in the consumer group.bin/kafka-consumer-groups.sh --bootstrap-server api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --describe --group consumer02 --members# bin/kafka-consumer-groups.sh --bootstrap-server api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --describe --group consumer02 --state 更改offset1234# 先查看一下customer的offset状态bin/kafka-consumer-groups.sh --bootstrap-server api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --group consumer02 --describe# reset offsets of a consumer group to the latest offset: (earliest)bin/kafka-consumer-groups.sh --bootstrap-server api.quartz.ren:9092,api.quartz.ren:9093,api.quartz.ren:9094 --reset-offsets --group consumer02 --topic nginx_log --to-latest 以上reset 只能在 consumer inactive状态时,才可以. 问题: 这个操作的目的和结果是什么??? Kafka auto.offset.reset值详解 123456earliest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费 latest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据 none topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Kafka","slug":"数据/数据处理/DataStore/Kafka","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Kafka/"}]},{"title":"pandas总结","date":"2018-11-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/pandas使用总结/","text":"API Referenct https://www.w3cschool.cn/python/dict Pandas-DataFrame基础知识点总结","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"}]},{"title":"pandas读取表格","date":"2018-11-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/pandas处理表格/","text":"1234import pandas as pd data = pd.read_table(&quot;./1.csv&quot;, header=None, sep=&#x27;,&#x27;, nrows = 10)# nrow 参数用来控制读取行数print(data)","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"}]},{"title":"pip 模块安装","date":"2018-11-17T09:10:49.000Z","path":"wk/平台工具/程序语言/Python/模块安装/","text":"pip安装1apt install python3-pip 安装完pip就可以使用它来安装需要的模块。也可以指定安装目录1pip install xgboost --target=/home/work/.local/lib/python2.7/site-packages/ -i https://mirrors.aliyun.com/pypi/simple/ 1https://mirrors.aliyun.com/pypi/simple/","tags":[{"name":"Python","slug":"Python","permalink":"https://quano.gitee.io/tags/Python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"}]},{"title":"Netty学习目录","date":"2018-11-16T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/Netty学习目录/","text":"Java NIO unix网络IO模型 Java IO的演进 四种IO的概念与比较 Netty NIO开发 服务端、客户端Demo Tcp粘包、拆包问题 分隔符和定长解码器的应用 Netty编解码开发 编解码技术（序列化、Protobuf、Thrift、Marshaling） MessagePack编解码 Google Protobuf编解码 JBoss Marshaling编解码 Netty多协议开发 Http协议开发 WebSoket协议开发 私有协议栈开发 私有协议介绍 协议栈功能设计 协议栈功能开发 服务端创建细节客户端创建细节 源码分析 ByteBuf Channel和Unsafe ChannelPipeline和ChannelHandler EventLoop和EventLoopGroup NioEventLoop源码分析 Future和Promise 架构和行业应用 Java NIOunix网络IO模型Java IO的演进四种IO的概念与比较Netty NIO开发服务端、客户端DemoTcp粘包、拆包问题分隔符和定长解码器的应用Netty编解码开发编解码技术（序列化、Protobuf、Thrift、Marshaling）MessagePack编解码Google Protobuf编解码JBoss Marshaling编解码Netty多协议开发Http协议开发WebSoket协议开发私有协议栈开发私有协议介绍协议栈功能设计协议栈功能开发服务端创建细节客户端创建细节源码分析ByteBufChannel和UnsafeChannelPipeline和ChannelHandlerEventLoop和EventLoopGroupNioEventLoop源码分析Future和Promise架构和行业应用已连接netty/README.md","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"读写事件流程分析与相关API","date":"2018-11-16T17:13:34.000Z","path":"wk/MicroService/技术框架/Netty/读写事件流程分析与相关API/","text":"netty5笔记-总体流程分析3-ChannelHandlerContext Netty4学习笔记（1）— ChannelPipeline 处理链处理写操作流程、Pipeline，Context和Handler的协作处理。 netty核心的概念：Channel、Buffer、Selecter ChannelChannel是核心的一个接口，表示一个联络Socket的通道。通过Channel，可以对Socket进行各种操作。 ChannelHandler在实际程序实现中，很少直接操作Channel，而是通过ChannelHandler来间接操纵Channel。（使用策略模式？） ChannelHandler的种类:ChannelHandler接口的子接口 ChannelInboundHandler ChannelOutboundHandler 5.0.0.Alpha1 版本已经没有了这两个接口，why。4.1.5存在。 ChannelPipelineChannelPipeline里有一个双向链表，使用HashMap存放节点。节点类型为：ChannelHandlerContext。 是一个ChandlerHandler的链表。当需要对Channel进行某种处理的时候，Pipeline负责依次调用每一个Handler进行处理。（责任链模式？） 每个Channel都有一个属于自己的Pipeline.(一对一关系) ChannelPipeline的方法有很多，其中一部分是用来管理ChannelHandler的，如下面这些： 12345678910111213ChannelPipeline addFirst(String name, ChannelHandler handler); ChannelPipeline addLast(String name, ChannelHandler handler); ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler); ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler); ChannelPipeline remove(ChannelHandler handler); ChannelHandler remove(String name); ChannelHandler removeFirst(); ChannelHandler removeLast(); ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler); ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler); ChannelHandler first(); ChannelHandler last(); ChannelHandler get(String name); 事件的传播为了搞清楚事件如何在Pipeline里传播， 让我们从Channel的抽象子类AbstractChannel开始： 12345678public abstract class AbstractChannel extends DefaultAttributeMap implements Channel &#123; // ... @Override public Channel write(Object msg) &#123; return pipeline.write(msg); &#125; // ... &#125; 再看DefaultChannelPipeline的write()方法实现 12345678final class DefaultChannelPipeline implements ChannelPipeline &#123; // ... @Override public ChannelFuture write(Object msg) &#123; return tail.write(msg); &#125; // ... &#125; 因为write是个outbound事件，所以DefaultChannelPipeline直接找到tail部分的context，调用其write()方法 接着看DefaultChannelHandlerContext的write()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final class DefaultChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext &#123; // ... @Override public ChannelFuture write(Object msg) &#123; return write(msg, newPromise()); &#125; @Override public ChannelFuture write(final Object msg, final ChannelPromise promise) &#123; if (msg == null) &#123; throw new NullPointerException(&quot;msg&quot;); &#125; validatePromise(promise, true); write(msg, false, promise); return promise; &#125; private void write(Object msg, boolean flush, ChannelPromise promise) &#123; DefaultChannelHandlerContext next = findContextOutbound(); next.invokeWrite(msg, promise); if (flush) &#123; next.invokeFlush(); &#125; &#125; private DefaultChannelHandlerContext findContextOutbound() &#123; DefaultChannelHandlerContext ctx = this; do &#123; ctx = ctx.prev; &#125; while (!ctx.outbound); return ctx; &#125; private void invokeWrite(Object msg, ChannelPromise promise) &#123; try &#123; ((ChannelOutboundHandler) handler).write(this, msg, promise); &#125; catch (Throwable t) &#123; notifyOutboundHandlerException(t, promise); &#125; &#125; // ... &#125; context的write()方法沿着context链往前找，直至找到一个outbound类型的context为止，然后调用其invokeWrite()方法 invokeWrite()接着调用handler的write()方法： ChannelHandlerContextChannelPipeline并不是直接管理ChannelHandler，而是通过ChannelHandlerContext来间接管理，这一点通过ChannelPipeline的默认实现DefaultChannelPipeline可以看出来。 调用ChannelHandlerContext#channel()方法可以得到和Context绑定的Channel，调用ChannelHandlerContext#handler()方法可以得到和Context绑定的Handler。 一个ChannelHandlerContext只能对应一个ChannelHander，只对应一个Channel，而一个ChannelHander则可以对应多个ChannelHandlerContext","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"Netty","slug":"MicroService/技术框架/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/Netty/"}]},{"title":"SpringBoot","date":"2018-11-16T17:13:34.000Z","path":"wk/MicroService/技术框架/SpringBoot/Readme/","text":"Spring Boot 2.0深度实践之核心技术","tags":[{"name":"springboot","slug":"springboot","permalink":"https://quano.gitee.io/tags/springboot/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"SpringBoot","slug":"MicroService/技术框架/SpringBoot","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/SpringBoot/"}]},{"title":"001.Docker镜像加速及常用命令","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Docker/001.Docker镜像加速-常用命令/","text":"Deepin下安装Docker 阿里云.来自云端的容器镜像服务 Docker镜像加速：阿里云 一、镜像加速12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://tabss8zh.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker nvidia-docker增加如下： 123456&quot;runtimes&quot;: &#123; &quot;nvidia&quot;: &#123; &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;, &quot;runtimeArgs&quot;: [] &#125; &#125; 123456789&#123; &quot;registry-mirrors&quot;: [&quot;https://tabss8zh.mirror.aliyuncs.com&quot;], &quot;runtimes&quot;: &#123; &quot;nvidia&quot;: &#123; &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;, &quot;runtimeArgs&quot;: [] &#125; &#125;&#125; 记得重启docker. 二、Docker常用操作命令 查看日志123456docker logs -f -t --since=&quot;2017-05-31&quot; --tail=10 edu_web_1--since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。-f : 查看实时日志-t : 查看日志产生的日期-tail=10 : 查看最后的10条日志。edu_web_1 : 容器名称 三、Docker 容器自定义 hosts 网络访问Docker自定义hosts网络访问 需求：使用自己的域名服务。 在很多应用环境中都会有其他服务器的访问需求。直接使用ip不便于修改。因此搭建自己的域名服务，之后配置docker环境使用此域名服务即可。也可同时使用其它域名服务。 12345(1)resolv-file=/etc/resolv.conf(2)strict-order(3)listen-address=192.168.0.127,127.0.0.1(4)addn-hosts=/etc/hosts //这歌地址指向的是你mac的hosts地址，你只需在里边做相应的 host(5)cache-size=2048 四、Docker镜像管理 搭建Docker私有仓库 更改Docker环境的配置指向私有仓库 向私有仓库提交镜像 从另外的docker环境获取上述镜像 Docker的镜像归纳为两种 需要知道docker容器的地址的类似zk这种组件的 不需要知道docker容器地址类似应用程序通过注册服务到zk，然后自动发现服务。 docker查看运行容器ip1docker inspect 容器ID | grep IPAddress","tags":[{"name":"Docker","slug":"Docker","permalink":"https://quano.gitee.io/tags/Docker/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Docker","slug":"平台工具/工具组件/Docker","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Docker/"}]},{"title":"ES环境搭建","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Elasticsearch/001.ES环境搭建/","text":"Elasticsearch Reference 搭建集群环境下载安装包安装步骤 选择 7.5.0. 更高版本需要jdk9 甚至更高版本. 1wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.0-linux-x86_64.tar.gz 后续下载， 先下载jdk11, 然后下载高版本的 es. 下载并解压 修改配置文件 default ： $ES_HOME/config/elasticsearch.yml 一般需要修改的几个地方如下： 1234567891011121314# 集群名称cluster.name: my-application# 节点名称node.name: node-1# 绑定的IPnetwork.host: 192.168.1.106# 开始发现新节点的IPdiscovery.zen.ping.unicast.hosts: [&quot;192.168.1.108&quot;, &quot;192.168.1.106&quot;]# 最多发现主节点的个数discovery.zen.minimum_master_nodes: 1# 当重启集群节点后最少启动N个节点后开始做恢复gateway.recover_after_nodes: 3# 在一台机器上最多启动的节点数node.max_local_storage_nodes: 1 具体配置文件解释见: elasticsearch配置文件详解 配置集群模式，在其它节点修改以上对应配置项，启动即可。 启动1./bin/elasticsearch -d 异常bootstrap check failure [1] of [2]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]bootstrap check failure [2] of [2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 第二个异常： 原因是 es用户拥有的内存权限太小。 至少需要262144.解决方案： sudo sysctl -w vm.max_map_count=262144 第一个异常：解决方案： vim /etc/security/limits.conf， 添加tensor soft nofile 65536tensor hard nofile 65536 root soft nofile 65536root hard nofile 65536 https://blog.csdn.net/qq_38636133/article/details/105621876 验证： 12ulimit -Huulimit -Su ubuntu 环境不生效. 经过排查，limits.conf这个文件实际是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 pam_limits.so模块的配置文件，然而，ubuntu的PAM默认并没有加载这个模块，导致最后limits.conf里面的配置不生效。 sudo vim /etc/pam.d/su https://mikemiao.com/ubuntu-limits-conf/ 第三个异常：1[2]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured 解决： cluster.initial_master_nodes: [“tensor-es”]node.name: tensor-es 最大文件描述符》》》 ubuntu子系统 没法改. 使用 高版本es. 配置使用高版本的jdk. JAVA11_HOME= 重启win10 子系统12net stop LxssManagernet start LxssManager","tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://quano.gitee.io/tags/elasticsearch/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Elasticsearch","slug":"平台工具/工具组件/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Elasticsearch/"}]},{"title":"ES环境搭建","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Elasticsearch/1.ES环境搭建/","text":"Elasticsearch Reference 搭建集群环境下载安装包安装步骤 下载并解压 修改配置文件 default ： $ES_HOME/config/elasticsearch.yml 一版需要修改的几个地方如下： 1234567891011121314# 集群名称cluster.name: my-application# 节点名称node.name: node-1# 绑定的IPnetwork.host: 192.168.1.106# 开始发现新节点的IPdiscovery.zen.ping.unicast.hosts: [&quot;192.168.1.108&quot;, &quot;192.168.1.106&quot;]# 最多发现主节点的个数discovery.zen.minimum_master_nodes: 1# 当重启集群节点后最少启动N个节点后开始做恢复gateway.recover_after_nodes: 3# 在一台机器上最多启动的节点数node.max_local_storage_nodes: 1 具体配置文件解释见: elasticsearch配置文件详解 配置集群模式，在其它节点修改以上对应配置项，启动即可。 启动1./bin/elasticsearch -d","tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://quano.gitee.io/tags/elasticsearch/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Elasticsearch","slug":"平台工具/工具组件/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Elasticsearch/"}]},{"title":"Python客户端创建索引","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Elasticsearch/Python客户端创建索引/","text":"安装elasticsearch模块 进入python交互界面 引入es的模块1from elasticsearch import Elasticsearch 定义es链接及变量12doc_type = &#x27;log&#x27;es = Elasticsearch(urls = [&#x27;http://192.168.1.108:9200&#x27;,&#x27;http://192.168.1.106:9200&#x27;], timeout = 60, max_retries = 0) 设置mapping 创建索引1es.index(index = &#x27;app-log&#x27;, doc_type=&#x27;log&#x27;, body = mapping) 12345678910111213141516171819202122232425262728293031323334mapping = &#123; &#x27;settings&#x27;: &#123; &#x27;index&#x27;: &#123; &#x27;number_of_replicas&#x27;: 1, &#x27;number_of_shards&#x27;: 6, &#x27;refresh_interval&#x27;: &#x27;5s&#x27; &#125; &#125;, &#x27;mappings&#x27;: &#123; &#x27;_default_&#x27;: &#123; &#x27;_all&#x27;: &#123; &#x27;enabled&#x27;: False &#125; &#125;, doc_type : &#123; &#x27;properties&#x27; : &#123; &#x27;day&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;time&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;nanoTime&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;created&#x27;: &#123; &#x27;type&#x27;: &#x27;date&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;app&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;host&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;thread&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;level&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;eventType&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;pack&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;clazz&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;line&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;messageSmart&#x27;: &#123; &#x27;type&#x27;: &#x27;text&#x27;, &#x27;analyzer&#x27;: &#x27;ik_smart&#x27;, &#x27;search_analyzer&#x27;: &#x27;ik_smart&#x27;, &#x27;include_in_all&#x27;: &#x27;true&#x27;, &#x27;boost&#x27;: 8&#125;, &#x27;messageMax&#x27;: &#123; &#x27;type&#x27;: &#x27;text&#x27;, &#x27;analyzer&#x27;: &#x27;ik_max_word&#x27;, &#x27;search_analyzer&#x27;: &#x27;ik_max_word&#x27;, &#x27;include_in_all&#x27;: &#x27;true&#x27;, &#x27;boost&#x27;: 8&#125; &#125; &#125; &#125; &#125; 验证1curl &#x27;192.168.1.108:9200/_cat/indices?v&#x27; 完整脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python# -*- coding: UTF-8 -*-import sysimport datetimefrom pyelasticsearch import ElasticSearchfrom pyelasticsearch import bulk_chunksdef main(argv): doc_type = &#x27;log&#x27; index = &#x27;app-log&#x27; es = ElasticSearch(urls = [&#x27;http://192.168.1.108:9200&#x27;], timeout = 60, max_retries = 0) mapping = &#123; &#x27;settings&#x27;: &#123; &#x27;index&#x27;: &#123; &#x27;number_of_replicas&#x27;: 1, &#x27;number_of_shards&#x27;: 6, &#x27;refresh_interval&#x27;: &#x27;5s&#x27; &#125; &#125;, &#x27;mappings&#x27;: &#123; &#x27;_default_&#x27;: &#123; &#x27;_all&#x27;: &#123; &#x27;enabled&#x27;: False &#125; &#125;, doc_type : &#123; &#x27;properties&#x27; : &#123; &#x27;day&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;time&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;nanoTime&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;created&#x27;: &#123; &#x27;type&#x27;: &#x27;date&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;app&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;host&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;thread&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;level&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;eventType&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;pack&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;clazz&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125;, &#x27;line&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;index&#x27;: &#x27;not_analyzed&#x27;&#125; # &#x27;messageSmart&#x27;: &#123; &#x27;type&#x27;: &#x27;string&#x27;, &#x27;analyzer&#x27;: &#x27;ik_smart&#x27;, &#x27;search_analyzer&#x27;: &#x27;ik_smart&#x27;, &#x27;include_in_all&#x27;: &#x27;true&#x27;, &#x27;boost&#x27;: 8&#125;, &#125; &#125; &#125; &#125; es.create_index(index = index, settings = mapping)if __name__ == &#x27;__main__&#x27;: main(sys.argv)","tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://quano.gitee.io/tags/elasticsearch/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Elasticsearch","slug":"平台工具/工具组件/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Elasticsearch/"}]},{"title":"Jenkins认识","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Jenkins/1.Jenkins认识/","text":"Jenkins可以做什么？软件开发实践过程中有很多重复性的工作，并且团队成员都需要经常集成他们的工作。 持续集成：一种软件开发实践。通过自动化的构建（包括编译，发布，自动化测试)来验证集成的工作任务。可以尽快的发现集成错误，可以大大减少集成的问题，让团队能够更快的开发内聚的软件。 而Jenkins的定义是一个可扩展的持续集成引擎。 持续集成不仅仅是自动化部署，它的重要性还包含了项目质量的提高以及减少重复的操作等等。 怎么让持续集成的价值体现出来呢？首先从这个持续集成工具开始。 持续集成的要素 1. Jenkins可以做的事最基本的就是项目构建，再就是通过Jenkins的插件围绕构建的一些工作进行自动化。比如以下： 自动化项目构建 自动化测试 自动化部署 Jenkins的强大依赖于很多第三方插件。 2. Jenkins实用插件 iOS专用：Xcode integration Android专用：Gradle plugin Gitlab插件：GitLab Plugin 和 Gitlab Hook Plugin Git插件： Git plugin GitBuckit插件： GitBuckit plugin 签名证书管理插件: Credentials Plugin 和Keychains and Provisioning Profiles Management FTP插件: Publish over FTP 脚本插件: Post-Build Script Plug-in 修改Build名称/描述(二维码)： build-name-setter / description setter plugin 获取仓库提交的commit log： Git Changelog Plugin 自定义全局变量: Environment Injector Plugin 自定义邮件插件： Email Extension Plugin 获取当前登录用户信息： build-user-vars-plugin 显示代码测试覆盖率报表： Cobertura Plugin 来展示生成的单元测试报表，支持一切单测框架，如junit、nosetests等： Junit Plugin 其它： GIT plugin / SSH Credentials Plugin 3. 基础环境配置 maven jdk 参考以下Jenkins Gitlab持续集成打包平台搭建 Jenkins使用 Jenkins系列文章","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://quano.gitee.io/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"https://quano.gitee.io/tags/CI/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Jenkins","slug":"平台工具/工具组件/Jenkins","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Jenkins/"}]},{"title":"Jenkins安装配置","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Jenkins/2.Jenkins安装配置/","text":"1.下载war文件。 下载地址. 2.启动 启动脚本如下： 12#set JENKINS_HOME=nohup java -jar jenkins* --httpPort=8000 --prefix=/jks &gt;&gt; nohup.out 2&gt;&amp;1 &amp; 默认JENKINS_HOME为 .jenkins。默认端口8080 3.验证 在浏览器输入：http://127.0.0.1:8000 4.输入安装密码，进入初始化页面 在启动之后，日志中会出现一个安装密码。打开页面时需要配置。 选择推荐插件模式进行安装。（等5分钟） 5.创建第一个管理员账户（请牢记密码） 6.安装成功","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://quano.gitee.io/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"https://quano.gitee.io/tags/CI/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Jenkins","slug":"平台工具/工具组件/Jenkins","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Jenkins/"}]},{"title":"Jenkins插件使用","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Jenkins/3.Jenkins插件使用/","text":"Version Number Plug-In版本管理：自动生成工单版本（例如201712280。最后一位0代表当天第几次构建）。记录历史构建版本。版本规则可自定义。 Role-based Authorization Strategy项目权限管理：用户只能查看、修改、构建自己相关项目 参考：Jenkins权限控制 这里的项目权限控制，通过项目名称的正则匹配，并没有直接或间接的关联（像通常的管理系统权限管理）。","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://quano.gitee.io/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"https://quano.gitee.io/tags/CI/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Jenkins","slug":"平台工具/工具组件/Jenkins","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Jenkins/"}]},{"title":"Jenkins项目常用配置","date":"2018-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/Jenkins/4.Jenkins项目常用配置/","text":"主要是maven项目的构建 不是父子关系的依赖项目，关联构建 父子关系项目 表示子模块，通过pom.xml中模块关联。两个项目之间互为父子项目。配置如下： 12345678910&lt;modules&gt; &lt;module&gt;aaa&lt;/module&gt; &lt;module&gt;bbb&lt;/module&gt; &lt;module&gt;ccc&lt;/module&gt;&lt;/modules&gt;&lt;parent&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;cc&lt;/artifactId&gt; &lt;version&gt;0001&lt;/version&gt;&lt;/parent&gt; 依赖项目关联构建 不属于上述情况，但项目之间是依赖关系。所以在构建需要的项目时，希望依赖的项目是最新的构建。 对于这种情况，就需要一种jenkins构建方案。目前发现的一种配置方式如下，可供参考。 配置项目如下： 表示：在构建当前项目时，会阻塞去构建依赖的项目，之后再完成当前项目的构建。","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://quano.gitee.io/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"https://quano.gitee.io/tags/CI/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"Jenkins","slug":"平台工具/工具组件/Jenkins","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/Jenkins/"}]},{"title":"Netty学习目录","date":"2018-11-16T17:13:34.000Z","path":"wk/MicroService/技术框架/RPC/Netty/Netty学习目录/","text":"Java NIO unix网络IO模型 Java IO的演进 四种IO的概念与比较 Netty NIO开发 服务端、客户端Demo Tcp粘包、拆包问题 分隔符和定长解码器的应用 Netty编解码开发 编解码技术（序列化、Protobuf、Thrift、Marshaling） MessagePack编解码 Google Protobuf编解码 JBoss Marshaling编解码 Netty多协议开发 Http协议开发 WebSoket协议开发 私有协议栈开发 私有协议介绍 协议栈功能设计 协议栈功能开发 服务端创建细节客户端创建细节 源码分析 ByteBuf Channel和Unsafe ChannelPipeline和ChannelHandler EventLoop和EventLoopGroup NioEventLoop源码分析 Future和Promise 架构和行业应用 Java NIOunix网络IO模型Java IO的演进四种IO的概念与比较Netty NIO开发服务端、客户端DemoTcp粘包、拆包问题分隔符和定长解码器的应用Netty编解码开发编解码技术（序列化、Protobuf、Thrift、Marshaling）MessagePack编解码Google Protobuf编解码JBoss Marshaling编解码Netty多协议开发Http协议开发WebSoket协议开发私有协议栈开发私有协议介绍协议栈功能设计协议栈功能开发服务端创建细节客户端创建细节源码分析ByteBufChannel和UnsafeChannelPipeline和ChannelHandlerEventLoop和EventLoopGroupNioEventLoop源码分析Future和Promise架构和行业应用已连接netty/README.md","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Netty","slug":"MicroService/技术框架/RPC/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/Netty/"}]},{"title":"读写事件流程分析与相关API","date":"2018-11-16T17:13:34.000Z","path":"wk/MicroService/技术框架/RPC/Netty/读写事件流程分析与相关API/","text":"netty5笔记-总体流程分析3-ChannelHandlerContext Netty4学习笔记（1）— ChannelPipeline 处理链处理写操作流程、Pipeline，Context和Handler的协作处理。 netty核心的概念：Channel、Buffer、Selecter ChannelChannel是核心的一个接口，表示一个联络Socket的通道。通过Channel，可以对Socket进行各种操作。 ChannelHandler在实际程序实现中，很少直接操作Channel，而是通过ChannelHandler来间接操纵Channel。（使用策略模式？） ChannelHandler的种类:ChannelHandler接口的子接口 ChannelInboundHandler ChannelOutboundHandler 5.0.0.Alpha1 版本已经没有了这两个接口，why。4.1.5存在。 ChannelPipelineChannelPipeline里有一个双向链表，使用HashMap存放节点。节点类型为：ChannelHandlerContext。 是一个ChandlerHandler的链表。当需要对Channel进行某种处理的时候，Pipeline负责依次调用每一个Handler进行处理。（责任链模式？） 每个Channel都有一个属于自己的Pipeline.(一对一关系) ChannelPipeline的方法有很多，其中一部分是用来管理ChannelHandler的，如下面这些： 12345678910111213ChannelPipeline addFirst(String name, ChannelHandler handler); ChannelPipeline addLast(String name, ChannelHandler handler); ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler); ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler); ChannelPipeline remove(ChannelHandler handler); ChannelHandler remove(String name); ChannelHandler removeFirst(); ChannelHandler removeLast(); ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler); ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler); ChannelHandler first(); ChannelHandler last(); ChannelHandler get(String name); 事件的传播为了搞清楚事件如何在Pipeline里传播， 让我们从Channel的抽象子类AbstractChannel开始： 12345678public abstract class AbstractChannel extends DefaultAttributeMap implements Channel &#123; // ... @Override public Channel write(Object msg) &#123; return pipeline.write(msg); &#125; // ... &#125; 再看DefaultChannelPipeline的write()方法实现 12345678final class DefaultChannelPipeline implements ChannelPipeline &#123; // ... @Override public ChannelFuture write(Object msg) &#123; return tail.write(msg); &#125; // ... &#125; 因为write是个outbound事件，所以DefaultChannelPipeline直接找到tail部分的context，调用其write()方法 接着看DefaultChannelHandlerContext的write()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final class DefaultChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext &#123; // ... @Override public ChannelFuture write(Object msg) &#123; return write(msg, newPromise()); &#125; @Override public ChannelFuture write(final Object msg, final ChannelPromise promise) &#123; if (msg == null) &#123; throw new NullPointerException(&quot;msg&quot;); &#125; validatePromise(promise, true); write(msg, false, promise); return promise; &#125; private void write(Object msg, boolean flush, ChannelPromise promise) &#123; DefaultChannelHandlerContext next = findContextOutbound(); next.invokeWrite(msg, promise); if (flush) &#123; next.invokeFlush(); &#125; &#125; private DefaultChannelHandlerContext findContextOutbound() &#123; DefaultChannelHandlerContext ctx = this; do &#123; ctx = ctx.prev; &#125; while (!ctx.outbound); return ctx; &#125; private void invokeWrite(Object msg, ChannelPromise promise) &#123; try &#123; ((ChannelOutboundHandler) handler).write(this, msg, promise); &#125; catch (Throwable t) &#123; notifyOutboundHandlerException(t, promise); &#125; &#125; // ... &#125; context的write()方法沿着context链往前找，直至找到一个outbound类型的context为止，然后调用其invokeWrite()方法 invokeWrite()接着调用handler的write()方法： ChannelHandlerContextChannelPipeline并不是直接管理ChannelHandler，而是通过ChannelHandlerContext来间接管理，这一点通过ChannelPipeline的默认实现DefaultChannelPipeline可以看出来。 调用ChannelHandlerContext#channel()方法可以得到和Context绑定的Channel，调用ChannelHandlerContext#handler()方法可以得到和Context绑定的Handler。 一个ChannelHandlerContext只能对应一个ChannelHander，只对应一个Channel，而一个ChannelHander则可以对应多个ChannelHandlerContext","tags":[{"name":"Netty","slug":"Netty","permalink":"https://quano.gitee.io/tags/Netty/"}],"categories":[{"name":"MicroService","slug":"MicroService","permalink":"https://quano.gitee.io/categories/MicroService/"},{"name":"技术框架","slug":"MicroService/技术框架","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/"},{"name":"RPC","slug":"MicroService/技术框架/RPC","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/"},{"name":"Netty","slug":"MicroService/技术框架/RPC/Netty","permalink":"https://quano.gitee.io/categories/MicroService/%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/RPC/Netty/"}]},{"title":"Something","date":"2018-03-09T03:55:57.000Z","path":"wk/项目管理/生活学习/生活/","text":"卡耐基在《人性的弱点》一书中讲述了忙里偷闲的方法，就是让我们学习那松松放置的袜子，很随意，也很自然，不与任何事物较劲儿。这样的放松，才能摆脱由紧张与压力所造成的焦虑。 我之所以没有留在无锡，没有考研．一方面是因为不想再被困在仅仅的学习中，我希望我以后的选择是自由的．可以想去那里，想有什么样的工作．不想为了一些事情被绑架，失去自由． 生活不仅是一种追逐，更是一种领悟和享受！ 其实，生活轻松与紧张都是相对的，要想不累，就要学会让自己的心情松弛下来。生活理应是有张有弛的，如果累了就停一停，生活没有奋斗的终点，并不是只争朝夕。要学会释放自己，学会忙里偷闲的时候给自己的心情放个假，去郊外山野走一走，听听音乐，看看书，与朋友聊聊天，就会找回那种最自然的轻松感觉。 其实，太过于追求完美，才是心灵的桎梏，不是吗？没完没了地加班加点，让你没有时间欣赏生活的美好，毫无休止的追句逐利，让你没有余暇体味幸福的甜蜜。其实，这样的生活，无疑是给自己施加了太大的压力，非但不会实现自己想要的生活，还会遗失那份”闲云野鹤“悠然心境。 http://news.163.com/12/0120/02/7O68KJJ700014AED_all.html 星座话题，衣服审美 有时候会发现努力的方向不对，你觉得目前的状态收获大吗，效率高吗.如果没有，为什么不去做一些这个年纪想做的事，铺垫一些未来．做一些环境准备． 很多新内容的学习认识，学会都很大程度受环境前提的影响． 2022.11.10最近看到这样一段话 把时间分给睡眠、 分给书籍、分给运动、分给花鸟树木和山川湖海 分给你对这个世界的热爱 而不是将自己浪费在无聊的人和事上 当你开始做时间的主人 你会感受到 平淡生活中 喷涌而出的 平静的力量 至于那些焦虑和不安 自然烟消云散.","tags":[{"name":"Life","slug":"Life","permalink":"https://quano.gitee.io/tags/Life/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"生活学习","slug":"项目管理/生活学习","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}]},{"title":"非技术问题","date":"2018-03-09T03:55:57.000Z","path":"wk/项目管理/软件工程/问题/关于非技术类的几个问题/","text":"别人的一些经历,经验,需要学习的地方,思想 有关管理,交流的问题,人的管理.","tags":[{"name":"其它","slug":"其它","permalink":"https://quano.gitee.io/tags/%E5%85%B6%E5%AE%83/"}],"categories":[{"name":"项目管理","slug":"项目管理","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"软件工程","slug":"项目管理/软件工程","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"问题","slug":"项目管理/软件工程/问题","permalink":"https://quano.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%97%AE%E9%A2%98/"}]},{"title":"Hadoop学习资料","date":"2018-02-16T04:56:24.000Z","path":"wk/数据/数据处理/DataStore/Hadoop/Hadoop学习资料/","text":"hadoop-notebook HDFS MapReduce Yarn HDFShdfs架构图Hadoop核心之HDFS 架构设计 数据块 NameNode DataNode SecondaryNameNode 各自的作用 MapReduceMapreduce是一个计算框架。 MapReduce讲的就是分而治之的程序处理理念。 MapReduce的根本原则是信息处理的本地化，哪台PC持有相应要处理的数据，哪台PC就负责处理该部分的数据，这样做的意义在于可以减少网络通讯负担。 学习的demo Welcome to the Hadoop installed wiki! 以下是相关资料 搭建hadoop-2.6.0-cdh5.4.7伪分布式 apache hadoop-2.6.0-CDH5.4.1 安装:完全分布式 官网：Hadoop分布式文件系统：架构和设计 Yarn 和MapReduce比较 HBase 默认配置 基于CDH5.4.5（ha）的Hbase 3节点搭建 分布式系统概述（Hadoop与HBase的前生今世） HBase介绍、搭建、环境、安装部署:架构、数据结构、原理 zk的作用及spark HBase之单机模式与伪分布式模式安装 HBase命令及数据结构//TODO HBase HMaster的作用： 为Region server分配region负责Region server的负载均衡发现失效的Region server并重新分配其上的regionHDFS上的垃圾文件回收处理schema更新请求 HRegionServer作用： 维护master分配给他的region，处理对这些region的io请求负责切分正在运行过程中变的过大的region可以看到，client访问HBase上的数据并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server），master仅仅维护table和region的元数据信息（table的元数据信息保存在zookeeper上），负载很低。HRegionServer存取一个子表时，会创建一个HRegion对象，然后对表的每个列族创建一个Store实例，每个Store都会有一个MemStore和0个或多个StoreFile与之对应，每个StoreFile都会对应一个HFile， HFile就是实际的存储文件。因此，一个HRegion有多少个列族就有多少个Store。一个HRegionServer会有多个HRegion和一个HLog。Welcome to the Hadoop installed wiki! 以下是相关资料 搭建hadoop-2.6.0-cdh5.4.7伪分布式 apache hadoop-2.6.0-CDH5.4.1 安装:完全分布式 官网：Hadoop分布式文件系统：架构和设计 Yarn 和MapReduce比较 HBase 默认配置 基于CDH5.4.5（ha）的Hbase 3节点搭建 分布式系统概述（Hadoop与HBase的前生今世） HBase介绍、搭建、环境、安装部署:架构、数据结构、原理 zk的作用及spark HBase之单机模式与伪分布式模式安装 HBase命令及数据结构//TODO HBaseHMaster的作用：为Region server分配region负责Region server的负载均衡发现失效的Region server并重新分配其上的regionHDFS上的垃圾文件回收处理schema更新请求 HRegionServer作用：维护master分配给他的region，处理对这些region的io请求负责切分正在运行过程中变的过大的region可以看到，client访问HBase上的数据并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server），master仅仅维护table和region的元数据信息（table的元数据信息保存在zookeeper上），负载很低。HRegionServer存取一个子表时，会创建一个HRegion对象，然后对表的每个列族创建一个Store实例，每个Store都会有一个MemStore和0个或多个StoreFile与之对应，每个StoreFile都会对应一个HFile， HFile就是实际的存储文件。因此，一个HRegion有多少个列族就有多少个Store。一个HRegionServer会有多个HRegion和一个HLog。 已连接data/bigdata/hadoop-learning/resources.md","tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://quano.gitee.io/tags/hadoop/"}],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Hadoop","slug":"数据/数据处理/DataStore/Hadoop","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Hadoop/"}]},{"title":"3.Java8Stream","date":"2018-01-21T17:55:57.000Z","path":"wk/平台工具/程序语言/Java/Java8Stream/","text":"12345List&lt;Vo&gt; results = voList.stream().collect(Collectors.groupingBy(this::fetchKey)).values() .stream().map(vo -&gt; vo.stream().reduce((vo1, vo2) -&gt; &#123; vo1.setCount(vo1.getCount() + vo2.getCount()); return vo1; &#125;).orElse(new Vo())).collect(Collectors.toList());","tags":[],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"平台工具/程序语言/Java","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"3.ES常用API","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/3.ES常用api/","text":"常用API 查看所有索引1http://yun.quartz.ren:9200/_cat/indices?v 索引和搜索文档索引里面还有类型的概念，在索引文档之前要先设置类型type 查询所有文档(索引的所有文档) 1234GET /lagou_job/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 查看索引结构其他语言的APIpython API","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"2.ES环境搭建","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/2.ES环境搭建/","text":"Docker安装esInstall Elasticsearch with Docker es 建议先手动安装. head 插件可以使用doker创建 12345docker pull elasticsearchdocker run -d -p 9200:9200 --name=es-for-dev elasticsearch或者docker pull registry.docker-cn.com/library/elasticsearchdocker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -d -p 9200:9200 -p 9300:9300 --name myes 使用另外一个镜像做head插件 1docker run --name elasticsearch-head -d -p 9100:9100 mobz/elasticsearch-head:5 使用docker可视化界面管理容器 1docker run --name docker-ui -d -p 9000:9000 --privileged -v /var/run/docker.sock:/var/run/docker.sock uifd/ui-for-docker 安装kibana1docker run -it -d -e ELASTICSEARCH_URL=http://127.0.0.1:9200 --name kibana -p 5601:5601 kibana:5.6.12 版本和es最好对应，这里还注意127.0.0.1是有问题，docker内部的127会访问不到外部 ES本地安装包安装下载 elasticsearch-6.3.2.tar.gz. 1wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.2.zip 解压后:修改配置文件,添加 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 上述是由于head插件和es 之间存在跨域问题(两个进程),需要给权限 https://www.jianshu.com/p/f80fb1dd842b 如果需要其他网络可以访问（不是同一个地址），需要设置如下： 1network.host: 0.0.0.0 这个时候可能会启动失败，解决：https://www.cnblogs.com/phpper/p/9803934.html https://www.cnblogs.com/hongdada/p/7887455.html 修改后重启吧，很恶心.（目前找到的资料是只能重启） 终极解决方案，新建用户．应该是当前用户有限制，会覆盖系统设置的max file limit. 或者好用的12非常简单好用docker run -d -p 9200:9200 -p 5601:5601 nshou/elasticsearch-kibana 12# 启动bin/elasticsearch -d 安装插件analysis-ik1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.2/elasticsearch-analysis-ik-6.3.2.zip https://github.com/medcl/elasticsearch-analysis-ik 安装sql插件1./bin/elasticsearch-plugin install https://github.com/NLPchina/elasticsearch-sql/releases/download/6.3.2.0/elasticsearch-sql-6.3.2.0.zip https://github.com/NLPchina/elasticsearch-sql 其他插件https://www.elastic.co/guide/en/elasticsearch/plugins/6.3/analysis.html 安装kibana1wget https://artifacts.elastic.co/downloads/kibana/kibana-6.3.2-linux-x86_64.tar.gz http://www.quartz.ren:5601/app/kibana#/home?_g=())","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"4.权限设置","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/4.ES权限设置/","text":"参考 开启权限 12curl -H &quot;Content-Type:application/json&quot; -XPOST http://yun.quartz.ren:9200/_xpack/license/start_trial?acknowledge=true 修改es的配置 12添加xpack.security.enabled: true 设置用户名和密码详见 1bin/elasticsearch-setup-passwords interactive 重要: 在Kibana中配置Security 添加用户,角色等操作. 6.3版本x-pack破解","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"7.ES核心-Lucene","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Elasticsearch/7.Es核心Lucene/","text":"Elasticsearch 基于 Lucene，隐藏其复杂性，并提供简单易用的 Restful API接口、Java API 接口。所以理解 ES 的关键在于理解 Lucene 的基本原理。","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Elasticsearch","slug":"数据/数据处理/DataStore/Elasticsearch","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Elasticsearch/"}]},{"title":"Mongo基础-相关命令行-Docker","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mongo/Mongo基础-Docker环境及相关命令/","text":"Docker安装mongo12docker pull mongodocker run --name mongo-server -p 27017:27017 -v /data/mongo/db:/data/db -d mongo 使用mongo镜像执行mongo命令了连接容器 1docker run -it mongo mongo --host 172.17.0.2 相关命令1234命令行登陆数据库（类似 mysql -uroot -p -h）mongo --port 27017use admindb.auth(&quot;adminUser&quot;, &quot;adminPass&quot;) 1234567891011&gt; 查看数据库show databases; // 或者 show dbs;&gt; 创建数据库use new_db; //只有插入数据,db才会真正创建.&gt; 创建集合后要再插入一个文档(记录)db.test.insert(&#123;&quot;name&quot;:&quot;菜鸟&quot;&#125;)&gt; 删除数据库db; // 查看当前数据库db.dropDatabase();//删除当前数据库&gt; 集合的删除db.collection.drop(); // 在当前数据库下的集合 12&gt; 查看集合show collections 开启权限验证1mongod --auth --dbpath &quot;/data/db&quot; 开启docker中的mongodb认证授权 集合创建集合创建 集合(collection)和table的区别? 创建固定大小的集合 123db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; ) 文档文档的数据结构和JSON基本一样。所有存储在集合中的数据都是BSON格式。BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。 1234567db.col.insert(&#123;title: &#x27;MongoDB 教程&#x27;, description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;, by: &#x27;菜鸟教程&#x27;, url: &#x27;http://www.runoob.com&#x27;, tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;], likes: 100&#125;) 查看已经插入的文档 1db.col.find() 也可以将数据定义为一个变量,然后插入 12345678document=(&#123;title: &#x27;MongoDB 教程&#x27;, description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;, by: &#x27;菜鸟教程&#x27;, url: &#x27;http://www.runoob.com&#x27;, tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;], likes: 100&#125;);db.col.insert(document); 文档更新语法MongoDB 更新文档 123456789101112131415161718192021222324252627282930db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)例如:db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;&#125;)db.col.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 100&#125;以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。&gt;db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;&#125;,&#123;multi:true&#125;) 删除文档MongoDB 删除文档 查询文档MongoDB 查询文档 MongoDB 条件操作符 MongoDB $type 操作符 MongoDB 索引MongoDB 索引 创建索引语法: 1db.collection.createIndex(keys, options) MongoDB JavaMongoDB Java","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mongo","slug":"数据/数据处理/DataStore/Mongo","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mongo/"}]},{"title":"Mongo环境搭建配置-客户端","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mongo/Mongo环境配置/","text":"下载安装https://www.mongodb.com/download-center/community?jmp=nav 客户端连接新mongo环境 mongo mongodb://127.0.0.1:27017然后创建账号并授权.mongo mongodb://nlp:nlp@192.168.1.42:27017 参考:https://www.mongodb.org.cn/tutorial/7.html 123show dbsuse `dbName` Docker整合Prometheus、Grafana监控MongoDBDocker整合Prometheus、Grafana监控MongoDB 12# 启动 mongodb_exporter 监控mongodocker run -d --name mongodb_exporter -p 9104:9001 chux0519/mongodb_exporter --mongodb.uri mongodb://192.168.0.103:27017 另一种方式。 先进行镜像编译. {镜像太大太复杂。不建议了} 12git clone git@github.com:dcu/mongodb_exporter.gitdocker build -t mongodb_exporter . 问题 eses/mongodb_exporter 没有找到现成的grafana面板. elarasu/mongodb_exporter 基于 dcu/mongodb_exporter.https://github.com/percona/mongodb_exporter 其他镜像都和 监控面板不匹配。 chux0519/mongodb_exporter 和 https://grafana.com/grafana/dashboards/2583 匹配。 另外一些其他监控指标可以后续了解支持. Prometheus 添加配置 12345678910# 进入 Prometheus 的容器. 修改配置docker exec -it prometheus vi /etc/prometheus/prometheus.yml # 添加一下job - job_name: &#x27;mongodb&#x27; static_configs: - targets: [&#x27;192.168.0.103:9104&#x27;] labels: instance: mongodb 检查 是否正常http://localhost:9090/targets 获取grafana json配置https://grafana.com/grafana/dashboards?search=mongo&amp;orderBy=name&amp;direction=asc找到适合的仪表盘. mongodb_replset_member_state 请大家为西银高铁、西部交通辛勤付出的同志们投一票,非常感谢, 请选择马校伟,李全,何俊.","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mongo","slug":"数据/数据处理/DataStore/Mongo","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mongo/"}]},{"title":"使用python添加数据到mongo","date":"2018-01-21T17:55:57.000Z","path":"wk/数据/数据处理/DataStore/Mongo/使用python添加数据到Mongo/","text":"123456789101112131415161718192021222324252627282930313233343536import pymongoimport jsonclient = pymongo.MongoClient(&quot;localhost&quot;, 27017)db = client.test# print (db.name)# print (db.my_collection)# db.my_collection.insert_one(&#123;&quot;x&quot;: 10&#125;).inserted_id# create collection . 可以不用创建,插入数据会自动创建## db.createCollection(&quot;UserBehavior&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 100000 &#125; )fo = open(&quot;/home/zhangquanquan/workspace/stream-project/my-flink-project/src/main/resources/UserBehavior.csv&quot;, &quot;r&quot;)print (&quot;文件名为: &quot;, fo.name)fileList = fo.readlines()fo.close()for line in fileList: line = line.strip() lineItem = line.split(&quot;,&quot;) ub = &#123;&#125; ub[&#x27;userId&#x27;] = lineItem[0] ub[&#x27;itemId&#x27;] = lineItem[1] ub[&#x27;categoryId&#x27;] = lineItem[2] ub[&#x27;behavior&#x27;] = lineItem[3] ub[&#x27;timestamp&#x27;] = lineItem[4] json_ub = json.dumps(ub) db.user_behavior.insert(ub) # 批量插入,可以使用 db.collection.insertMany([&#123;&quot;b&quot;: 3&#125;, &#123;&#x27;c&#x27;: 4&#125;]) # print (json_ub)print (&quot;finished.&quot;)# for item in db.my_collection.find().sort(&quot;x&quot;, pymongo.ASCENDING):# print(item[&quot;x&quot;])","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Mongo","slug":"数据/数据处理/DataStore/Mongo","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Mongo/"}]},{"title":"Oracle批量测试数据生成","date":"2018-01-08T03:55:57.000Z","path":"wk/数据/数据处理/DataStore/Oracle/Oracle批量测试数据生成/","text":"oracle使用declare 1234567891011121314declarei integer; --定义变量 begin i := 1;loop /* 插入数据: 自定义 */INSERT INTO table VALUES(i, &#x27;20171016&#x27;);/* 参数递增 */i := i + 1;/* 停止条件 */ exit when i &gt; 100000; end loop;commit;end;","tags":[],"categories":[{"name":"数据","slug":"数据","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据处理","slug":"数据/数据处理","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"DataStore","slug":"数据/数据处理/DataStore","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/"},{"name":"Oracle","slug":"数据/数据处理/DataStore/Oracle","permalink":"https://quano.gitee.io/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/DataStore/Oracle/"}]},{"title":"ActiveMQ介绍","date":"2017-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/ActiveMQ/ActiveMQ介绍/","text":"使用方式（嵌入模式、集群模式） 概念：具体某一个队列、整个队列的创建、使用。一个broker 连接方式（连接池？） 支持协议 几个端口作用、以及监控实现 消息模式（发送订阅和点对点消息） 与其它消息队列比较 消息确认机制（事物） ActiveMQ的设置消息时长，事务，确认机制 ，持久化(六)（http://blog.csdn.net/u014401141/article/details/54772847） 集群方案（内嵌代理所引发的问题：消息过载、管理混乱） 队列使用 讲解流程前言：断连导致消息丢失问题，消费者没有中断。1、队列的优点，大概说一下（异步、系统之间解耦）2、队列的使用场景，复杂的交易系统消息异步，实现系统解耦合。 3、activemq相关（几个端口，支持的协议，应用的连接方式，队列的详细：broker、及队列及管理）消息模式，消息时长的设置，事务，持久化机制。4、我们对activemq的应用，应用内嵌模式。及用了之后的好处(异步，提高系统性能、缓冲或者流量削峰，降低系统压力、防止不正常因素&lt;系统停止，连接断连，&gt;导致消息丢失，持久化消息)或者说弥合 生产者和消费者速度和稳定性 不一致的差异。实现系统间解耦。 举例，之前的积分系统，需要请求账户系统做积分增加。但账户系统某一天凌晨2点会停机升级。那这个积分就加不上了。目前系统中的断连的情况，没有消息队列，消息只能丢失，或者没有好的处理方式防止丢失。 为什么需要消息队列 系统的性能（并发量，吞吐量，响应时间）会有瓶颈 聊聊QPS/TPS/并发量/系统吞吐量的概念 短信发送时间肯定能达到1000，但完成单个事务的平均处理时间受到数据库操作的影响，两个同步数据库操作，一个insert，一个update。所以最多处理一秒1000个比较难。做一些细节的优化。 数据库优化","tags":[{"name":"activemq","slug":"activemq","permalink":"https://quano.gitee.io/tags/activemq/"},{"name":"mq","slug":"mq","permalink":"https://quano.gitee.io/tags/mq/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"ActiveMQ","slug":"平台工具/工具组件/ActiveMQ","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/ActiveMQ/"}]},{"title":"ActiveMQ分享","date":"2017-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/ActiveMQ/ActiveMQ分享/","text":"队列的优点总结整理实际应用 具体使用的细节 消费者线程的问题，以及队列使用模式/流程 队列的优点、有哪些场景以及好处、其中包括我们使用队列的场景 我们使用队列的流程以及短信消息处理的流程 队列相关的概念（broker、创建一个队列） 交互的协议介绍、及各个端口的作用、连接方式（协议、连接池） 消息模式：我们使用的、还有其他模式 集群与单点 消息的流程、有哪些线程。可以知道在哪个环境出问题。 提升系统的稳定性提升响应速度","tags":[{"name":"activemq","slug":"activemq","permalink":"https://quano.gitee.io/tags/activemq/"},{"name":"mq","slug":"mq","permalink":"https://quano.gitee.io/tags/mq/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"ActiveMQ","slug":"平台工具/工具组件/ActiveMQ","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/ActiveMQ/"}]},{"title":"Jupyter","date":"2017-11-16T17:13:34.000Z","path":"wk/平台工具/程序语言/Python/jupyter/1.什么是jupyter/","text":"Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。 Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等. 运行Jupyter Notebook12# 查看帮助文档jupyter notebook -h 123456# 启动jupyter notebook# 指定端口启动jupyter notebook --port &lt;port_number&gt;# 启动不打开浏览器jupyter notebook --no-browser 主页面当执行完启动命令之后，浏览器将会进入到Notebook的主页面，如下图所示。","tags":[{"name":"python","slug":"python","permalink":"https://quano.gitee.io/tags/python/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"程序语言","slug":"平台工具/程序语言","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"平台工具/程序语言/Python","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/"},{"name":"jupyter","slug":"平台工具/程序语言/Python/jupyter","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/jupyter/"}]},{"title":"Wiki Start","date":"2017-02-16T04:56:24.000Z","path":"wk/WikiStart/","text":"Welcome Nova’s Wiki为什么要有这个章节呢？整理这本零散的书，只是想把遇到的一些问题，技术做一个总结。积累下来。 而作为一名技术人员。计算机的基础是很重要的。很多程序员都是每天在复制粘贴，完成一些业务逻辑。高级一点再就是复制别的一些很不错的code，引用过来。 但是对于比较深的技术方案，生产问题，技术架构，基础知识在这里起着至关重要的作用。 大多数技术蜻蜓点水的了解是需要的，但更需要对某个点更深层次的学习。这样才会在一些领域站住脚跟。 虽然说计算机行业技术更新速度日新月异，但基础知识也就是那些，变动还是不会太大。 所以，要想做一些更深层次的事，就待学习一个东西到更深的层次，同时学习好基础。come on。 感兴趣也可以关注我的博客 My Wiki Build项目地址 wiki项目源码(master)和部署文件(gh-pages)都在 https://gitee.com/quano/quano.Gitee Pages部署. wiki的文章[_post]位置: https://gitee.com/quano/notebook/tree/master/z_wiki_post. wiki环境搭建 拉取wiki项目源码(master分支). 安装node、npm、hexo. 使用hexo搭建. 文章更新a. 编辑：通过编辑软件(sublime等)编辑[notebook.z_wiki_post]，然后_posts cp 到 wiki的项目源码b. 发布：通过wiki的项目源码，在本地执行 hexo deploy 进行发布（发布后需要在gitee上手动更新Pages服务哦） 12345# 本地_posts cp的脚本. (见notebook/z_script/local_build_wiki.md)rm -rf /Users/zhangquanquan/quano/wiki/source/_posts/*cp -r ~/Documents/notebook_east/z_wiki_post/* /Users/zhangquanquan/quano/wiki/source/_posts/cd /Users/zhangquanquan/quano/wiki/hexo s 环境安装 安装nodejs 环境 https://www.quartz.ren/2017/10/12/nodejs-env/ 安装hexo 123456npm install -g hexo-cli...等好长时间ln -s /opt/node-v4.4.4-linux-x86/bin/hexo /usr/local/bin/hexo## 加速方案npm install -g hexo-cli --registry=http://registry.npm.taobao.org 创建hexo项目-建站 https://hexo.io/zh-cn/docs/setup 使用Wikitten主题 https://github.com/zthxxx/hexo-theme-Wikitten 主要的命令如下: 123456git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikittencp -rf themes/Wikitten/_source/* source/cp -rf themes/Wikitten/_scaffolds/* scaffolds/cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml# edit and customize itvim themes/Wikitten/_config.yml 一些其他的配置 gitee 编辑环境 不错的vpn推荐 https://wiki.zthxxx.me/wiki/index/ Hexo Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"wiki","slug":"wiki","permalink":"https://quano.gitee.io/tags/wiki/"},{"name":"hexo","slug":"hexo","permalink":"https://quano.gitee.io/tags/hexo/"}],"categories":[]},{"title":"Git使用规范","date":"2015-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/IDE/Git使用规范/","text":"Git使用流程的规范. 目的: 避免杂乱无章的commit,从而让项目难以协调和维护。避免合并代码导致的丢失。 一.新建分支每次开发新功能。都需要从最新的master新建分支。 123456# 获取主干最新代码$ git checkout master$ git pull# 新建一个开发分支myfeature$ git checkout -b myfeature 二.提交分支commit分支功能开发修改后，就可以提交commit了。 123$ git add --all # 需要提交全部修改的话通过使用--all. 或者[git add .] $ git status$ git commit --verbose 如果是commit指定的几个文件. 12git status 查看变动的文件之后git add $&#123;需要提交的文件&#125; git add 只是将文件修改添加到了暂存区。git commit提交更改，是把暂存区的所有内容提交到当前分支。 Git工作区和暂存区 三.撰写提交信息完整的功能开发，或者重要的修改迭代点给出完整扼要的提交信息。下面是一个范本 12345678主题内容（一行不超过50字的提要）罗列出改动原因、主要变动、以及需要注意的问题。例如:标黄公司GpsWifi策略需求开发- 增加过滤大厂，增加过滤保险公司接口变量- 增加命中标黄类型处理逻辑 简单的改动使用一行改动的主题说明即可。格式可以是：1234增加$&#123;什么内容&#125;修改$&#123;什么内容&#125;优化$&#123;什么内容&#125;修复$&#123;什么内容&#125; 四.与主干同步分支的开发过程中，要经常与主干保持同步。 12$ git fetch origin$ git rebase origin/master 五.合并commit分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。 那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。 1$ git rebase -i origin/master","tags":[{"name":"Git","slug":"Git","permalink":"https://quano.gitee.io/tags/Git/"},{"name":"版本管理","slug":"版本管理","permalink":"https://quano.gitee.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"IDE","slug":"平台工具/工具组件/IDE","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/IDE/"}]},{"title":"Git学习","date":"2015-11-16T17:13:34.000Z","path":"wk/平台工具/工具组件/IDE/Git学习/","text":"svn与git的比较 时光机穿梭 git的分支管理 git的命令 svn与git的比较集中式vs分布式分支管理版本管理（回退-某个文件、整个项目工程） 时光穿梭机Git会把所有人的提交串成一条时间线。（使用可视化工具可以清楚的看到） git reset ： 版本回退（回到过去，回到将来） git reflog ： 查看每一次命令 工作区、暂存区git的命令分为两种 一种是本地仓库相关的。另一种是提交远程仓库的","tags":[{"name":"Git","slug":"Git","permalink":"https://quano.gitee.io/tags/Git/"},{"name":"版本管理","slug":"版本管理","permalink":"https://quano.gitee.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"平台工具","slug":"平台工具","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/"},{"name":"工具组件","slug":"平台工具/工具组件","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/"},{"name":"IDE","slug":"平台工具/工具组件/IDE","permalink":"https://quano.gitee.io/categories/%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%BB%84%E4%BB%B6/IDE/"}]}]}